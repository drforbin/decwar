% .SGNAM will be obsolete; please use GETTAB .GTRFN instead.
% .SGPPN will be obsolete; please use GETTAB .GTRDI instead.
% .SGDEV will be obsolete; please use GETTAB .GTRDV instead.
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 1
WARMAC	MAC	 7-Jul-;2 18:15		Macro definitions

					;	This file is part of Decwar.
					;	Copyright 1979, 2011 Bob Hysick, Jeff Potter, The University of Texas
					;	Computation Center and Harris Newman.

					;	This program is free software; you can redistribute it and/or modify
					;	it under the terms of the GNU General Public License as published by
					;	the Free Software Foundation; either version 3, or (at your option)
					;	any later version.

					;	This program is distributed in the hope that it will be useful,
					;	but WITHOUT ANY WARRANTY; without even the implied warranty of
					;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
					;	GNU General Public License for more details.

					;	You should have received a copy of the GNU General Public License
					;	along with this program; if not, write to the Free Software
					;	Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
					;	02110-1301, USA.  


						title	WARMAC -- MACRO support routines for DECWAR.FOR

		777777	777777			%deb%==-1

	400000'					twoseg
						search	UUOSYM,MACTEN
					;	sall
					;	.directive flblst

					lall
						subttl	Macro definitions

						;added date macro drforbin
						define dacon(cndat,day,month,year)<
						idivi	cndat,^D31
						addi	t2,1
						movem	t2,day
						idivi	cndat,^D12
						addi	t2,1
						movem	t2,month
						addi	cndat,^D1964
						subi	cndat,^D2000
						movem	cndat,year
						>




					;;;	ASCIL -- Define an ASCII string with <CR><LF><NUL> tacked on the end.
					;
						define ascil (txt), <
						  asciz `txt
					`
						>

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 1-1
WARMAC	MAC	 7-Jul-;2 18:15		Macro definitions

					;;;	WARN -- Dump TTY buffer and output warning message.  Go to addr (if
					;	given), else continue in sequence.
					;
						define warn (txt,addr<.+1>), <
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%'txt>]
							jrst addr
							]
						>

					;;;	ERR -- Dump TTY buffer, output error message, and exit.  Go to
					;	addr on CONTINUE (else if addr is blank, exit again).
					;
						define err (txt,addr<.-1>), <
						jrst	[skipn	hungup
							 output	tty,
							 skipn	hungup
							outstr [ascil <?'txt>]
							jrst monit
							]
						>

					;;;	SAVE -- Save data on argument stack (S).
					;
						define save (addr), <
						  xlist
						  irp addr, <push s,addr>
						  list
						>

					;;;	RESTOR -- Restore data from argument stack (S).
					;
						define restor (addr), <
						  xlist
						irp addr,<
							camn	s,[iowd stksiz,stk]
							jrst	[skipn	hungup
								 outstr	[asciz "
					???? data stack underflow!
					"]
								 halt	.+1
								]
							pop	s,addr>
						  list
						>

					;;;	COMMON -- Define a FORTRAN compatible common block.  Any following
					;	REAL, INTEGER, or LOGICAL, macros define symbols relative to name.
					;
						define common (name), <
						  .common name [1]
						  comblk=!name
						  size==0
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 1-2
WARMAC	MAC	 7-Jul-;2 18:15		Macro definitions

						>

					;;;	REAL -- Define a real scalar or array to be in the most recently
					;	defined common block.
					;
						define real (name,size), <array name, <size>>

					;;;	INTEGER -- Define an integer scalar or array to be in the most recently
					;	defined common block.
					;
						define integer (name,size), <array name, <size>>

					;;;	LOGICAL -- Define a logical scalar or array to be in the most recently
					;	defined common block.
					;
						define logical (name,size), <array name, <size>>

					;;;	ARRAY -- Define an n dimensional array (n >= 0) in the most recently
					;	defined common block.
					;
						define array (name,dim), <
						  name=size+comblk
						  x..==1
						  odim..==1
						  f..==0
						  irp dim,<
						    ifdif <dim><:>,<
						      ife f..,<
						        x..==x..*odim..
						        odim..==dim
						      >
						      ifn f..,<
						        x..==x..*<dim-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <dim><:>,<f..==-1>
						  >
						  x..==x..*odim..
						  size==size+x..
						>

					;;;	SHOW -- Show value of symbol equated inside a macro.
					;
						define show (sym), <
						  exp sym
						  .org .-1
						>

					;;;	FLGBIT -- Define a flag bit in terms of the previoulsy defined flag
					;	bit.  To initialize this macro, set bit..==1.
					;
						define flgbit (mnemonic), <
						  mnemonic==bit..
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 1-3
WARMAC	MAC	 7-Jul-;2 18:15		Macro definitions

						  bit..==bit.._1
						  show. mnemonic
						>

					;;;	GTTAB. -- GETTAB a value into ac.
					;
						define gttab. (ac,number), <
						  xlist
						  move ac,[number]
						  gettab ac,
						    halt
						  list
						>

					;;;	OSTR -- Output asciz string.
					;
						define ostr (addr), <
						  xlist
						  movei t1,addr
						  pushj p,ostr.
						  list
						>

					;;;	OCHR -- Output character.
					;
						define ochr (chr), <
						  xlist
						  movei c,chr
						  pushj p,ochr.
						  list
						>

					;;;	ARGBLK -- Define a fortran compatible argument block, and load a
					;	pointer to it into the argument block pointer, arg.
					;
						define argblk (args), <
						  t..==0
						  irp <args>, <t..==t..+1>
						  movei arg,[
							    -t..,,0
							    irp <args>, <exp args>
							    ]+1
						>

			000000			lofst.==0
						define local (var), <irp var, <loc1 var>>
						define loc1 (var1), <loc2 var1>
						define loc2 (name,size<1>), <
						  if1, <
						    name=lowend+lofst.
						    lofst.==lofst.+size
						  >
						  if2, <
						    name=lowend
						    lowend=lowend+size
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 1-4
WARMAC	MAC	 7-Jul-;2 18:15		Macro definitions

						  >
						>
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 2
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- parameters

						subttl	FORTRAN interface -- parameters

						radix	10

					;;;	General constants used by DECWAR

			000012			knplay==10		;maximum number of players (can't be increased)
			000024			knloks==^d20		; maximum number of active locks (LOCK./UNLOk.)
			000012			knstat==10		; number of statistic entries retained
			000012			knbase==10		;initial number of bases on each side
			000113			kgalv==75		;maximum Vertical coordinate in galaxy
			000031			ksid==25		;# of words to hold compressed row of galaxy
			000113			kgalh==75		;maximum Horizontal coordinate in galaxy
			003523			brdsiz==1875		;board size (kgalv * kgalh / 3)
			000074			knplnt==60		;maximum number of planets
					;	kmnpln==20		;minimum number of planets
					;	kmxpln==80		;maximum number of planets
			000011			kndev==9		;number of devices
		000005	154513			kpass=="S2K"		;password for system (*) commands
			000040			knmsg==32		;maximum number of messages in queue
			000021			msglen==17		;max # of words per msg (header + 80 chars)
			000007			kngrp==7		;number of defined message groups
			000050			knhshp==^d40		; number of hit queue entries per ship
			000620			knhit==knhshp*^d10	; max number of hit entries
			000041			kncmd==33		;number of available commands
			000014			knpcmd==12		;number of available commands in PREGAM
			000010			knpoin==8		;number of different scoring categories
			000010			knxtr==8		;# of things besides commands HELP knows
			000002			kscmd==2		;number of * (system) commands
			000017			kmaxtk==15		;max number of tokens to scan per input line
			000010			kntty==8		;number of TTY types supported
			000012			krange==10		;maximum range of scan, phasers, and torps
			005670			kcrit==3000		;amount of device damage deemed critical
			060650			kendam==25000		;amount of ship damage deemed fatal
			352300			kwait==120000		;milliseconds to wait before restart
			003720			kcmdtm==2000		;milliseconds to wait for command before loop
			000012			kqlen==10		;length of killed queue
		377777	777777			maxint==^o377777777777	;biggest integer
			000310			locsiz==200		;size of LOCAL common block

					;;;	Token types returned by GTKN

		777777	777777			keol==-1		;end of line
			000000			knul==0			;null
			000001			kint==1			;integer
			000002			kflt==2			;floating point
			000003			kalf==3			;alphanumeric

					;;;	SHPCON indeces

			000001			kvpos==1		;V coordinate of ships, etc.
			000002			khpos==2		;H coordinate of ship, etc.
			000003			knturn==3		;number of turns player has taken
			000004			kspcon==4		;condition of ship (1=green, 2 = yellow,
									;  3=red)
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 2-1
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- parameters

			000005			kntorp==5		;number of torps remaining
			000006			kshcon==6		;condition of shields (1=up, -1=down)
			000007			klfsup==7		;life support reserves in stardates
			000010			ksnrgy==8		;units of ship energy remaining
			000011			ksdam==9		;amount of ship damage
			000012			ksshpc==10		;shield %

					;;;	SCORE indeces

			000001			kpedam==1		;points for damage to enemy
			000002			kpekil==2		;points for enemies killed
			000003			kpbdam==3		;points for damage to bases
			000004			kppcap==4		;points for planets captured
			000005			kpbbas==5		;points for building bases
			000006			kprkil==6		;points for Romulans killed
			000007			knsdes==7		;numbers of stars destroyed
			000010			knpdes==8		;number of planets destroyed

					;;;	SHPDAM indeces

			000001			kdshld==1		;damage to shields
			000002			kdwarp==2		;damage to warp engines
			000003			kdimp==3		;damage to impulse engines
			000004			kdlife==4		;damage to life support
			000005			kdtorp==5		;damage to photon torpedo tubes
			000006			kdphas==6		;damage to phasers
			000007			kdcomp==7		;damage to computer
			000010			kdrad==8		;damage to radio

					;;;	JOB constants

			000011			knjbst==9		;total number of job status words
			000001			kjob==1			;job number
			000002			knam1==2		;first half of SIXBIT user name
			000003			knam2==3		;second half of SIXBIT user name
			000004			kppn==4			;PPN
			000005			kttyn==5		;TTY #
			000006			kttysp==6		;TTY speed
			000007			kttytp==7		;TTY type
			000010			kjobtm==8		;daytime at start up of present ship
			000011			kruntm==9		;run time at start up of present ship

					;;;	Bits used by LIST

			000001			nambit==^o000001	;ship name
			000002			prtbit==^o000002	;PORT
			000004			shpbit==^o000004	;SHIP
			000010			basbit==^o000010	;BASE
			000020			plnbit==^o000020	;PLANET
			000040			crdbit==^o000040	;coordinate

			000100			fedbit==^o000100	;FEDERATION, HUMAN
			000200			empbit==^o000200	;EMPIRE, KLINGON
			000400			rombit==^o000400	;ROMULAN
			001000			neubit==^o001000	;NEUTRAL
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 2-2
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- parameters

			002000			capbit==^o002000	;CAPTURED
			004000			allbit==^o004000	;ALL
			010000			rngbit==^o010000	;range
			020000			clsbit==^o020000	;CLOSEST

			040000			sumbit==^o040000	;SUMMARY
			100000			lstbit==^o100000	;LIST
			140000			outmsk==^o140000	;SUMMARY|LIST

			000001			irnbit==^o000001	;in range
			000002			isrbit==^o000002	;in specified range
			000004			igmbit==^o000004	;in game
			000010			ornbit==^o000010	;out of range
			000020			pasbit==^o000020	;selected only because password is set
			000040			knobit==^o000040	;only known about because it's been scanned

			003700			sidmsk==^o003700 ;fedbit|empbit|neubit|rombit|capbit
			000077			objmsk==^o000077 ;nambit|crdbit|basbit|shpbit|plnbit|prtbit

					;;;	Ship conditions

			000001			green==1
			000002			yellow==2
			000003			red==3

					;;;	OFLG values

		777777	777777			short==-1		;use short format output
			000000			medium==0		;use medium format output
			000001			long==1			;use long format output

					;;;	ICFLG/OCFLG values

		777777	777777			krel==-1		;default to relative coordinates
			000000			kboth==0		;output both relative and absolute coords
			000001			kabs==1			;default to absolute coordinates

					;;;	Codes for commands that are entry points in the LIST command

			000000			lstcmd==0		;LIST
			000001			sumcmd==1		;SUMMARY
			000002			bascmd==2		;BASES
			000003			plncmd==3		;PLANETS
			000004			tarcmd==4		;TARGETS

					;;;	DISP constants

			000000			dxmpty==0		;empty space
			000001			dxfshp==1		;federation ship
			000002			dxeshp==2		;empire ship
			000003			dxfbas==3		;feceration base
			000004			dxebas==4		;empire base
			000005			dxrom==5		;romulan ship
			000006			dxnpln==6		;neutral planet
			000007			dxfpln==7		;federation planet
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 2-3
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- parameters

			000010			dxepln==8		;empire planet
			000011			dxstar==9		;star
			000012			dxbhol==10		;black hole
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						subttl	FORTRAN interface -- high segment common block

						common	hiseg^
						  .common hiseg [1]
			000000*			  comblk=!hiseg
			000000			  size==0
						^

						;High core zeroed out by first player
						integer	hfz			^;first location to zero out
					array hfz, <>^
		000000000000#			  hfz=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000001			  size==size+x..
						^
		000000000000#		hi.fst==hfz
						integer	shpcon,<KNPLAY,10>	^;ship information
					array shpcon, <KNPLAY,10>^
		000000000000#			  shpcon=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

						    ifdif <10><:>,<
						      ife f..,<
			000012			        x..==x..*odim..
			000012			        odim..==10
						      >
						      ifn f..,<
						        x..==x..*<10-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <10><:>,<f..==-1>
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-1
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

	  

			000144			  x..==x..*odim..
			000145			  size==size+x..
						^
						integer	shpdam,<KNPLAY,KNDEV>	^;damage to ship devices
					array shpdam, <KNPLAY,KNDEV>^
		000000000000#			  shpdam=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

						    ifdif <KNDEV><:>,<
						      ife f..,<
			000012			        x..==x..*odim..
			000011			        odim..==KNDEV
						      >
						      ifn f..,<
						        x..==x..*<KNDEV-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNDEV><:>,<f..==-1>
	  

			000132			  x..==x..*odim..
			000277			  size==size+x..
						^
						integer	base,<KNBASE,4,2>	^;base information
					array base, <KNBASE,4,2>^
		000000000000#			  base=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNBASE><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-2
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

			000012			        odim..==KNBASE
						      >
						      ifn f..,<
						        x..==x..*<KNBASE-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNBASE><:>,<f..==-1>
	  

						    ifdif <4><:>,<
						      ife f..,<
			000012			        x..==x..*odim..
			000004			        odim..==4
						      >
						      ifn f..,<
						        x..==x..*<4-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <4><:>,<f..==-1>
	  

						    ifdif <2><:>,<
						      ife f..,<
			000050			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000120			  x..==x..*odim..
			000417			  size==size+x..
						^
						integer	nbase,<2>		^;number of federation and klingon bases
					array nbase, <2>^
		000000000000#			  nbase=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-3
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000002			  x..==x..*odim..
			000421			  size==size+x..
						^
						integer board,<brdsiz>		^;board
					array board, <brdsiz>^
		000000000000#			  board=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <brdsiz><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			003523			        odim..==brdsiz
						      >
						      ifn f..,<
						        x..==x..*<brdsiz-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <brdsiz><:>,<f..==-1>
	  

			003523			  x..==x..*odim..
			004144			  size==size+x..
						^
						integer	locpln,<KNPLNT,4>	^;planet info
					array locpln, <KNPLNT,4>^
		000000000000#			  locpln=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPLNT><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000074			        odim..==KNPLNT
						      >
						      ifn f..,<
						        x..==x..*<KNPLNT-odim..+1>
						        odim..==1
						        f..==0
						      >
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-4
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						    >
						    ifidn <KNPLNT><:>,<f..==-1>
	  

						    ifdif <4><:>,<
						      ife f..,<
			000074			        x..==x..*odim..
			000004			        odim..==4
						      >
						      ifn f..,<
						        x..==x..*<4-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <4><:>,<f..==-1>
	  

			000360			  x..==x..*odim..
			004524			  size==size+x..
						^
						integer	locr,<2>		^;romulan position
					array locr, <2>^
		000000000000#			  locr=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000002			  x..==x..*odim..
			004526			  size==size+x..
						^
						integer	erom			^;romulan energy
					array erom, <>^
		000000000000#			  erom=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-5
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

			004527			  size==size+x..
						^
						integer eromo			^;initial rom energy
					array eromo, <>^
		000000000000#			  eromo=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004530			  size==size+x..
						^
						integer	rsr,<8>			^;romulan scoring info
					array rsr, <8>^
		000000000000#			  rsr=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <8><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000010			        odim..==8
						      >
						      ifn f..,<
						        x..==x..*<8-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <8><:>,<f..==-1>
	  

			000010			  x..==x..*odim..
			004540			  size==size+x..
						^
						integer	nplnet			^;number of existing planets
					array nplnet, <>^
		000000000000#			  nplnet=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004541			  size==size+x..
						^
						logical	rom			^;true if Romulan exists
					array rom, <>^
		000000000000#			  rom=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-6
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						  irp 

			000001			  x..==x..*odim..
			004542			  size==size+x..
						^
						integer	romcnt			^;Romulan move counter
					array romcnt, <>^
		000000000000#			  romcnt=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004543			  size==size+x..
						^
						integer rtpaus			^;Romulan torpedo tube pause time
					array rtpaus, <>^
		000000000000#			  rtpaus=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004544			  size==size+x..
						^
						integer rppaus			^;Romulan phaser pause time
					array rppaus, <>^
		000000000000#			  rppaus=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004545			  size==size+x..
						^
						integer	job,<KNPLAY,KNJBST>	^;various job status information
					array job, <KNPLAY,KNJBST>^
		000000000000#			  job=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-7
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

						    ifdif <KNJBST><:>,<
						      ife f..,<
			000012			        x..==x..*odim..
			000011			        odim..==KNJBST
						      >
						      ifn f..,<
						        x..==x..*<KNJBST-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNJBST><:>,<f..==-1>
	  

			000132			  x..==x..*odim..
			004677			  size==size+x..
						^
						integer	msgflg,<KNPLAY>		^;flag for message routine
					array msgflg, <KNPLAY>^
		000000000000#			  msgflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

			000012			  x..==x..*odim..
			004711			  size==size+x..
						^
						integer	hitflg,<KNPLAY>		^;flag for MAKHIT, GETHIT
					array hitflg, <KNPLAY>^
		000000000000#			  hitflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-8
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

			000012			  x..==x..*odim..
			004723			  size==size+x..
						^
						integer	numcap,<2>		^;number of fed and emp planets
					array numcap, <2>^
		000000000000#			  numcap=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000002			  x..==x..*odim..
			004725			  size==size+x..
						^
						integer	romopt			^;romulan option flag
					array romopt, <>^
		000000000000#			  romopt=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004726			  size==size+x..
						^
						integer	blhopt			^;black hole option flag
					array blhopt, <>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-9
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

		000000000000#			  blhopt=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004727			  size==size+x..
						^
						integer	endflg			^;universe is destroyed flag
					array endflg, <>^
		000000000000#			  endflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004730			  size==size+x..
						^
						integer	nomsg			^;radio off flag
					array nomsg, <>^
		000000000000#			  nomsg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004731			  size==size+x..
						^
						integer	tmscor,<2,8>		^;team scoring information
					array tmscor, <2,8>^
		000000000000#			  tmscor=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

						    ifdif <8><:>,<
						      ife f..,<
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-10
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

			000002			        x..==x..*odim..
			000010			        odim..==8
						      >
						      ifn f..,<
						        x..==x..*<8-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <8><:>,<f..==-1>
	  

			000020			  x..==x..*odim..
			004751			  size==size+x..
						^
						integer	tim0			^;initial startup time
					array tim0, <>^
		000000000000#			  tim0=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004752			  size==size+x..
						^
						integer	slwest			^;class code of slowest terminal
					array slwest, <>^
		000000000000#			  slwest=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			004753			  size==size+x..
						^
						integer	kilque,<KQLEN,5>	^;list of players recently killed
					array kilque, <KQLEN,5>^
		000000000000#			  kilque=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KQLEN><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KQLEN
						      >
						      ifn f..,<
						        x..==x..*<KQLEN-odim..+1>
						        odim..==1
						        f..==0
						      >
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-11
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						    >
						    ifidn <KQLEN><:>,<f..==-1>
	  

						    ifdif <5><:>,<
						      ife f..,<
			000012			        x..==x..*odim..
			000005			        odim..==5
						      >
						      ifn f..,<
						        x..==x..*<5-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <5><:>,<f..==-1>
	  

			000062			  x..==x..*odim..
			005035			  size==size+x..
						^
						integer	nkill			^;current length of killed queue
					array nkill, <>^
		000000000000#			  nkill=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005036			  size==size+x..
						^
						integer	kilndx			^;current index into killed queue
					array kilndx, <>^
		000000000000#			  kilndx=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005037			  size==size+x..
						^
						integer tmturn,<3>		^;total # of turns used by each side
					array tmturn, <3>^
		000000000000#			  tmturn=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <3><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000003			        odim..==3
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-12
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						      >
						      ifn f..,<
						        x..==x..*<3-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <3><:>,<f..==-1>
	  

			000003			  x..==x..*odim..
			005042			  size==size+x..
						^
						integer numshp,<2>		^;total numbers of ships used
					array numshp, <2>^
		000000000000#			  numshp=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000002			  x..==x..*odim..
			005044			  size==size+x..
						^
						integer numrom			^;total number of romulans used
					array numrom, <>^
		000000000000#			  numrom=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005045			  size==size+x..
						^
						integer	trstat,<KNPLAY>		^;tractor beam status
					array trstat, <KNPLAY>^
		000000000000#			  trstat=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-13
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						  irp 

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

			000012			  x..==x..*odim..
			005057			  size==size+x..
						^
						integer	active,<KNPLAY>		^;dead ship flags
					array active, <KNPLAY>^
		000000000000#			  active=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

			000012			  x..==x..*odim..
			005071			  size==size+x..
						^
						logical	alive,<KNPLAY>		^;true if player is alive
					array alive, <KNPLAY>^
		000000000000#			  alive=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-14
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

			000012			  x..==x..*odim..
			005103			  size==size+x..
						^
						integer comknt			^;dead ship monitor count
					array comknt, <>^
		000000000000#			  comknt=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005104			  size==size+x..
						^
						integer hitime			^;time to reinitialize HISEG
					array hitime, <>^
		000000000000#			  hitime=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005105			  size==size+x..
						^
						logical	dead			^;true if KILHGH already called
					array dead, <>^
		000000000000#			  dead=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005106			  size==size+x..
						^
						integer	docked,<KNPLAY>		^;docked flags
					array docked, <KNPLAY>^
		000000000000#			  docked=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-15
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

			000012			  x..==x..*odim..
			005120			  size==size+x..
						^
						integer	hlz			^;last location to zero out
					array hlz, <>^
		000000000000#			  hlz=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005121			  size==size+x..
						^

						;high core not zeroed out by first player

						integer plnlok			^;lock variable for LOCPLN array
					array plnlok, <>^
		000000000000#			  plnlok=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005122			  size==size+x..
						^
						integer frelok			^;lock variable for FREE routine
					array frelok, <>^
		000000000000#			  frelok=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005123			  size==size+x..
						^
						integer quelok			^;lock variable for queue routines
					array quelok, <>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-16
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

		000000000000#			  quelok=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005124			  size==size+x..
						^

						integer	device,<KNDEV>		^;device names
					array device, <KNDEV>^
		000000000000#			  device=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNDEV><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000011			        odim..==KNDEV
						      >
						      ifn f..,<
						        x..==x..*<KNDEV-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNDEV><:>,<f..==-1>
	  

			000011			  x..==x..*odim..
			005135			  size==size+x..
						^
						integer	isaydo,<2,KNCMD>	^;mnemonics for commands
					array isaydo, <2,KNCMD>^
		000000000000#			  isaydo=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-17
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

	  

						    ifdif <KNCMD><:>,<
						      ife f..,<
			000002			        x..==x..*odim..
			000041			        odim..==KNCMD
						      >
						      ifn f..,<
						        x..==x..*<KNCMD-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNCMD><:>,<f..==-1>
	  

			000102			  x..==x..*odim..
			005237			  size==size+x..
						^
						integer	xhelp,<2,KNXTR>		^;extra things help is available for
					array xhelp, <2,KNXTR>^
		000000000000#			  xhelp=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

						    ifdif <KNXTR><:>,<
						      ife f..,<
			000002			        x..==x..*odim..
			000010			        odim..==KNXTR
						      >
						      ifn f..,<
						        x..==x..*<KNXTR-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNXTR><:>,<f..==-1>
	  

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-18
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

			000020			  x..==x..*odim..
			005257			  size==size+x..
						^
						integer	ttydat,<2,KNTTY>	^;mnemonics for supported TTYs
					array ttydat, <2,KNTTY>^
		000000000000#			  ttydat=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

						    ifdif <KNTTY><:>,<
						      ife f..,<
			000002			        x..==x..*odim..
			000010			        odim..==KNTTY
						      >
						      ifn f..,<
						        x..==x..*<KNTTY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNTTY><:>,<f..==-1>
	  

			000020			  x..==x..*odim..
			005277			  size==size+x..
						^
						integer	names,<KNPLAY,3>	^;names of players
					array names, <KNPLAY,3>^
		000000000000#			  names=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPLAY><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000012			        odim..==KNPLAY
						      >
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-19
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						      ifn f..,<
						        x..==x..*<KNPLAY-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPLAY><:>,<f..==-1>
	  

						    ifdif <3><:>,<
						      ife f..,<
			000012			        x..==x..*odim..
			000003			        odim..==3
						      >
						      ifn f..,<
						        x..==x..*<3-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <3><:>,<f..==-1>
	  

			000036			  x..==x..*odim..
			005335			  size==size+x..
						^
						integer	bits,<18>		^;player's identification bit
					array bits, <18>^
		000000000000#			  bits=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <18><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000022			        odim..==18
						      >
						      ifn f..,<
						        x..==x..*<18-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <18><:>,<f..==-1>
	  

			000022			  x..==x..*odim..
			005357			  size==size+x..
						^
										;(powers of 2 table)
						integer sbits,<0,:,2>		^;flag bits for different sides
					array sbits, <0,:,2>^
		000000000000#			  sbits=size+comblk
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-20
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <0><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000000			        odim..==0
						      >
						      ifn f..,<
						        x..==x..*<0-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <0><:>,<f..==-1>
	  

						    ifdif <:><:>,<
						      ife f..,<
						        x..==x..*odim..
						        odim..==:
						      >
						      ifn f..,<
						        x..==x..*<:-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
		777777	777777			    ifidn <:><:>,<f..==-1>
	  

						    ifdif <2><:>,<
						      ife f..,<
						        x..==x..*odim..
						        odim..==2
						      >
						      ifn f..,<
			000003			        x..==x..*<2-odim..+1>
			000001			        odim..==1
			000000			        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000003			  x..==x..*odim..
			005362			  size==size+x..
						^
						integer cmdbts,<KNCMD>		^;flags commands usable before game
					array cmdbts, <KNCMD>^
		000000000000#			  cmdbts=size+comblk
			000001			  x..==1
			000001			  odim..==1
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-21
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

			000000			  f..==0
						  irp 

						    ifdif <KNCMD><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000041			        odim..==KNCMD
						      >
						      ifn f..,<
						        x..==x..*<KNCMD-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNCMD><:>,<f..==-1>
	  

			000041			  x..==x..*odim..
			005423			  size==size+x..
						^
						integer	numply			^;number of active players
					array numply, <>^
		000000000000#			  numply=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005424			  size==size+x..
						^
						integer	numsid,<2>		^;current # of active ships per side
					array numsid, <2>^
		000000000000#			  numsid=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000002			  x..==x..*odim..
			005426			  size==size+x..
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-22
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						^
						integer	versio			^;version number
					array versio, <>^
		000000000000#			  versio=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005427			  size==size+x..
						^
						integer	gameno			^; game number
					array gameno, <>^
		000000000000#			  gameno=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005430			  size==size+x..
						^
						integer dotime			^; counter for driving base rebuild etc.
					array dotime, <>^
		000000000000#			  dotime=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005431			  size==size+x..
						^
						integer score,<KNPOIN,knplay>		^;ship score information
					array score, <KNPOIN,knplay>^
		000000000000#			  score=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <KNPOIN><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000010			        odim..==KNPOIN
						      >
						      ifn f..,<
						        x..==x..*<KNPOIN-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <KNPOIN><:>,<f..==-1>
	  
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-23
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block


						    ifdif <knplay><:>,<
						      ife f..,<
			000010			        x..==x..*odim..
			000012			        odim..==knplay
						      >
						      ifn f..,<
						        x..==x..*<knplay-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <knplay><:>,<f..==-1>
	  

			000120			  x..==x..*odim..
			005551			  size==size+x..
						^
						integer hi.lst			^; highest location for remap
					array hi.lst, <>^
		000000000000#			  hi.lst=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			005552			  size==size+x..
						^

						common	timers			^; block of data for timers

						  .common timers [1]
			000000*			  comblk=!timers
			000000			  size==0
	
						integer timnam,^d50		^; names
					array timnam, <^d50>^
		000000000000#			  timnam=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <^d50><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000062			        odim..==^d50
						      >
						      ifn f..,<
						        x..==x..*<^d50-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-24
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						    ifidn <^d50><:>,<f..==-1>
	  

			000062			  x..==x..*odim..
			000062			  size==size+x..
						^
						integer timcnt,^d50		^; # times used
					array timcnt, <^d50>^
		000000000000#			  timcnt=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <^d50><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000062			        odim..==^d50
						      >
						      ifn f..,<
						        x..==x..*<^d50-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <^d50><:>,<f..==-1>
	  

			000062			  x..==x..*odim..
			000144			  size==size+x..
						^
						integer timtot,^d50		^; total time
					array timtot, <^d50>^
		000000000000#			  timtot=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <^d50><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000062			        odim..==^d50
						      >
						      ifn f..,<
						        x..==x..*<^d50-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <^d50><:>,<f..==-1>
	  

			000062			  x..==x..*odim..
			000226			  size==size+x..
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 3-25
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- high segment common block

						^
						integer timhi,^d50		^; high time
					array timhi, <^d50>^
		000000000000#			  timhi=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <^d50><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000062			        odim..==^d50
						      >
						      ifn f..,<
						        x..==x..*<^d50-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <^d50><:>,<f..==-1>
	  

			000062			  x..==x..*odim..
			000310			  size==size+x..
						^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

						subttl	FORTRAN interface -- low segment common block

						common	lowseg^
						  .common lowseg [1]
			000000*			  comblk=!lowseg
			000000			  size==0
						^

						integer	lfz			^;first location of LOWSEG
					array lfz, <>^
		000000000000#			  lfz=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000001			  size==size+x..
						^
						integer	ntok			^;number of tokens on input line
					array ntok, <>^
		000000000000#			  ntok=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000002			  size==size+x..
						^
						integer	tknlst,<kmaxtk>		^;buffer for tokens from input line
					array tknlst, <kmaxtk>^
		000000000000#			  tknlst=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <kmaxtk><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000017			        odim..==kmaxtk
						      >
						      ifn f..,<
						        x..==x..*<kmaxtk-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <kmaxtk><:>,<f..==-1>
	  

			000017			  x..==x..*odim..
			000021			  size==size+x..
						^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-1
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

						integer	vallst,<kmaxtk>		^;numeric values of tokens, else 0
					array vallst, <kmaxtk>^
		000000000000#			  vallst=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <kmaxtk><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000017			        odim..==kmaxtk
						      >
						      ifn f..,<
						        x..==x..*<kmaxtk-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <kmaxtk><:>,<f..==-1>
	  

			000017			  x..==x..*odim..
			000040			  size==size+x..
						^
						integer	typlst,<kmaxtk>		^;types for corresponding tokens
					array typlst, <kmaxtk>^
		000000000000#			  typlst=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <kmaxtk><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000017			        odim..==kmaxtk
						      >
						      ifn f..,<
						        x..==x..*<kmaxtk-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <kmaxtk><:>,<f..==-1>
	  

			000017			  x..==x..*odim..
			000057			  size==size+x..
						^
						integer	ptrlst,<kmaxtk>		^;pointers to beginning of each token
					array ptrlst, <kmaxtk>^
		000000000000#			  ptrlst=size+comblk
			000001			  x..==1
			000001			  odim..==1
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-2
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

			000000			  f..==0
						  irp 

						    ifdif <kmaxtk><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000017			        odim..==kmaxtk
						      >
						      ifn f..,<
						        x..==x..*<kmaxtk-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <kmaxtk><:>,<f..==-1>
	  

			000017			  x..==x..*odim..
			000076			  size==size+x..
						^
						integer	who			^;which player you are
					array who, <>^
		000000000000#			  who=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000077			  size==size+x..
						^
						integer	iwhat			^;type of hit for MAKHIT, GETHIT
					array iwhat, <>^
		000000000000#			  iwhat=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000100			  size==size+x..
						^
						integer	ihita			^;size of hit for MAKHIT, GETHIT
					array ihita, <>^
		000000000000#			  ihita=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000101			  size==size+x..
						^
						integer	Vto			^;V disp. location for MAKHIT, GETHIT
					array Vto, <>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-3
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

		000000000000#			  Vto=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000102			  size==size+x..
						^
						integer	Hto			^;H disp. location for MAKHIT, GETHIT
					array Hto, <>^
		000000000000#			  Hto=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000103			  size==size+x..
						^
						integer Vfrom			^;V disp. location for MAKHIT, GETHIT
					array Vfrom, <>^
		000000000000#			  Vfrom=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000104			  size==size+x..
						^
						integer Hfrom			^;H disp. location for MAKHIT, GETHIT
					array Hfrom, <>^
		000000000000#			  Hfrom=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000105			  size==size+x..
						^
						integer	critdv			^;dev. # of crit. hit for MAKHIT, GETHIT
					array critdv, <>^
		000000000000#			  critdv=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000106			  size==size+x..
						^
						integer	critdm			^;size of crit. hit for MAKHIT, GETHIT
					array critdm, <>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-4
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

		000000000000#			  critdm=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000107			  size==size+x..
						^
						integer	klflg			^;killed flag for MAKHIT, GETHIT
					array klflg, <>^
		000000000000#			  klflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000110			  size==size+x..
						^
						integer	dispfr			^;DISP code of sender of information
					array dispfr, <>^
		000000000000#			  dispfr=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000111			  size==size+x..
						^
						integer	dispto			^;DISP code of receiver
					array dispto, <>^
		000000000000#			  dispto=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000112			  size==size+x..
						^
						integer	dbits			^;destination bits for MAKHIT, GETHIT
					array dbits, <>^
		000000000000#			  dbits=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000113			  size==size+x..
						^
						integer	shcnto			^;hittee's shield condition
					array shcnto, <>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-5
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

		000000000000#			  shcnto=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000114			  size==size+x..
						^
						integer shstto			^;hittee's shield strength
					array shstto, <>^
		000000000000#			  shstto=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000115			  size==size+x..
						^
						integer shcnfr			^;hitter's shield condition
					array shcnfr, <>^
		000000000000#			  shcnfr=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000116			  size==size+x..
						^
						integer shstfr			^;hitter's shield strength
					array shstfr, <>^
		000000000000#			  shstfr=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000117			  size==size+x..
						^
						integer shjump			^;object displacement flag
					array shjump, <>^
		000000000000#			  shjump=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000120			  size==size+x..
						^
						integer	group,<kngrp,2>		^;player groups for SEND command
					array group, <kngrp,2>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-6
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

		000000000000#			  group=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <kngrp><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000007			        odim..==kngrp
						      >
						      ifn f..,<
						        x..==x..*<kngrp-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <kngrp><:>,<f..==-1>
	  

						    ifdif <2><:>,<
						      ife f..,<
			000007			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000016			  x..==x..*odim..
			000136			  size==size+x..
						^
						integer	ngroup			^;number of defined groups
					array ngroup, <>^
		000000000000#			  ngroup=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000137			  size==size+x..
						^
						integer	pasflg			^;true if the guy knows the password
					array pasflg, <>^
		000000000000#			  pasflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-7
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block


			000001			  x..==x..*odim..
			000140			  size==size+x..
						^
						integer shtype			^;shiptype (1=norm,10=trainer)
					array shtype, <>^
		000000000000#			  shtype=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000141			  size==size+x..
						^
						integer	team			^;1 for federation, 2 for empire
					array team, <>^
		000000000000#			  team=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000142			  size==size+x..
						^
						logical	ccflg			^;-1 if ^C while turned off
					array ccflg, <>^
		000000000000#			  ccflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000143			  size==size+x..
						^
						internal ccflg
						logical	player			^;player / romulan movement flag
					array player, <>^
		000000000000#			  player=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000144			  size==size+x..
						^
						integer	tpoint,<knpoin>		^;points to be stored into SCORE
					array tpoint, <knpoin>^
		000000000000#			  tpoint=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-8
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

						  irp 

						    ifdif <knpoin><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000010			        odim..==knpoin
						      >
						      ifn f..,<
						        x..==x..*<knpoin-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <knpoin><:>,<f..==-1>
	  

			000010			  x..==x..*odim..
			000154			  size==size+x..
						^
						integer	phbank,<2>		^;time of last phaser fire
					array phbank, <2>^
		000000000000#			  phbank=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <2><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000002			        odim..==2
						      >
						      ifn f..,<
						        x..==x..*<2-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <2><:>,<f..==-1>
	  

			000002			  x..==x..*odim..
			000156			  size==size+x..
						^
						integer	tobank			^;time of last torpedo fire
					array tobank, <>^
		000000000000#			  tobank=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000157			  size==size+x..
						^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-9
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

						integer	ptime			^;pause after last command in GETCMD
					array ptime, <>^
		000000000000#			  ptime=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000160			  size==size+x..
						^
						integer prtype			^;prompt type (0 = normal)
					array prtype, <>^
		000000000000#			  prtype=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000161			  size==size+x..
						^
						logical	rptflg			^;TRUE if command was repeated with $
					array rptflg, <>^
		000000000000#			  rptflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000162			  size==size+x..
						^
						integer gagmsg			^;mask to gag msgs from individual ships
					array gagmsg, <>^
		000000000000#			  gagmsg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000163			  size==size+x..
						^
						integer oflg			^;output verbosity flag
					array oflg, <>^
		000000000000#			  oflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000164			  size==size+x..
						^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-10
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

						integer	scnflg			^;scan verbosity flag
					array scnflg, <>^
		000000000000#			  scnflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000165			  size==size+x..
						^
						integer	ttytyp			^;terminal type
					array ttytyp, <>^
		000000000000#			  ttytyp=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000166			  size==size+x..
						^
						integer	hcpos			^;horizontal cursor position
					array hcpos, <>^
		000000000000#			  hcpos=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000167			  size==size+x..
						^
						integer	icflg			^;default coord input type (abs,rel)
					array icflg, <>^
		000000000000#			  icflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000170			  size==size+x..
						^
						integer ocflg			^;default coord out type (abs,rel,both)
					array ocflg, <>^
		000000000000#			  ocflg=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000171			  size==size+x..
						^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-11
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

						integer	blank			^;number of consecutive blank lines
					array blank, <>^
		000000000000#			  blank=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000172			  size==size+x..
						^
						integer	llz			^;last location in LOWSEG
					array llz, <>^
		000000000000#			  llz=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000173			  size==size+x..
						^
						integer inwait			^; -1 if waiting for input
					array inwait, <>^
		000000000000#			  inwait=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000174			  size==size+x..
						^
						integer	hungup			^; -1 if user has hungup
					array hungup, <>^
		000000000000#			  hungup=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000175			  size==size+x..
						^
						integer addrck			^; -1 if address check has occured
					array addrck, <>^
		000000000000#			  addrck=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000176			  size==size+x..
						^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 4-12
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- low segment common block

						integer lkfail			^; -1 if a lock request failed
					array lkfail, <>^
		000000000000#			  lkfail=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000177			  size==size+x..
						^
						integer	terwid			^; holds user's terminal width (chars)
					array terwid, <>^
		000000000000#			  terwid=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

			000001			  x..==x..*odim..
			000200			  size==size+x..
						^

						internal inwait,hungup,addrck
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 5
WARMAC	MAC	 7-Jul-;2 18:15		FORTRAN interface -- general purpose common block (low seg)

						subttl	FORTRAN interface -- general purpose common block (low seg)

						common	local^
						  .common local [1]
			000000*			  comblk=!local
			000000			  size==0
						^

						integer	loc..,<locsiz>^array loc.., <locsiz>^
		000000000000#			  loc..=size+comblk
			000001			  x..==1
			000001			  odim..==1
			000000			  f..==0
						  irp 

						    ifdif <locsiz><:>,<
						      ife f..,<
			000001			        x..==x..*odim..
			000310			        odim..==locsiz
						      >
						      ifn f..,<
						        x..==x..*<locsiz-odim..+1>
						        odim..==1
						        f..==0
						      >
						    >
						    ifidn <locsiz><:>,<f..==-1>
	  

			000310			  x..==x..*odim..
			000310			  size==size+x..
						^^

						;SCAN variables
		000000000000#			Hmin==loc..+0
		000000000000#			Hmax==loc..+1
		000000000000#			Vmin==loc..+2
		000000000000#			Vmax==loc..+3
		000000000000#			dH==loc..+4
		000000000000#			dV==loc..+5
		000000000000#			screen==loc..+6

						;OSTS.Y variables  (Pre-game GRIPE line info)
		000000000000#			jobnum==loc..+0
		000000000000#			nam1==loc..+1
		000000000000#			nam2==loc..+2
		000000000000#			ppn==loc..+3
		000000000000#			ttynum==loc..+4
		000000000000#			ttyspd==loc..+5

						radix	8
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 6
WARMAC	MAC	 7-Jul-;2 18:15		Registers and other constants

						subttl	Registers and other constants

			000000			f=0			;flags
			000000			t0=0			;FORTRAN function value
			000001			t1=1			;temporary
			000002			t2=2
			000003			t3=3
			000004			t4=4

			000005			x1=5			;must be preserved by low level routines
			000006			x2=6
			000007			x3=7
			000010			x4=10

			000011			c=11			;character
			000012			p1=12			;byte pointer
			000013			p2=13

			000015			s=15			;arg save stack
			000016			arg=16
			000017			p=17


			000050			pdlsiz==50		;depth of push down list
			000050			stksiz==50		;depth of argument save stack
			000036			ntry=^D30		;# of times to try to access locked routine
			000144			slptim=^D100		;milliseconds to sleep between tries
			011610			cmdtim=^D5000		;milliseconds to sleep between commands
			000120			maxcnt==^D80		;maximum number of characters per line
			000024			grpsiz==^D20		;maximum number of lines in a gripe

			000015			cr=15			;carriage return
			000012			lf=12			;line feed
			000040			sp=40			;space

			000000			tty==0			;TTY output channel
			000001			nws==1			;NEWS input channel
			000002			hlp==2			;HELP input channel
			000003			grp==3			;GRIPE I/O channel
			000004			ini==4			;DECWAR.INI input channel
			000005			ren==5			;channel to rename high seg on
			000006			sta==6			; channel for DECWAR.STA

						;Token flag bits

			000001			tf.num==1		;token had some leading digits
			000002			tf.nnm==2		;token is non-numeric
			000004			tf.eol==4		;eol was seen after token
			000010			tf.chr==10		;token has characters (isn't null)
			000020			tf.sgn==20		;token has a sign (+/-)
			000040			tf.pnt==40		;token has a decimal point
			000100			tf.neg==100		;token started with a minus sign

						;File block offsets (see Low Level I/O for a detailed description)

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 6-1
WARMAC	MAC	 7-Jul-;2 18:15		Registers and other constants

			000000			.fbcio==0		;addr of char I/O routines
			000001			.fbbuf==1		;addr of buffers
			000002			.fbfnc==2		;channel,,function
			000003			.fbios==3		;data mode
			000004			.fbdev==4		;device
			000005			.fbbrh==5		;addr of buffer ring headers
			000006			.fbnbf==6		;number of buffers
			000007			.fbnam==7		;file name
			000010			.fbext==10		;extension
			000011			.fbprv==11		;protection code
			000012			.fbppn==12		;PPN
			000013			.fbsfd==13		;SFDs

		777777	777777			debug.==-1		;if nonzero, include error checking and
									;diagnostic prints
			000000			dbque.==0		; -1 to check the queues
			000000			dbzer.==0		; -1 to check for storing zero values in setdsp
		777777	777777			db777.==-1		; -1 to check for storing 7777 in setdsp
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 7
WARMAC	MAC	 7-Jul-;2 18:15		low segment data

						subttl	low segment data

	000000'					reloc	0

	000000'				hand:	block	2		;drforbin
	000002'				uscbh.:	block	2		;drforbin
	000004'				save$v:	block	1		; saves contents of $v in havenq
	000005'				hang$v:	block	1		; saves contents of $v in hang
	000006'				hangta:	block	1		; save for register ta
	000007'				hv.lok:	block	1		; set to -1 when enq. request is granted
	000010'				LVLTBL:	block	2
	000012'				pdl:	block	pdlsiz		;push down list
	000062'				stk:	block	stksiz		;argument save stack

						;Info needed to rename/delete program binary
	000132'				p.nam:	block	1		;filename
	000133'				p.ppn:	block	1		;PPN
	000134'				p.dev:	block	1		;device

	000135'				echflg:	block	1		;-1 if echoing is currently off, else 0
	000136'				iniflg:	block	1		;-1 if input from DECWAR.INI, else 0

	000137'				scale:	block	1		;scale factor used by ANUM.

	000140'				ccflg.::block	1		;used to unstack multiple cmds/line on ^C
	000141'				bufptr:	block	1		;pointer to input buffer, or -1
	000142'				chrcnt:	block	1		;count of number of characters on line
	000143'				linbuf:	block	maxcnt+1	;buffer to store input line

	000264'				obflb:	block	1		;address of current output file block
	000265'	000000	000002		obfctr:	0+.BFCTR		;address of current output character count
	000266'	000000	000001		obfptr:	0+.BFPTR		;address of current output character pointer
	000267'	067 00 0 00 000000 	obfins:	output	0,		;current buffer output instruction
	000270'	260 17 0 00 406077'	oc:	pushj	p,ochr.		;current character output routine

	000271'				ibflb:	block	1		;address of current input file block
	000272'	000000	000002		ibfctr:	0+.BFCTR		;address of current input character count
	000273'	000000	000001		ibfptr:	0+.BFPTR		;address of current input character pointer
	000274'	056 00 0 00 000000 	ibfins:	in	0,		;current buffer input instruction
	000275'	260 17 0 00 406150'	ic:	pushj	p,ichr.		;current character input routine

	000276'				tobcb:	block	3		;tty output buffer control block
	000301'				tobuf:	block	3		;tty output buffer header block
	000304'					block	50		;tty output buffer

	000354'				frebie:	block	1		; -1 if free user running
	000355'				ftlerr:	block	1		; holds address of where to go on APR trap
	000356'				locked:	block	1		; holds address of most recent LOCK,,UNLOCK
	000357'				svlock:	block	1		; saves lock over hiber etc.
	000360'				whohas:	block	3		; job number of user who has a queue
	000363'				loktab:	block	knloks		; table of active locks
	000407'				jsqwho:	block	1		; ship number (index into jsqtab)
	000410'				timsta:	block	^d50		; holds time into given routine
	000472'				timlcn:	block	^d50		; holds timer name locally
	000554'				stabuf::block	^d128*5		; buffer for DECWAR.STA
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 7-1
WARMAC	MAC	 7-Jul-;2 18:15		low segment data

			001753'		staend==.-1			; end of the status buffer
			000554'		staser==stabuf+0		; game serial #
			000555'		stafed==stabuf+1		; Federation high score
			000556'		stanfw==stabuf+2		; # times Federation "won"
			000755'		staemp==stabuf+^d129		; Empire high score
			000756'		stanew==staemp+1		; # times Empire "won"
			000557'		staflv==stabuf+3	; surviving captains (Federation)
			000723'		stafka==staflv+^d10*knstat	; killed in action (Fed)
			001157'		staelv==staflv+^d256		; surviving captains (Empire)
			001323'		staeka==staelv+^d10*knstat	; killed in action (Empire)
			001554'		stacap==stabuf+^d512		; count of commissions for each ship
			001566'		stakil==stacap+knplay		; counter for # times destroyed
	001754'	776600	000553'		staiow:	iowd	^d128*5,stabuf
	001755'	000000	000000			0
	001756'	776600	000553'		stfiow:	iowd	^d128*5,stabuf
	001757'	000000	000000			0
		000001	000027		sysppn==1,,27			; ppn for system files
	001760'				debflg:	block	1		; 0 = user PPN; -1 = 55,7; +1 = 77xxx,*

	001761'				dbuf:	block	3		;disk I/O buffer cntrl blk (news,gripe,help)
	001764'				dibuf:	block	3		;DECWAR.INI input buffer control block

	001767'				tmp:	block	6

						;^C and fatal error intercept block
	001775'	000004	411426'		intblk:	4,,inth.		;block length ,, addr of interrupt handler
	001776'	000000	000002			ER.ICC		;intercept ^C and fatal errors
	001777'				intadr:	block	1		;PC word at time of interrupt
	002000'				inttyp:	block	1		;error bit ,, channel number

	002001'				intsav:	block	1		;save AC to check out interrupt type
	002002'				intflg:	block	1		;-1 if ^C is being processed, else 0
	002003'				trpadr:	block	1		;address of ^C trap routine
	002004'				savr:	block	17		;for storage of ACs during trap routine

	002023'				seed:	block	1		;random number seed

						;OPEN./CLOSE. data block

	002024'				fl.ff:	block	1		;old .JBFF

	002025'				foblk:				;filop. block
	002025'				fo.fnc:	block	1		;protection bit,,function code
	002026'				fo.ios:	block	1		;open flags, data mooe
	002027'				fo.dev:	block	1		;device name
	002030'				fo.brh:	block	1		;addr of output,,input buffer control blocks
	002031'				fo.nbf:	block	1		;number of output,,input buffers
	002032'				fo.leb:	block	1		;addr of rename,,lookup/enter blocks

	002033'				leblk:				;lookup/enter block
	002033'				le.nam:	block	1		;file name
	002034'				le.ext:	block	1		;extension
	002035'				le.prv:	block	1		;protection code
	002036'				le.ppn:	block	1		;PPN or pointer to path. block

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 7-2
WARMAC	MAC	 7-Jul-;2 18:15		low segment data

	002037'				ptblk:				;path. block
	002037'				pt.fcn:	block	1		;function code
	002040'				pt.swt:	block	1		;flags and switches
	002041'				pt.ppn:	block	1		;PPN
	002042'				pt.sfd:	block	5		;SFDs
	002047'				pt.max:	block	1		;terminating word

					ifn debug., <
	002050'				oldobj:	block	1		;object at location on board before zero
					> ;end ifn debug.

						;RUN code in low seg, so can recover from RUN error
	002051'	047 01 0 00 000035 	rundec:	run	t1,
	002052'	254 00 0 00 405556'		jrst	monit

	002053'	000001	000005		queue:	xwd	1,5		; used by LOCK. and UNL.
	002054'	000000	000000		quereq:	xwd	0,0		; rh = request ID
	002055'	200000	777776			xwd	200000,-2	; ignore sequence errors
	002056'	500000	000000		queuen:	xwd	500000,0
	002057'	000000	000000			xwd	0
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 8
WARMAC	MAC	 7-Jul-;2 18:15		high segment data

						subttl	high segment data

	400000'					reloc	400000

	400000'				jsqtim:	block	1		; time for next scan for job activity
	400001'				jsqtab:	block	^d10		; table of jsq,,jbn for active jobs

	400013'				hitser:	block	1	; serial number for finding oldest hit queue entry
	400014'					block	1	; master pointer for hit queue
	400015'				hitql:	block	knhit		;hit queue link list
	400635'				hitq:	block	4*knhit		;hit queue

	403735'					block	1	; master pointer for message queue
	403736'				msgql:	block	knmsg		;message queue link list
	403776'				msgq:	block	msglen*knmsg	;message queue

						;File blocks

						;TTY I/O
	405036'	406100'	406162'		ttyfil:	ochr.b,,ichr.t		;buffered output, TTCALLs for input
	405037'	000000	000301'			0,,tobuf		;address of output buffer
	405040'	000000	000003			tty,,.FOWRT		;channel TTY,,open for input
	405041'	400000	000100			.IOASC+UU.PHS+IO.LEM	;physical device only, special editor mode
	405042'	64 64 71 00 00 00 		sixbit /TTY/
	405043'	000276'	000000			tobcb,,0		;output buffer control block
	405044'	000001	000000			1,,0			;1 output buffer
	405045'	000 00 0 00 000000 		z

						;DECWAR.INI
	405046'	000000	405644'		inibeg:	0,,iich.		;buffered input
	405047'	777777	000203			-1,,203			;generate 203 words of buffer space
	405050'	000004	000001			ini,,.FORED		;channel INI,,open for input
	405051'	400000	000000			.IOASC+UU.PHS
	405052'	44 63 53 00 00 00 		sixbit /DSK/
	405053'	000000	001764'			0,,dibuf
	405054'	000000	000002			0,,2
	405055'	44 45 43 67 41 62 		sixbit /DECWAR/
	405056'	42 45 47 00 00 00 		sixbit /BEG/
	405057'	000000	000000			0
	405060'	777777	777777			-1			;use logged in PPN
	405061'	000 00 0 00 000000 		z

	405062'	000000	405644'		iniint:	0,,iich.		;buffered input
	405063'	777777	000203			-1,,203			;generate 203 words of buffer space
	405064'	000004	000001			ini,,.FORED		;channel INI,,open for input
	405065'	400000	000000			.IOASC+UU.PHS
	405066'	44 63 53 00 00 00 		sixbit /DSK/
	405067'	000000	001764'			0,,dibuf
	405070'	000000	000002			0,,2
	405071'	44 45 43 67 41 62 		sixbit /DECWAR/
	405072'	51 56 64 00 00 00 		sixbit /INT/
	405073'	000000	000000			0
	405074'	777777	777777			-1			;use logged in PPN
	405075'	000 00 0 00 000000 		z

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 8-1
WARMAC	MAC	 7-Jul-;2 18:15		high segment data

	405076'	000000	405644'		iniexp:	0,,iich.		;buffered input
	405077'	777777	000203			-1,,203			;generate 203 words of buffer space
	405100'	000004	000001			ini,,.FORED		;channel INI,,open for input
	405101'	400000	000000			.IOASC+UU.PHS
	405102'	44 63 53 00 00 00 		sixbit /DSK/
	405103'	000000	001764'			0,,dibuf
	405104'	000000	000002			0,,2
	405105'	44 45 43 67 41 62 		sixbit /DECWAR/
	405106'	45 70 60 00 00 00 		sixbit /EXP/
	405107'	000000	000000			0
	405110'	777777	777777			-1			;use logged in PPN
	405111'	000 00 0 00 000000 		z
						;News file
	405112'	000000	406151'		nwsfil:	0,,ichr.b		;buffered input
	405113'	777777	000406			-1,,406			;generate 406 words of buffer space
	405114'	000001	000001			nws,,.FORED		;channel NWS,,open for input
	405115'	400000	000000			.IOASC+UU.PHS		;physical device only
	405116'	44 63 53 00 00 00 		sixbit	/DSK/
	405117'	000000	001761'			0,,dbuf			;input buffer control block
	405120'	000000	000002			0,,2			;2 input buffers
	405121'	44 45 43 67 41 62 		sixbit /DECWAR/
	405122'	56 67 63 00 00 00 		sixbit /NWS/
	405123'	000000	000000			0
	405124'	000 00 0 00 000000 		z

						;Special help file
	405125'	000000	406151'		hl1fil:	0,,ichr.b		;buffered input
	405126'	777777	000406			-1,,406			;generate 406 words of buffer space
	405127'	000002	000001			hlp,,.FORED		;channel HLP,,open for input
	405130'	000000	000000			.IOASC
	405131'	44 63 53 00 00 00 		sixbit /DSK/
	405132'	000000	001761'			0,,dbuf			;input buffer control block
	405133'	000000	000002			0,,2			;2 input buffers
	405134'	44 45 43 67 41 62 		sixbit /DECWAR/
	405135'	50 54 60 00 00 00 		sixbit /HLP/
	405136'	000000	000000			0
	405137'	000000	000000			0
	405140'	44 45 43 67 41 62 		sixbit /DECWAR/
	405141'	50 54 60 00 00 00 		sixbit /HLP/
	405142'	000 00 0 00 000000 		z

						;Standard help file
	405143'	000000	406151'		hl2fil:	0,,ichr.b
	405144'	777777	000406			-1,,406
	405145'	000002	000001			hlp,,.FORED
	405146'	400000	000000			.IOASC+UU.PHS
	405147'	44 63 53 00 00 00 		sixbit /DSK/
	405150'	000000	001761'			0,,dbuf
	405151'	000000	000002			0,,2
	405152'	44 45 43 67 41 62 		sixbit /DECWAR/
	405153'	50 54 60 00 00 00 		sixbit /HLP/
	405154'	000 00 0 00 000000 		z
	405155'	000 00 0 00 000000 		z

						;Gripe file
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 8-2
WARMAC	MAC	 7-Jul-;2 18:15		high segment data

	405156'	412637'	000000		grpfil:	ogch.,,0
	405157'	000000	000000			0,,0
	405160'	000003	000004			grp,,.FOSAU
	405161'	400000	000017			.IODMP+UU.PHS
	405162'	44 63 53 00 00 00 		sixbit /DSK/
	405163'	001761'	000000			dbuf,,0
	405164'	000000	000000			0
	405165'	44 45 43 67 41 62 		sixbit /DECWAR/
	405166'	47 62 60 00 00 00 		sixbit /GRP/
	405167'	010 000 000 000 		byte	(9) 010,0,0,0
	405170'	000001	000027			exp	sysppn

						; DECWAR.STA
	405171'	000000	000000		stared:	xwd	0,0
	405172'	000000	000000			xwd	0,0
	405173'	000006	000001			xwd	sta,.fored
	405174'	400000	000017			exp	.iodmp+uu.phs
	405175'	44 63 53 00 00 00 		sixbit	/DSK/
	405176'	000554'	000000			xwd	stabuf,0
	405177'	000000	000000			0
	405200'	44 45 43 67 41 62 		sixbit	/DECWAR/
	405201'	63 64 41 00 00 00 		sixbit	/STA/
	405202'	000000	000000			0
	405203'	000001	000027			exp	sysppn

	405204'	000000	000000		staupd:	xwd	0,0
	405205'	000000	000000			xwd	0,0
	405206'	000006	000003			xwd	sta,.fowrt
	405207'	400000	000017			exp	.iodmp+uu.phs
	405210'	44 63 53 00 00 00 		sixbit	/DSK/
	405211'	000554'	000000			xwd	stabuf,0
	405212'	000000	000000			0
	405213'	44 45 43 67 41 62 		sixbit	/DECWAR/
	405214'	63 64 41 00 00 00 		sixbit	/STA/
	405215'	010 000 000 000 		byte	(9) 010,0,0,0
	405216'	000001	000027			exp	sysppn

						; DECWAF.STA		(status for "free" users)
	405217'	000000	000000		stfred:	xwd	0,0
	405220'	000000	000000			xwd	0,0
	405221'	000006	000001			xwd	sta,.fored
	405222'	400000	000017			exp	.iodmp+uu.phs
	405223'	44 63 53 00 00 00 		sixbit	/DSK/
	405224'	000554'	000000			xwd	stabuf,0
	405225'	000000	000000			0
	405226'	44 45 43 67 41 46 		sixbit	/DECWAF/
	405227'	63 64 41 00 00 00 		sixbit	/STA/
	405230'	000000	000000			0
	405231'	000001	000027			exp	sysppn

	405232'	000000	000000		stfupd:	xwd	0,0
	405233'	000000	000000			xwd	0,0
	405234'	000006	000003			xwd	sta,.fowrt
	405235'	400000	000017			exp	.iodmp+uu.phs
	405236'	44 63 53 00 00 00 		sixbit	/DSK/
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 8-3
WARMAC	MAC	 7-Jul-;2 18:15		high segment data

	405237'	000554'	000000			xwd	stabuf,0
	405240'	000000	000000			0
	405241'	44 45 43 67 41 46 		sixbit	/DECWAF/
	405242'	63 64 41 00 00 00 		sixbit	/STA/
	405243'	010 000 000 000 		byte	(9) 010,0,0,0
	405244'	000001	000027			exp	sysppn

	405245'	400000	000100		eonblk:	.IOASC+UU.PHS+IO.LEM	;TTY:, echo on
	405246'	64 64 71 00 00 00 		sixbit	/TTY/
	405247'	000 00 0 00 000000 		z

	405250'	400000	000300		eofblk:	.IOASC+UU.PHS+IO.LEM+IO.SUP ;TTY:, echo off
	405251'	64 64 71 00 00 00 		sixbit	/TTY/
	405252'	000 00 0 00 000000 		z

	405253'	350 00 0 17 000000 	cpopj1:	aos	(p)		;skip return
	405254'	263 17 0 00 000000 	cpopj:	popj	p,		;non-skip return

	405255'	44 07 0 00 000000#		point	7,screen,-1
	405256'	35 07 0 00 000000#	b7tbl:	point	7,screen,6
	405257'	26 07 0 00 000000#		point	7,screen,13
	405260'	17 07 0 00 000000#		point	7,screen,20
	405261'	10 07 0 00 000000#		point	7,screen,27
	405262'	01 07 0 00 000000#		point	7,screen,34

	405263'	44 14 0 00 000000#		point	12,board,-1
	405264'	30 14 0 00 000000#	b12tbl:	point	12,board,11
	405265'	14 14 0 00 000000#		point	12,board,23
	405266'	00 14 0 00 000000#		point	12,board,35
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 9
WARMAC	MAC	 7-Jul-;2 18:15		Character type bits

						subttl	Character type bits

			000001			bit..==1

						flgbit	cf.bsc		^;delete previous character

			000001			  cf.bsc==bit..
			000002			  bit..==bit.._1
						  show. cf.bsc^	.XCREF
	405267'	000000	000001			EXP	<cf.bsc>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.bsl		^;delete entire line

			000002			  cf.bsl==bit..
			000004			  bit..==bit.._1
						  show. cf.bsl^	.XCREF
	405267'	000000	000002			EXP	<cf.bsl>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.ign		^;ignore this character

			000004			  cf.ign==bit..
			000010			  bit..==bit.._1
						  show. cf.ign^	.XCREF
	405267'	000000	000004			EXP	<cf.ign>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.cr		^;this character outputs a carriage return

			000010			  cf.cr==bit..
			000020			  bit..==bit.._1
						  show. cf.cr^	.XCREF
	405267'	000000	000010			EXP	<cf.cr>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.ff		^;this character outputs one or more line feeds

			000020			  cf.ff==bit..
			000040			  bit..==bit.._1
						  show. cf.ff^	.XCREF
	405267'	000000	000020			EXP	<cf.ff>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.eof		^;end of file character (^Z or EOF)

			000040			  cf.eof==bit..
			000100			  bit..==bit.._1
						  show. cf.eof^	.XCREF
	405267'	000000	000040			EXP	<cf.eof>
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 9-1
WARMAC	MAC	 7-Jul-;2 18:15		Character type bits

	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.rpt		^;repeat previous command

			000100			  cf.rpt==bit..
			000200			  bit..==bit.._1
						  show. cf.rpt^	.XCREF
	405267'	000000	000100			EXP	<cf.rpt>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.eol		^;end of line character

			000200			  cf.eol==bit..
			000400			  bit..==bit.._1
						  show. cf.eol^	.XCREF
	405267'	000000	000200			EXP	<cf.eol>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.eoc		^;end of command character

			000400			  cf.eoc==bit..
			001000			  bit..==bit.._1
						  show. cf.eoc^	.XCREF
	405267'	000000	000400			EXP	<cf.eoc>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.dsp		^;display the line

			001000			  cf.dsp==bit..
			002000			  bit..==bit.._1
						  show. cf.dsp^	.XCREF
	405267'	000000	001000			EXP	<cf.dsp>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.etg		^;toggle echo

			002000			  cf.etg==bit..
			004000			  bit..==bit.._1
						  show. cf.etg^	.XCREF
	405267'	000000	002000			EXP	<cf.etg>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.spc		^;spacing character

			004000			  cf.spc==bit..
			010000			  bit..==bit.._1
						  show. cf.spc^	.XCREF
	405267'	000000	004000			EXP	<cf.spc>
	405267'					.ORG	.-1
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 9-2
WARMAC	MAC	 7-Jul-;2 18:15		Character type bits

								.CREF^
	
						flgbit	cf.dlm		^;delimiter

			010000			  cf.dlm==bit..
			020000			  bit..==bit.._1
						  show. cf.dlm^	.XCREF
	405267'	000000	010000			EXP	<cf.dlm>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.com		^;comment character (;)

			020000			  cf.com==bit..
			040000			  bit..==bit.._1
						  show. cf.com^	.XCREF
	405267'	000000	020000			EXP	<cf.com>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.sgn		^;sign (+ or -)

			040000			  cf.sgn==bit..
			100000			  bit..==bit.._1
						  show. cf.sgn^	.XCREF
	405267'	000000	040000			EXP	<cf.sgn>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.dig		^;digit (0 - 9)

			100000			  cf.dig==bit..
			200000			  bit..==bit.._1
						  show. cf.dig^	.XCREF
	405267'	000000	100000			EXP	<cf.dig>
	405267'					.ORG	.-1
								.CREF^
	
						flgbit	cf.pnt		^;decimal point (.)

			200000			  cf.pnt==bit..
			400000			  bit..==bit.._1
						  show. cf.pnt^	.XCREF
	405267'	000000	200000			EXP	<cf.pnt>
	405267'					.ORG	.-1
								.CREF^
	

			000003			cf.del==cf.bsc!cf.bsl
			003203			cf.spe==cf.del!cf.etg!cf.eol!cf.dsp
			340000			cf.num==cf.sgn!cf.dig!cf.pnt

	000000				cbits:	phase 0
	000000	000000	000600			cf.eol!cf.eoc			;^@
	000001	000 00 0 00 000000 		z				;^A
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 9-3
WARMAC	MAC	 7-Jul-;2 18:15		Character type bits

	000002	000 00 0 00 000000 		z				;^B
	000003	000000	000630			cf.eol!cf.eoc!cf.cr!cf.ff	;^C
	000004	000 00 0 00 000000 		z				;^D
	000005	000 00 0 00 000000 		z				;^E
	000006	000 00 0 00 000000 		z				;^F
	000007	000000	002000			cf.etg				;^G <BEL>
	000010	000000	000001			cf.bsc				;^H <BS>
	000011	000000	014000			cf.spc!cf.dlm			;^I <TAB> <HT>
	000012	000000	000620			cf.eol!cf.eoc!cf.ff		;^J <LF>
	000013	000000	000620			cf.eol!cf.eoc!cf.ff		;^K <VT>
	000014	000000	000620			cf.eol!cf.eoc!cf.ff		;^L <FF>
	000015	000000	000014			cf.cr!cf.ign			;^M <CR>
	000016	000 00 0 00 000000 		z				;^N
	000017	000000	000030			cf.cr!cf.ff			;^O never passed to the program
	000020	000 00 0 00 000000 		z				;^P
	000021	000 00 0 00 000000 		z				;^Q if TTY NO PAGE is set
	000022	000000	001000			cf.dsp				;^R if TTY RTCOMP is set or char mode
	000023	000 00 0 00 000000 		z				;^S if TTY NO PAGE is set
	000024	000 00 0 00 000000 		z				;^T if TTY RTCOMP is set
	000025	000000	000002			cf.bsl				;^U
	000026	000 00 0 00 000000 		z				;^V
	000027	000 00 0 00 000000 		z				;^W
	000030	000 00 0 00 000000 		z				;^X
	000031	000 00 0 00 000000 		z				;^Y
	000032	000000	000670			cf.eol!cf.eoc!cf.cr!cf.ff!cf.eof;^Z
	000033	000000	000700			cf.rpt!cf.eol!cf.eoc		;^[ <ALT> altmode
	000034	000 00 0 00 000000 		z				;^\
	000035	000 00 0 00 000000 		z				;^]
	000036	000 00 0 00 000000 		z				;^^
	000037	000 00 0 00 000000 		z				;^_
	000040	000000	014000			cf.spc!cf.dlm			;<SP> blank
	000041	000 00 0 00 000000 		z				;!
	000042	000 00 0 00 000000 		z				;"
	000043	000 00 0 00 000000 		z				;#
	000044	000 00 0 00 000000 		z				;$
	000045	000 00 0 00 000000 		z				;%
	000046	000 00 0 00 000000 		z				;&
	000047	000 00 0 00 000000 		z				;'
	000050	000 00 0 00 000000 		z				;(
	000051	000 00 0 00 000000 		z				;)
	000052	000 00 0 00 000000 		z				;*
	000053	000000	040000			cf.sgn				;+
	000054	000000	010000			cf.dlm				;,
	000055	000000	040000			cf.sgn				;-
	000056	000000	200000			cf.pnt				;.
	000057	000000	000400			cf.eoc				;/
	000060	000000	100000			cf.dig				;0
	000061	000000	100000			cf.dig				;1
	000062	000000	100000			cf.dig				;2
	000063	000000	100000			cf.dig				;3
	000064	000000	100000			cf.dig				;4
	000065	000000	100000			cf.dig				;5
	000066	000000	100000			cf.dig				;6
	000067	000000	100000			cf.dig				;7
	000070	000000	100000			cf.dig				;8
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 9-4
WARMAC	MAC	 7-Jul-;2 18:15		Character type bits

	000071	000000	100000			cf.dig				;9
	000072	000 00 0 00 000000 		z				;:
	000073	000000	020400			cf.com!cf.eoc			;;
	000074	000 00 0 00 000000 		z				;<
	000075	000 00 0 00 000000 		z				;=
	000076	000 00 0 00 000000 		z				;>
	000077	000 00 0 00 000000 		z				;?
	000100	000 00 0 00 000000 		z				;@
	000101	000 00 0 00 000000 		z				;A
	000102	000 00 0 00 000000 		z				;B
	000103	000 00 0 00 000000 		z				;C
	000104	000 00 0 00 000000 		z				;D
	000105	000 00 0 00 000000 		z				;E
	000106	000 00 0 00 000000 		z				;F
	000107	000 00 0 00 000000 		z				;G
	000110	000 00 0 00 000000 		z				;H
	000111	000 00 0 00 000000 		z				;I
	000112	000 00 0 00 000000 		z				;J
	000113	000 00 0 00 000000 		z				;K
	000114	000 00 0 00 000000 		z				;L
	000115	000 00 0 00 000000 		z				;M
	000116	000 00 0 00 000000 		z				;N
	000117	000 00 0 00 000000 		z				;O
	000120	000 00 0 00 000000 		z				;P
	000121	000 00 0 00 000000 		z				;Q
	000122	000 00 0 00 000000 		z				;R
	000123	000 00 0 00 000000 		z				;S
	000124	000 00 0 00 000000 		z				;T
	000125	000 00 0 00 000000 		z				;U
	000126	000 00 0 00 000000 		z				;V
	000127	000 00 0 00 000000 		z				;W
	000130	000 00 0 00 000000 		z				;X
	000131	000 00 0 00 000000 		z				;Y
	000132	000 00 0 00 000000 		z				;Z
	000133	000 00 0 00 000000 		z				;[
	000134	000 00 0 00 000000 		z				;/
	000135	000 00 0 00 000000 		z				;]
	000136	000 00 0 00 000000 		z				;^
	000137	000 00 0 00 000000 		z				;_
	000140	000 00 0 00 000000 		z				;`
	000141	000 00 0 00 000000 		z				;a
	000142	000 00 0 00 000000 		z				;b
	000143	000 00 0 00 000000 		z				;c
	000144	000 00 0 00 000000 		z				;d
	000145	000 00 0 00 000000 		z				;e
	000146	000 00 0 00 000000 		z				;f
	000147	000 00 0 00 000000 		z				;g
	000150	000 00 0 00 000000 		z				;h
	000151	000 00 0 00 000000 		z				;i
	000152	000 00 0 00 000000 		z				;j
	000153	000 00 0 00 000000 		z				;k
	000154	000 00 0 00 000000 		z				;l
	000155	000 00 0 00 000000 		z				;m
	000156	000 00 0 00 000000 		z				;n
	000157	000 00 0 00 000000 		z				;o
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 9-5
WARMAC	MAC	 7-Jul-;2 18:15		Character type bits

	000160	000 00 0 00 000000 		z				;p
	000161	000 00 0 00 000000 		z				;q
	000162	000 00 0 00 000000 		z				;r
	000163	000 00 0 00 000000 		z				;s
	000164	000 00 0 00 000000 		z				;t
	000165	000 00 0 00 000000 		z				;u
	000166	000 00 0 00 000000 		z				;v
	000167	000 00 0 00 000000 		z				;w
	000170	000 00 0 00 000000 		z				;x
	000171	000 00 0 00 000000 		z				;y
	000172	000 00 0 00 000000 		z				;z
	000173	000 00 0 00 000000 		z				;{
	000174	000 00 0 00 000000 		z				;\
	000175	000 00 0 00 000000 		z				;}
	000176	000 00 0 00 000000 		z				;~
	000177	000000	000001			cf.bsc				;<DEL>
	405467'					dephase
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 10
WARMAC	MAC	 7-Jul-;2 18:15		RESET./STOP./EXIT./EXIT/MONIT

						subttl	RESET./STOP./EXIT./EXIT/MONIT


					;all changes below made by drforbin(merlyn)
					;changes include ridding CIS variables and defining terminal wdth to 80 characters

					;to fix -drforbin---p.nam,p.ppn,p.dev
					;;;	RESET. -- This routine is called automatically by the FORTRAN
					;	generated code.  It initializes all the I/O, etc.  Most of the
					;	actual initialization is done in SETUP, which is low segment
					;	code that is removed once the player is solidly in the game.
					;
						extern	setup,z		;what a kludge, but for a Monitor bug
									;what can you do?
						entry	reset.
	405467'	62 45 63 45 64 16 		sixbit	/RESET./
	405470'	047 00 0 00 000000 	reset.:	reset
	405471'	202 00 0 00 000132'		movem	.sgnam^0^,p.nam	;save program name
	405472'	202 07 0 00 000133'		movem	.sgppn^7^,p.ppn	;save source PPN
	405473'	202 11 0 00 000134'		movem	.sgdev^11^,p.dev	;save device

	405474'	200 01 0 00 000000*		move	t1,.JBFF	;get last used location in low seg
	405475'	301 01 0 00 000000*		cail	t1,z		;setup code loaded?
	405476'	336 00 0 00 000000*		skipn	setup		;for sure?
	405477'	254 00 0 00 411536'		jrst	start		;low seg not all there; try a RUN

	405500'	200 17 0 00 414770'		move	p,[iowd pdlsiz,pdl] ;init subroutine stack
	405501'	200 15 0 00 414771'		move	s,[iowd stksiz,stk] ;init data stack
	405502'	271 16 0 00 000001 		addi	16,1		;return addr -1 is passed in AC16
	405503'	261 17 0 00 000016 		push	p,16
					;	pushj	p,rdusr.##		; if tmpcor:usr not found
					;	skipe	0
					;	pushj	p,makusr##		; then set it up now
					;	ldb	t1,[point 9,1+uster.##,8]	; set up terminal width
					;	skipn	t1
	405504'	201 01 0 00 000120 		movei	t1,^d80			; default
	405505'	202 01 0 00 000000#		movem	t1,terwid

	405506'	561 00 0 00 000030 		hrroi	t0,30			; if not 'WIZARD' running
	405507'	047 00 0 00 000041 		gettab	t0,
	405510'	400 00 0 00 000000 		  setz	t0,

	405511'				iswiz:
	405511'	400 01 0 00 000000 		setz	t1,
	405512'	047 01 0 00 000036 		setuwp	t1,
	405513'	254 04 0 00 000000 		  halt

	405514'	402 00 0 00 000000#		setzm	ccflg		;^C not typed yet
	405515'	402 00 0 00 000140'		setzm	ccflg.		;used to unstack multiple commands per line
	405516'	402 00 0 00 002003'		setzm	trpadr		;no ^C trap routine selected
	405517'	476 00 0 00 002002'		setom	intflg		;not processing ^C interrupt
	405520'	402 00 0 00 000000#		setzm	inwait
	405521'	402 00 0 00 000000#		setzm	hungup
	405522'	402 00 0 00 000000#		setzm	addrck
					;	pushj	p,cishng	; enable hangup detect and enq. interrupt
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 10-1
WARMAC	MAC	 7-Jul-;2 18:15		RESET./STOP./EXIT./EXIT/MONIT

	405523'	201 01 0 00 001775'		movei	t1,intblk	;enable interception of ^C and fatal errors
	405524'	402 00 0 00 001777'		setzm	intblk+2
	405525'	202 01 0 00 000000*		movem	t1,.JBINT
	405526'	201 01 0 00 414413'		movei	t1,aprtrp	; set up to capture APR failures
	405527'	542 01 0 00 000000*		hrrm	t1,.jbapr##
	405530'	201 01 0 00 220000 		movei	t1,1b19+1b22
	405531'	047 01 0 00 000016 		aprenb	t1,
	405532'	476 00 0 00 000141'		setom	bufptr		;time to read another line of input
	405533'	402 00 0 00 000135'		setzm	echflg		;echoing is turned on

	405534'	200 05 0 00 414772'		move	x1,[ttyfil,,ttyfil]
	405535'	260 17 0 00 405725'		pushj	p,open.		;open TTY
	405536'	254 04 0 00 000000 		  halt
	405537'	260 17 0 00 406041'		pushj	p,seto.		;set up for output to TTY
	405540'	260 17 0 00 406060'		pushj	p,seti.		;set up for input from TTY
	405541'	402 00 0 00 000136'		setzm	iniflg		;not getting input from DECWAR.INI
	405542'	201 12 0 00 414773'		movei	p1,[asciz "DECWAR, Edit "]
	405543'	260 17 0 00 406710'		pushj	p,ostr.
	405544'	550 05 0 00 000000*		hrrz	x1,.jbver##
	405545'	201 06 0 00 000005 		movei	x2,5
	405546'	260 17 0 00 407035'		pushj	p,odec.
	405547'	260 17 0 00 406616'		pushj	p,crlf
	405550'	336 00 0 00 000000#		skipn	hungup
	405551'	067 00 0 00 000000 		output	tty,

	405552'	263 17 0 00 000000 		popj	p,


						entry	stop., exit., exit
	405553'	45 70 51 64 00 00 		sixbit	/EXIT/
	405554'				stop.:
	405554'				exit.:
	405554'				exit:
	405554'	254 00 0 00 405556'		jrst	monit
						entry	monit
	405555'	55 57 56 51 64 00 		sixbit	/MONIT/
	405556'	336 00 0 00 000000#	monit:	skipn	hungup
	405557'	067 00 0 00 000000 		output	tty,
	405560'	513 00 0 00 000000*		hllzs	.jbsa##		; no restarts allowed
	405561'	260 17 0 00 412135'		pushj	p,zaplok	; zap all pending locks
	405562'	047 00 0 00 000000 		reset			; kill any pending locks
	405563'	332 01 0 00 000000#		skipe	t1,who		; if ship apparently active
						jrst	[movei	arg,[who]
							 pushj	p,free##	; then free it
							 jrst	.+1
							skipe	t1,jsqwho ;drforbin		; if job has entry in jsqtab
							setzm	jsqtab-1(t1) ;drforbin		; then clear it
	405564'	254 00 0 00 414777'			]

					;2 lines below commented drforbin.
					;	skipe	t1,jsqwho		; if job has entry in jsqtab
					;	setzm	jsqtab-1(t1)		; then clear it
	405565'	047 01 0 00 000012 		monrt.	;drforbin (add)

					;
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 10-2
WARMAC	MAC	 7-Jul-;2 18:15		RESET./STOP./EXIT./EXIT/MONIT

					;	jrst	rdwhst		; run "DWHOST"

						subttl	PTY

					;;;	PTY -- Check to see if job is logged on to a PTY.  This is done
					;	because a ^C received by such a job will unconditionally stop it,
					;	without even checking for an intercept routine.  So, since DECWAR
					;	has to do some cleaning up before letting a player out, we have to
					;	say that you can't play from a PTY.
					;
					;	PTY(dummy) = TRUE if running from a PTY.
					;
						entry	pty
	405566'	60 64 71 00 00 00 		sixbit	/PTY/
	405567'	474 01 0 00 000000 	pty:	seto	t1,
	405570'	051 06 0 00 000001 		getlch	t1		;get line characteristics
						txnn	t1,GL.ITY	^;PTY?

						.XCREF
					IFB  <GL.ITY>,	OP%%TX	<^O37777777&t1>,1B<t1_-^D30>,TLNN,TRNN,TDNN
					IFNB <GL.ITY>,	OP%%TX	t1,<GL.ITY>,TLNN,TRNN,TDNN^
						.XCREF
					IFN <<t1>&^O777777777760>, PRINTX ? t1 IS NOT AN ACCUMULATOR

			000000			TEMP%%=0
					IFE	<<GL.ITY>_^D18>,<
					IFN	<GL.ITY>,<
			000001			TEMP%%=1
						.CREF
	405571'	607 01 0 00 400000 		TLNN	t1,(GL.ITY)
						.XCREF
					>>
					IFE	<<GL.ITY>_-^D18>,<
						TEMP%%=1
						.CREF
						TRNN	t1,<GL.ITY>
						.XCREF
					>
					IFE	TEMP%%,<
						.CREF
						TDNN	t1,[GL.ITY]
					>
						PURGE	TEMP%%
						.CREF^
						.CREF

	405572'	634 00 0 00 000000 		tdza	t0,t0		;no, FALSE
	405573'	474 00 0 00 000000 		seto	t0,		;yes, TRUE
	405574'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 11
WARMAC	MAC	 7-Jul-;2 18:15		DECINI

						subttl	DECINI

					;;;	DECINI -- Switch input from TTY to DECWAR.INI, and back again
					;	on eof.
					;
						entry	DECINI
	405575'	44 45 43 51 56 51 		sixbit	/DECINI/
	405576'				decini:	save	<x1,p1>^
						  xlist
						  list
						^
	405600'	336 00 0 00 000000#	decin0:	skipn	hungup
						outstr	[asciz "
					Are you:
					1 - Beginner
					2 - Intermediate
					3 - Expert

	405601'	051 03 0 00 415004'	Which? "]
	405602'	332 00 0 00 000000#		skipe	hungup
	405603'	334 12 0 00 415022'		skipa	p1,["3"]
	405604'	051 04 0 00 000012 		inchwl	p1
	405605'	255 00 0 00 000000 		  jfcl
	405606'	336 00 0 00 000000#		skipn	hungup
	405607'	051 11 0 00 000000 		clrbfi
	405610'	255 00 0 00 000000 		  jfcl
	405611'	201 01 0 00 000010 		movei	t1,10		; hibernate to clear the wake state
	405612'	047 01 0 00 000072 		hiber	t1,
	405613'	255 00 0 00 000000 		  jfcl
	405614'	301 12 0 00 000061 		cail	p1,"1"
	405615'	303 12 0 00 000063 		caile	p1,"3"
	405616'	254 00 0 00 405600'		jrst	decin0
	405617'	476 00 0 00 000141'		setom	bufptr		;and get set to read new line

	405620'	201 05 0 00 405076'		movei	x1,iniexp	; choose ini file
	405621'	306 12 0 00 000063 		cain	p1,"3"
	405622'	254 00 0 00 405627'		jrst	decin1
	405623'	201 05 0 00 405062'		movei	x1,iniint
	405624'	306 12 0 00 000062 		cain	p1,"2"
	405625'	254 00 0 00 405627'		jrst	decin1
	405626'	201 05 0 00 405046'		movei	x1,inibeg
	405627'	260 17 0 00 405725'	decin1:	pushj	p,open.
	405630'	254 00 0 00 405635'		  jrst	deci.1		;no can do, so don't bother

	405631'	260 17 0 00 405717'		pushj	p,ttyon		;clear ^O
	405632'	260 17 0 00 406616'		pushj	p,ocrl.

	405633'	260 17 0 00 406060'		pushj	p,seti.		;set up for input from DECWAR.INI
	405634'	476 00 0 00 000136'		setom	iniflg		;getting input from DECWAR.INI
	405635'				deci.1:	restor	<p1,x1>^
						  xlist
						  list
						^
	405643'	263 17 0 00 000000 		popj	p,

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 11-1
WARMAC	MAC	 7-Jul-;2 18:15		DECINI


					;;;	Here to read a character from DECWAR.INI
					;
	405644'	260 17 0 00 406151'	iich.:	pushj	p,ichr.b	;get character from DECWAR.INI
	405645'	321 11 0 00 405656'		jumpl	c,iich.2	;eof, switch back to TTY
	405646'	335 00 0 00 000000#		skipge	ccflg		;^C?
	405647'	254 00 0 00 405655'		jrst	iich.1		;yes, stop processing DECWAR.INI
	405650'	302 11 0 00 000007 		caie	c,007		;^G?
	405651'	335 00 0 00 000135'		skipge	echflg		;or, echoing turned off?
	405652'	254 00 0 00 405654'		jrst	.+2
	405653'	260 17 0 00 406077'		pushj	p,ochr.		;no, echo character
	405654'	263 17 0 00 000000 		popj	p,		;and do normal input stuff

	405655'	402 00 0 00 000000#	iich.1:	setzm	ccflg		;ok, we've taken care of what ^C asked for
	405656'				iich.2:	save	<x1,p1>^
						  xlist
						  list
						^
	405660'	260 17 0 00 406021'		pushj	p,close.	;close file, get rid of buffers, etc.

	405661'	260 17 0 00 405717'		pushj	p,ttyon		;clear ^O
	405662'	260 17 0 00 405713'		pushj	p,dmpbuf

	405663'	201 05 0 00 405036'		movei	x1,ttyfil
	405664'	260 17 0 00 406060'		pushj	p,seti.		;set up for input from TTY
	405665'	402 00 0 00 000136'		setzm	iniflg		;no longer getting input from DECWAR.INI
	405666'	476 00 0 00 000000#		setom	blank		;no blank lines yet
						restor	<p1,x1>^
						  xlist
						  list
						^
	405675'	324 17 0 00 406150'		pjrst	ichr.		;now get character from TTY
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 12
WARMAC	MAC	 7-Jul-;2 18:15		ECHON/ECHOFF/DMPBUF/TTYON

						subttl	ECHON/ECHOFF/DMPBUF/TTYON

					;;;	ECHON -- turn echoing on
					;
						entry	echon
	405676'	45 43 50 57 56 00 		sixbit	/ECHON/
	405677'	263 17 0 00 000000 	echon:	popj	p,
	405700'	050 00 0 00 405245'		open	tty,eonblk	;open TTY, don't suppress echoing
	405701'	254 04 0 00 000000 		  halt
	405702'	402 00 0 00 000135'		setzm	echflg
	405703'	263 17 0 00 000000 		popj	p,


					;;;	ECHOFF -- turn echoing off
					;
						entry	echoff
	405704'	45 43 50 57 46 46 		sixbit	/ECHOFF/
	405705'	263 17 0 00 000000 	echoff:	popj	p,
	405706'	050 00 0 00 405250'		open	tty,eofblk	;open TTY with echoing suppressed
	405707'	254 04 0 00 000000 		  halt
	405710'	476 00 0 00 000135'		setom	echflg
	405711'	263 17 0 00 000000 		popj	p,


					;;;	DMPBUF -- dump the tty output buffer
					;
						entry	dmpbuf
	405712'	44 55 60 42 65 46 		sixbit	/DMPBUF/
	405713'	336 00 0 00 000000#	dmpbuf:	skipn	hungup
	405714'	067 00 0 00 000000 		output	tty,
	405715'	263 17 0 00 000000 		popj	p,


					;;;	TTYON -- dump the TTY buffer and clear ^O
					;
						entry	ttyon
	405716'	64 64 71 57 56 00 		sixbit	/TTYON/
	405717'	336 00 0 00 000000#	ttyon:	skipn	hungup
	405720'	067 00 0 00 000000 		output	tty,
	405721'	336 00 0 00 000000#		skipn	hungup
	405722'	051 14 0 00 000000 		skpinl
	405723'	255 00 0 00 000000 		  jfcl
	405724'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 13
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- Introduction

						subttl	Low Level I/O -- Introduction

					comment %

					To suspend output to the current file and open a new file for output

						MOVE X1,[<file block>,,<file block>]
						PUSHJ P,OPEN.
						  open failed
						PUSHJ P,SETO.

					To output the character from c to the current output file,

						PUSHJ P,OCHR.

					To close the current output file and restore the old output file

						PUSHJ P,CLOSE.
						PUSHJ P,SETO.	(X1 must have value returned by previous call to SETO.)


					To suspend input from the current file and open a new file for input

						HRLI X1,<file block>
						PUSHJ P,OPEN.
						  open failed
						PUSHJ P,SETI.

					To input a character from the current input file into c

						PUSHJ P,ICHR.

					To close the current input file and restore the old input file

						PUSHJ P,CLOSE.
						PUSHJ P,SETI.	(X1 must have value returned by previous call to SETI.)


					The file block has the format

						.fbcio	address of character output,,input routines
						.fbbuf	0,,address of buffers
							or -1,,amount of space to allocate for buffers @ .JBFF
						.fbfnc	protection bit, channel,,filop. function code
						.fbios	open flags, data mode
						.fbdev	device name
						.fbbrh	address of output,,input buffer control blocks
						.fbnbf	number of output,,input buffers
						.fbnam	file name
							or 0 to end block (if init device only)
						.fbext	extension
						.fbprv	protection code (if writing file)
						.fbppn	PPN
							or 0 to end block (if ersatz device)
						.fbsfd	SFDs, terminated by the first 0 word
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 13-1
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- Introduction

					%
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 14
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- OPEN./CLOSE.

						subttl	Low Level I/O -- OPEN./CLOSE.

					;;;	OPEN. -- Open file for input and/or output.
					;
					;		MOVEI	X1,<file block>
					;		PUSHJ	P,OPEN.
					;		  nope
					;		success
					;
					;	Input
					;	  X1	address of file block
					;
					;	Note: throughout this routine,
					;	X2 points to the bottom of the buffer space.  If buffer space
					;	is allocated by this routine X2 will be the value of .JBFF upon
					;	entry, else it will be the address of the static buffer space
					;	(probably the TTY output buffer).
					;	X3 holds the value of .JBFF (.JBFF itself is changed so FILOP.
					;	allocates any buffer space in the right place).
					;
	405725'				open.:	save	<x2,x3>^
						  xlist
						  list
						^
	405727'	402 00 0 00 002024'		setzm	fl.ff		;no buffers allocated yet
	405730'	200 07 0 00 405474*		move	x3,.JBFF	;save real value of .JBFF
	405731'	331 06 0 05 000001 		skipl	x2,.fbbuf(x1)	;need to allocate buffers?
	405732'	254 00 0 00 405743'		jrst	open.1		;no, buffers are static
	405733'	202 07 0 00 002024'		movem	x3,fl.ff	;reduce core to here on close
	405734'	271 07 0 06 000000 		addi	x3,(x2)		;new .JBFF
	405735'	200 06 0 00 405730*		move	x2,.JBFF	;start of allocated buffers
	405736'	201 01 0 07 777777 		movei	t1,-1(x3)	;last word needed for buffers
	405737'	317 01 0 00 000000*		camg	t1,.JBREL	;already allocated?
	405740'	254 00 0 00 405743'		jrst	open.1		;yes, don't need to grab any more
	405741'	047 01 0 00 000011 		core	t1,
						  warn	<Not enough core>,open.7^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Not enough core>^
						  asciz `%Not enough core
					`
						^]
							jrst open.7
	405742'	254 00 0 00 415052'			]
						^
	405743'	202 06 0 00 405735*	open.1:	movem	x2,.JBFF	;start of buffers (for filop.)

	405744'	515 01 0 05 000002 		hrlzi	t1,.fbfnc(x1)	;copy filop. block
	405745'	541 01 0 00 002025'		hrri	t1,foblk
	405746'	251 01 0 00 002031'		blt	t1,foblk+4

	405747'	336 00 0 05 000007 		skipn	.fbnam(x1)	;file name given?
	405750'	254 00 0 00 405765'		jrst	open.4		;no, just opening device (must be tty)
	405751'	551 01 0 00 002033'		hrrzi	t1,leblk
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 14-1
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- OPEN./CLOSE.

	405752'	202 01 0 00 002032'		movem	t1,foblk+.foleb	;filop. block points to lookup/enter block
	405753'	515 01 0 05 000007 		hrlzi	t1,.fbnam(x1)	;copy lookup/enter block
	405754'	541 01 0 00 002033'		hrri	t1,leblk
	405755'	251 01 0 00 002036'		blt	t1,leblk+3
	405756'	331 00 0 05 000012 		skipl	.fbppn(x1)	;negative PPN?
	405757'	254 00 0 00 405764'		jrst	open.2		;no
	405760'	047 01 0 00 000024 		getppn	t1,		;use logged in PPN
	405761'	255 00 0 00 000000 		  jfcl
	405762'	202 01 0 00 002036'		movem	t1,leblk+3
	405763'	254 00 0 00 405764'		jrst	open.3		;and ignore any SFDs

	405764'				open.2:
	405764'	334 01 0 00 415057'	open.3:	skipa	t1,[6,,foblk]	;use long filop. block (open file too)
	405765'	200 01 0 00 415060'	open.4:	move	t1,[5,,foblk]
	405766'	336 00 0 00 001760'		skipn	debflg			; if running from funny PPN
	405767'	254 00 0 00 406000'		jrst	open.8
	405770'	337 00 0 00 001760'		skipg	debflg			; then if in development area
						jrst	[	movsi	t2,'DSK'	; then use local files
								movem	t2,fo.dev
								setzm	le.ppn
								jrst	open.8
	405771'	254 00 0 00 415061'			]
	405772'	554 02 0 00 002034'		hlrz	t2,le.ext		; if 'STA'
	405773'	306 02 0 00 636441 		cain	t2,'STA'
	405774'	402 00 0 00 002036'		setzm	le.ppn			; then use local file
	405775'	306 02 0 00 476260 		cain	t2,'GRP'		; map DECWAR.GRP to
	405776'	201 02 0 00 556050 		movei	t2,'MPH'		;     DECWAR.MPH
	405777'	506 02 0 00 002034'		hrlm	t2,le.ext
	406000'	047 01 0 00 000155 	open.8:	filop.	t1,		;open it, set up buffers, etc.
	406001'	254 00 0 00 406004'		  jrst	open.5		;oops!
	406002'	350 00 0 17 000000 		aos	(p)
	406003'	254 00 0 00 406011'		jrst	open.6

	406004'	312 07 0 00 405743*	open.5:	came	x3,.JBFF	;buffer space allocated by this routine?
	406005'	254 00 0 00 406011'		jrst	open.6		;no, don't need to deallocate
	406006'	201 07 0 06 000000 		movei	x3,(x2)		;pull .JBFF back down
	406007'	047 06 0 00 000011 		core	x2,		;shrink (maybe)
	406010'	255 00 0 00 000000 		  jfcl
	406011'	202 07 0 00 406004*	open.6:	movem	x3,.JBFF	;restore .JBFF
	406012'				open.7:	restor	<x3,x2>^
						  xlist
						  list
						^
	406020'	263 17 0 00 000000 		popj	p,



					;;;	CLOSE. -- Close the most recently opened file and release any
					;	core that was allocated for buffers.
					;
	406021'	515 01 0 00 070000 	close.:	hrlzi	t1,(close 0,)	;build close instr
	406022'	554 02 0 00 002025'		hlrz	t2,fo.fnc	;add in channel number
	406023'	137 02 0 00 415073'		dpb	t2,[point 4,t1,12]
	406024'	256 00 0 00 000001 		xct	t1		;close it

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 14-2
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- OPEN./CLOSE.

	406025'	337 01 0 00 002024'		skipg	t1,fl.ff	;need to reduce core?
	406026'	263 17 0 00 000000 		popj	p,		; no

	406027'	402 00 0 00 002024'		setzm	fl.ff
	406030'	202 01 0 00 406011*		movem	t1,.JBFF
	406031'	405 01 0 00 777000 		andi	t1,^-777	;last page used
	406032'	200 02 0 00 405737*		move	t2,.JBREL
	406033'	405 02 0 00 777000 		andi	t2,^-777	;last page allocated
	406034'	306 01 0 02 000000 		cain	t1,(t2)		;same?
	406035'	263 17 0 00 000000 		popj	p,		;yes, forget CORE UUO

	406036'	047 01 0 00 000011 		core	t1,		;deallocate buffer space
						  warn	<Can't reduce core>^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't reduce core>^
						  asciz `%Can't reduce core
					`
						^]
							jrst .+1
	406037'	254 00 0 00 415101'			]
						^
	406040'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 15
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- SETO./SETI.

						subttl	Low Level I/O -- SETO./SETI.

					;;;	SETO. -- Set up for output to new file.
					;
					;	Input
					;	  X1[L]	address of new output file block
					;	Output
					;	  X1[L]	address of old output file block
					;
	406041'	554 01 0 00 000005 	seto.:	hlrz	t1,x1
	406042'	504 05 0 00 000264'		hrl	x1,obflb	;get addr of old file block
	406043'	542 01 0 00 000264'		hrrm	t1,obflb	;save addr of new file block

	406044'	554 02 0 01 000000 		hlrz	t2,.fbcio(t1)	;get addr of char out routine
	406045'	202 02 0 00 000270'		movem	t2,oc		;save it

	406046'	554 02 0 01 000005 		hlrz	t2,.fbbrh(t1)	;addr of buffer control block
	406047'	201 03 0 02 000002 		movei	t3,.BFCTR(t2)	;addr of char count
	406050'	202 03 0 00 000265'		movem	t3,obfctr
	406051'	201 03 0 02 000001 		movei	t3,.BFPTR(t2)	;addr of char pointer
	406052'	202 03 0 00 000266'		movem	t3,obfptr

	406053'	515 02 0 00 067000 		hrlzi	t2,(output 0,)	;build output instr
	406054'	202 02 0 00 000267'		movem	t2,obfins
	406055'	554 02 0 01 000002 		hlrz	t2,.fbfnc(t1)	;add in channel number
	406056'	137 02 0 00 415106'		dpb	t2,[point 4,obfins,12]

	406057'	263 17 0 00 000000 		popj	p,



					;;;	SETI. -- Set up for input from new file.
					;
					;	Input
					;	  X1[R]	address of new input file block
					;	Output
					;	  X1[R]	address of old input file block
					;
	406060'	551 01 0 05 000000 	seti.:	hrrzi	t1,(x1)
	406061'	540 05 0 00 000271'		hrr	x1,ibflb	;get addr of old file block
	406062'	542 01 0 00 000271'		hrrm	t1,ibflb	;save addr of new file block

	406063'	550 02 0 01 000000 		hrrz	t2,.fbcio(t1)	;get addrr of char in routine
	406064'	202 02 0 00 000275'		movem	t2,ic		;save it

	406065'	550 02 0 01 000005 		hrrz	t2,.fbbrh(t1)	;addr of buffer control block
	406066'	201 03 0 02 000002 		movei	t3,.BFCTR(t2)	;addr of char count
	406067'	202 03 0 00 000272'		movem	t3,ibfctr
	406070'	201 03 0 02 000001 		movei	t3,.BFPTR(t2)	;addr of char pointer
	406071'	202 03 0 00 000273'		movem	t3,ibfptr

	406072'	515 02 0 00 056000 		hrlzi	t2,(in 0,)	;build in instr
	406073'	202 02 0 00 000274'		movem	t2,ibfins
	406074'	554 02 0 01 000002 		hlrz	t2,.fbfnc(t1)	;add in channel number
	406075'	137 02 0 00 415107'		dpb	t2,[point 4,ibfins,12]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 15-1
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- SETO./SETI.


	406076'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 16
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- OCHR./ICHR.

						subttl	Low Level I/O -- OCHR./ICHR.

					;;;	OCHR. -- Low level character output routine.
					;	Output the character from c.
					;
	406077'	254 00 1 00 000270'	ochr.:	jrst	@oc		;dispatch to character output routine

	406100'	332 00 0 00 000000#	ochr.b:	skipe	hungup		; if job hung up
	406101'	263 17 0 00 000000 		popj	p,		; then ignore this output request!
	406102'	371 00 1 00 000265'		sosl	@obfctr		;buffered output
	406103'	254 00 0 00 406115'		jrst	ochr.x
	406104'	256 00 0 00 000267'		xct	obfins		;output buffer
	406105'	261 17 0 00 000000 		push	p,0
	406106'	201 00 0 00 000120 		movei	0,^d80		; force byte count to small number
	406107'	202 00 1 00 000265'		movem	0,@obfctr
	406110'	262 17 0 00 000000 		pop	p,0
	406111'	254 00 0 00 406100'		jrst	ochr.b

	406112'	336 00 0 00 000000#	ochr.t:	skipn	hungup		; ignore outchr if job hungup
	406113'	051 01 0 00 000011 		outchr	c		;ttcall output
	406114'	254 00 0 00 406116'		jrst	.+2

	406115'	136 11 1 00 000266'	ochr.x:	idpb	c,@obfptr
	406116'	350 00 0 00 000000#		aos	hcpos		;update horizontal cursor position
	406117'	602 11 0 00 000140 		trne	c,140		;control char?
	406120'	263 17 0 00 000000 		popj	p,		;no, no special processing required

						save	<c>^
						  xlist
						  list
						^
	406122'	551 11 0 11 000000 		hrrzi	c,(c)
	406123'	370 00 0 00 000000#		sos	hcpos		;most control chars are non printing

	406124'	302 11 0 00 000015 		caie	c,cr		;carriage return?
	406125'	254 00 0 00 406132'		jrst	ochr.1		;no
	406126'	332 00 0 00 000000#		skipe	hcpos		;line was blank?
	406127'	476 00 0 00 000000#		setom	blank		;no, next <LF> will be first blank line
	406130'	402 00 0 00 000000#		setzm	hcpos		;back at left margin
	406131'	254 00 0 00 406144'		jrst	ochr.2

	406132'	306 11 0 00 000012 	ochr.1:	cain	c,lf		;line feed?
	406133'	350 00 0 00 000000#		aos	blank		;yes, increment blank line count

	406134'	306 11 0 00 000010 		cain	c,010		;backspace?
	406135'	370 00 0 00 000000#		sos	hcpos		;yes, back up one

	406136'	302 11 0 00 000011 		caie	c,011		;tab?
	406137'	254 00 0 00 406144'		jrst	ochr.2		;no
	406140'	200 11 0 00 000000#		move	c,hcpos		;get old horizontal cursor position
	406141'	271 11 0 00 000010 		addi	c,10		;compute new position
	406142'	405 11 0 00 777740 		andi	c,^-37
	406143'	202 11 0 00 000000#		movem	c,hcpos

	406144'				ochr.2:	restor	<c>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 16-1
WARMAC	MAC	 7-Jul-;2 18:15		Low Level I/O -- OCHR./ICHR.

						  xlist
						  list
						^
	406147'	263 17 0 00 000000 		popj	p,


					;;;	ICHR. -- Low level character input routine.
					;	Input a character into c.
					;
	406150'	254 00 1 00 000275'	ichr.:	jrst	@ic		;dispatch to character input routine

	406151'	375 00 1 00 000272'	ichr.b:	sosge	@ibfctr		;buffered input
	406152'	254 00 0 00 406156'		jrst	ichr.1
	406153'	134 11 1 00 000273'		ildb	c,@ibfptr	;get character
	406154'	322 11 0 00 406151'		jumpe	c,ichr.b	;ignore nulls
	406155'	263 17 0 00 000000 		popj	p,

	406156'	256 00 0 00 000274'	ichr.1:	xct	ibfins		;get next buffer
	406157'	254 00 0 00 406151'		  jrst	ichr.b
	406160'	474 11 0 00 000000 		seto	c,		;any error is assumed to be eof
	406161'	263 17 0 00 000000 		popj	p,

	406162'	336 00 0 00 000000#	ichr.t:	skipn	hungup		; if job is hungup
	406163'	332 00 0 00 000000#		skipe	ccflg		; or ^C was seen
	406164'	254 00 0 00 406172'		jrst	incr.h		; then return an <esc>
	406165'	476 00 0 00 000000#		setom	inwait		; tell hangup detect we are waiting for input
	406166'	051 04 0 00 000011 		inchwl	c
	406167'	402 00 0 00 000000#		setzm	inwait
	406170'	336 00 0 00 000000#		skipn	ccflg		; if ^C or
	406171'	332 00 0 00 000000#		skipe	hungup		; if hangup 
					incr.h:	jrst	[movei	c,12	; then return <lf>
							 skipn	hungup	; if hungup
							 clrbfi		; don't do this
							 popj	p,
	406172'	254 00 0 00 415113'			]
	406173'	322 11 0 00 406162'		jumpe	c,ichr.t
	406174'	306 11 0 00 000015 		cain	c,15		; ignore <ret>
	406175'	254 00 0 00 406162'		jrst	ichr.t
	406176'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 17
WARMAC	MAC	 7-Jul-;2 18:15		GTKN -- GTKN

						subttl	GTKN -- GTKN

					;;;	GTKN -- Read and parse a line of input.  Return the individual
					;	tokens in TKNLST, their numeric value in VALLST (else 0), their
					;	type (eol, null, integer, floating point, alfa) in TYPLST, and
					;	a pointer to the first character in PTRLST.  The last token  will
					;	always be EOL.  Return the number of tokens (minus the EOL) in
					;	NTOK.
					;
						entry	gtkn
	406177'	47 64 53 56 00 00 		sixbit	/GTKN/
	406200'	332 00 0 00 000000#	gtkn:	skipe	hungup	; if job is hung up
	406201'	263 17 0 00 000000 		popj	p,		; then don't try to get anything
						save	<x1,x2>^
						  xlist
						  list
						^
	406204'	352 00 0 00 000140'		aose	ccflg.		;^C after last GTKN call?
	406205'	357 00 0 00 000141'		aosg	bufptr		;at end of line?
	406206'	254 00 0 00 406211'		jrst	gtkn.1		;yes, get new input line
	406207'	260 17 0 00 406616'		pushj	p,ocrl.
	406210'	254 00 0 00 406222'		jrst	gtkn.2

	406211'				gtkn.1:
	406211'	200 01 0 00 000356'		move	t1,locked	; if we have database locked
	406212'	202 01 0 00 000357'		movem	t1,svlock
	406213'	332 00 0 00 000001 		skipe	t1
	406214'	260 17 0 00 412142'		pushj	p,unlo.
	406215'	260 17 0 00 406431'		pushj	p,inli.		;get input line
	406216'	332 01 0 00 000357'		skipe	t1,svlock	; re-grab database if necessary
						jrst	[pushj	p,lock.
							 skipe	lkfail
							 jrst	.-1	; we have to get the lock back
	406217'	254 00 0 00 415117'			 jrst	.+1]
	406220'	201 01 0 00 000143'		movei	t1,linbuf
	406221'	202 01 0 00 000141'		movem	t1,bufptr
	406222'	400 00 0 00 000000 	gtkn.2:	setz	f,
	406223'	515 05 0 00 777762 		hrlzi	x1,-<kmaxtk-1>	;maximum number of tokens to return
	406224'	332 00 0 00 000000#		skipe	hungup		; if job has hungup
						jrst	[movei	t1,kalf	; force 'QUIT' token
							 movem	t1,typlst(x1)
							 move	t1,[asciz 'QUIT']
							 movem	t1,tknlst(x1)
							 aoja	x1,gtkn.5
	406225'	254 00 0 00 415124'			]

	406226'	260 17 0 00 406271'	gtkn.3:	pushj	p,nxtt.		;scan off next token
	406227'	201 01 0 00 000000 		movei	t1,knul		;assume token is blank
	406230'	602 00 0 00 000001 		trne	f,tf.num
	406231'	201 01 0 00 000001 		movei	t1,kint		;token is integer
	406232'	602 00 0 00 000040 		trne	f,tf.pnt
	406233'	201 01 0 00 000002 		movei	t1,kflt		;token is floating point
	406234'	602 00 0 00 000002 		trne	f,tf.nnm
	406235'	201 01 0 00 000003 		movei	t1,kalf		;token is non-numeric characters
	406236'	202 01 0 05 000000#		movem	t1,typlst(x1)	;store token type
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 17-1
WARMAC	MAC	 7-Jul-;2 18:15		GTKN -- GTKN

	406237'	602 00 0 00 000004 		trne	f,tf.eol	;end of line?
	406240'	254 00 0 00 406247'		jrst	gtkn.4		;yes

	406241'	253 05 0 00 406226'		aobjn	x1,gtkn.3
						movei	p1,[ascil <Too many words -- line ignored>^
						  asciz `Too many words -- line ignored
					`
	406242'	201 12 0 00 415131'		^]
	406243'	260 17 0 00 406710'		pushj	p,ostr.
	406244'	400 05 0 00 000000 		setz	x1,
	406245'	476 00 0 00 000141'		setom	bufptr
	406246'	254 00 0 00 406253'		jrst	gtkn.5

	406247'	606 00 0 00 000010 	gtkn.4:	trnn	f,tf.chr	;any characters in token?
	406250'	602 05 0 00 777777 		trne	x1,777777	;no, is this the first token?
	406251'	551 05 0 05 000001 		hrrzi	x1,1(x1)	;increment token count
	406252'	551 05 0 05 000000 		hrrzi	x1,(x1)

	406253'	202 05 0 00 000000#	gtkn.5:	movem	x1,ntok
						movx	t1,keol		^;type of last token is end of line

						.XCREF
		777777	777777			TEST%%=keol
					.IFN <TEST%%>,ABSOLUTE,<
						.CREF
						MOVE	t1,[keol]
						.XCREF
					>
					.IF <TEST%%>,ABSOLUTE,<
			000000			TEST%%=0
					IFE	<<keol>_-^D18>,<
						TEST%%=1
						.CREF
						MOVEI	t1,<keol>
						.XCREF
					>
					IFE	TEST%%,<IFE	<<keol>_^D18>,<
						TEST%%=1
						.CREF
						MOVSI	t1,(keol)
						.XCREF
					>>
					IFE	TEST%%,<IFE	<<<keol>_-^D18>-^O777777>,<
			000001			TEST%%=1
						.CREF
	406254'	561 01 0 00 777777 		HRROI	t1,<keol>
						.XCREF
					>>
					IFE	TEST%%,<IFE	<<<keol>_^D18>-^O777777B17>,<
						TEST%%=1
						.CREF
						HRLOI	t1,(<keol>-^O777777)
						.XCREF
					>>
					IFE	TEST%%,<
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 17-2
WARMAC	MAC	 7-Jul-;2 18:15		GTKN -- GTKN

						.CREF
						MOVE	t1,[keol]
						.XCREF
					>
					>	;[35][32] END OF .IF <keol>,ABSOLUTE
						PURGE	TEST%%
						.CREF
	406255'	202 01 0 05 000000#		movem	t1,typlst(x1)
	406256'	402 00 0 05 000000#		setzm	vallst(x1)
	406257'	201 01 0 05 000000 		movei	t1,(x1)
	406260'	402 00 0 01 000000#		setzm	tknlst(t1)
						restor	<x2,x1>^
						  xlist
						  list
						^
	406267'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 18
WARMAC	MAC	 7-Jul-;2 18:15		GTKN -- NXTT.

						subttl	GTKN -- NXTT.

					;;;	NXTT. -- Get the next token from the input line and store it
					;	in TKNLST, store it's numeric value is VALLST, and store the
					;	index to the first character of the token in PTRLST.
					;
					;	Input
					;	  X1	Token index
					;	Output
					;	  F	LH  input line flag bits (lf.eol)
					;		RH  token flag bits

	406270'	56 70 64 64 16 00 		sixbit	/NXTT./
	406271'				nxtt.:	save	<x2,x3,p1>^
						  xlist
						  list
						^
	406274'	510 00 0 00 000000 		hllz	f,f		;zero out local flag bits
	406275'	201 12 0 05 000000#		movei	p1,tknlst(x1)	;place to stick token
	406276'	505 12 0 00 440700 		hrli	p1,(point 7)
	406277'	402 00 0 12 000000 		setzm	(p1)
	406300'	201 07 0 00 000005 		movei	x3,5		;max number of chars in token
	406301'	400 06 0 00 000000 		setz	x2,		;numeric value of token

	406302'	260 17 0 00 406360'		pushj	p,skpb.		;skip leading spacing characters
	406303'	200 01 0 00 000141'		move	t1,bufptr
	406304'	202 01 0 05 000000#		movem	t1,ptrlst(x1)	;save index to beginning of token
	406305'	625 11 0 00 777777 		tlza	c,-1		;mask out character type bits
	406306'	550 11 1 00 000141'	nxtt.1:	hrrz	c,@bufptr	;get character from input line
	406307'	303 11 0 00 000137 		caile	c,137		;character is lower case?
	406310'	275 11 0 00 000040 		subi	c,040		;yes, change to upper case
	406311'	504 11 0 11 405267'		hrl	c,cbits(c)	;get character type bits
	406312'	603 11 0 00 000400 		tlne	c,cf.eoc	;end of command?
	406313'	254 00 0 00 406333'		jrst	nxtt.3		;yes
	406314'	603 11 0 00 010000 		tlne	c,cf.dlm	;delimiter?
	406315'	254 00 0 00 406327'		jrst	nxtt.2		;yes, done with this token
	406316'	606 00 0 00 000002 		trnn	f,tf.nnm	;non-numeric chars seen already?
	406317'	607 11 0 00 340000 		tlnn	c,cf.num	;numeric character?
	406320'	664 00 0 00 000002 		troa	f,tf.nnm
	406321'	260 17 0 00 406367'		pushj	p,anum.		;add character to number
	406322'	361 07 0 00 406324'		sojl	x3,.+2		;make sure there's room for this character
	406323'	136 11 0 00 000012 		idpb	c,p1		;add character to token
	406324'	660 00 0 00 000010 		tro	f,tf.chr	;flag that a character has been seen
	406325'	350 00 0 00 000141'		aos	bufptr
	406326'	254 00 0 00 406306'		jrst	nxtt.1

	406327'	260 17 0 00 406360'	nxtt.2:	pushj	p,skpb.		;skip trailing spacing characters
	406330'	603 11 0 00 010000 		tlne	c,cf.dlm	;terminating character is a delimiter?
	406331'	350 00 0 00 000141'		aos	bufptr		;yes, skip it
	406332'	603 11 0 00 000400 		tlne	c,cf.eoc	;end of command line?
	406333'	660 00 0 00 000004 	nxtt.3:	tro	f,tf.eol	;yes, flag it
	406334'	603 11 0 00 020200 		tlne	c,cf.eol!cf.com	;end of line?
	406335'	476 00 0 00 000141'		setom	bufptr		;yes

	406336'	606 00 0 00 000002 		trnn	f,tf.nnm	;non-numeric character seen?
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 18-1
WARMAC	MAC	 7-Jul-;2 18:15		GTKN -- NXTT.

	406337'	254 00 0 00 406342'		jrst	nxtt.4		;no
	406340'	400 06 0 00 000000 		setz	x2,		;make sure 0 is returned for numeric value
	406341'	620 00 0 00 000161 		trz	f,tf.num!tf.sgn!tf.neg!tf.pnt
	406342'	602 00 0 00 000100 	nxtt.4:	trne	f,tf.neg	;number is negative?
	406343'	210 06 0 00 000006 		movn	x2,x2		;yes, take care of it
	406344'	202 06 0 05 000000#		movem	x2,vallst(x1)
						restor	<p1,x3,x2>^
						  xlist
						  list
						^
	406356'	263 17 0 00 000000 		popj	p,



						;Skip string of spacing characters pointed to by BUFPTR.

	406357'	63 53 60 42 16 00 		sixbit	/SKPB./
	406360'	200 11 1 00 000141'	skpb.:	move	c,@bufptr	;get next character
	406361'	504 11 0 11 405267'		hrl	c,cbits(c)	;get character type bits
	406362'	607 11 0 00 004000 		tlnn	c,cf.spc	;spacing character?
	406363'	263 17 0 00 000000 		popj	p,		;no, done
	406364'	350 00 0 00 000141'		aos	bufptr		;yes, skip it
	406365'	254 00 0 00 406360'		jrst	skpb.



						;Add C to the partially built number in X2.

	406366'	41 56 65 55 16 00 		sixbit	/ANUM./
	406367'	607 11 0 00 040000 	anum.:	tlnn	c,cf.sgn	;sign?
	406370'	254 00 0 00 406377'		jrst	anum.1		;no
	406371'	662 00 0 00 000030 		troe	f,tf.sgn!tf.chr	;flag that sign has been seen
	406372'	254 00 0 00 406425'		jrst	anum.4		;this isn't the first character
	406373'	551 01 0 11 000000 		hrrzi	t1,(c)		;get character only (no flag bits)
	406374'	306 01 0 00 000055 		cain	t1,"-"		;minus sign?
	406375'	660 00 0 00 000100 		tro	f,tf.neg	;yes, remember that
	406376'	263 17 0 00 000000 		popj	p,

	406377'	607 11 0 00 200000 	anum.1:	tlnn	c,cf.pnt	;decimal point?
	406400'	254 00 0 00 406407'		jrst	anum.2		;no
	406401'	662 00 0 00 000040 		troe	f,tf.pnt	;flag that decimal point has been seen
	406402'	254 00 0 00 406425'		jrst	anum.4		;this is the second decimal point
	406403'	127 06 0 00 000006 		fltr	x2,x2		;float the number
	406404'	515 07 0 00 204500 		hrlzi	x3,(10.0)
	406405'	202 07 0 00 000137'		movem	x3,scale	;scaling factor for first fractional digit
	406406'	263 17 0 00 000000 		popj	p,

	406407'	660 00 0 00 000001 	anum.2:	tro	f,tf.num	;digit seen
	406410'	602 00 0 00 000040 		trne	f,tf.pnt	;working on fraction portion?
	406411'	254 00 0 00 406415'		jrst	anum.3		;yes
	406412'	221 06 0 00 000012 		imuli	x2,^D10
	406413'	271 06 0 11 777720 		addi	x2,-"0"(c)	;add digit into integer
	406414'	263 17 0 00 000000 		popj	p,

	406415'	201 01 0 11 777720 	anum.3:	movei	t1,-"0"(c)	;get digit to add to fraction
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 18-2
WARMAC	MAC	 7-Jul-;2 18:15		GTKN -- NXTT.

	406416'	127 01 0 00 000001 		fltr	t1,t1		;float it
	406417'	200 02 0 00 000137'		move	t2,scale	;get scaling factor
	406420'	170 01 0 00 000002 		fdv	t1,t2		;scale it
	406421'	140 06 0 00 000001 		fad	x2,t1		;add it into the number
	406422'	165 02 0 00 204500 		fmpri	t2,(10.0)	;adjust scaling factor for next digit
	406423'	202 02 0 00 000137'		movem	t2,scale
	406424'	263 17 0 00 000000 		popj	p,

	406425'	660 00 0 00 000002 	anum.4:	tro	f,tf.nnm	;illegal sequence of numeric characters
	406426'	400 06 0 00 000000 		setz	x2,
	406427'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 19
WARMAC	MAC	 7-Jul-;2 18:15		GETLIN -- INLI.

						subttl	GETLIN -- INLI.

					;;;	INLI. -- Read a line from the tty and store it in LINBUF.
					;	If the first character typed is <ESC> (even before ^H or ^U),
					;	return the previous input line.  Handle line editing (^H, ^U,
					;	^R) to allow backing up over ^G, which is the echo toggle char.
					;	Ignore <CR>, and convert the end of line character to <NUL>.
					;	Always echo <CR>, and also echo <LF> if the end of line char
					;	didn't output any line feed (<ESC>).
					;
	406430'	51 56 54 51 16 00 		sixbit	/INLI./
	406431'	336 00 0 00 000000#	inli.:	skipn	hungup
	406432'	067 00 0 00 000000 		output	tty,
	406433'	476 00 0 00 000141'		setom	bufptr		;new line
	406434'	260 17 0 00 406513'		pushj	p,nxch.		;get first character
	406435'	606 00 0 00 000100 		trnn	f,cf.rpt	;repeat previous command?
	406436'	254 00 0 00 406441'		jrst	inli.1		;no
	406437'	476 00 0 00 000000#		setom	rptflg		;yes, say so (can't repeat TELL commands)
	406440'	254 00 0 00 406460'		jrst	inli.5

	406441'	402 00 0 00 000000#	inli.1:	setzm	rptflg		;this is a new command
	406442'	402 00 0 00 000142'		setzm	chrcnt		;no characters read yet
	406443'	254 00 0 00 406445'		jrst	.+2

	406444'	260 17 0 00 406513'	inli.2:	pushj	p,nxch.		;get next character
	406445'	602 00 0 00 003203 		trne	f,cf.spe	;character requires special action?
	406446'	254 00 0 00 406454'		jrst	inli.3		;yes
	406447'	350 01 0 00 000142'		aos	t1,chrcnt	;increment input character count
	406450'	202 11 0 01 000142'		movem	c,linbuf-1(t1)	;store character in line buffer
	406451'	305 01 0 00 000120 		caige	t1,maxcnt	;buffer full yet?
	406452'	254 00 0 00 406444'		jrst	inli.2		;no, get next character
	406453'	254 00 0 00 406456'		jrst	inli.4		;yes, terminate input line

	406454'	606 00 0 00 000200 	inli.3:	trnn	f,cf.eol	;end of line character?
	406455'	254 00 0 00 406472'		jrst	inli.6		;no
	406456'	350 01 0 00 000142'	inli.4:	aos	t1,chrcnt
	406457'	402 00 0 01 000142'		setzm	linbuf-1(t1)	;end input with a null character
	406460'	201 11 0 00 000015 	inli.5:	movei	c,cr		;return to left margin
	406461'	260 17 0 00 406077'		pushj	p,ochr.
	406462'	201 11 0 00 000012 		movei	c,lf
	406463'	331 00 0 00 000136'		skipl	iniflg		;input from DECWAR.INI?
	406464'	602 00 0 00 000020 		trne	f,cf.ff		;character already echoed form feed?
	406465'	354 00 0 00 000000#		aosa	blank		;yes, already on next line
	406466'	260 17 0 00 406077'		pushj	p,ochr.		;no, goto next output line
	406467'	332 00 0 00 000135'		skipe	echflg		;echoing turned off?
	406470'	260 17 0 00 405677'		pushj	p,echon		;yes, turn it on again
	406471'	263 17 0 00 000000 		popj	p,

	406472'	602 00 0 00 002000 	inli.6:	trne	f,cf.etg
	406473'	260 17 0 00 406550'		pushj	p,echg.		;toggle echo

	406474'	602 00 0 00 001000 		trne	f,cf.dsp
	406475'	260 17 0 00 406523'		pushj	p,disp.		;display line

	406476'	606 00 0 00 000001 		trnn	f,cf.bsc	;back up over single character?
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 19-1
WARMAC	MAC	 7-Jul-;2 18:15		GETLIN -- INLI.

	406477'	254 00 0 00 406502'		jrst	inli.7		;no
	406500'	375 00 0 00 000142'		sosge	chrcnt
	406501'	402 00 0 00 000142'		setzm	chrcnt

	406502'	606 00 0 00 000002 	inli.7:	trnn	f,cf.bsl	;back space over entire line?
	406503'	254 00 0 00 406444'		jrst	inli.2		;no
	406504'	402 00 0 00 000142'		setzm	chrcnt		;yes, no more chars in buffer
	406505'	336 00 0 00 000000#		skipn	hungup
	406506'	051 03 0 00 415137'		outstr	[byte (7) 15,12]
	406507'	335 00 0 00 000135'		skipge	echflg		;echoing off?
	406510'	260 17 0 00 405677'		pushj	p,echon		;yes, turn it on
	406511'	254 00 0 00 406444'		jrst	inli.2
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 20
WARMAC	MAC	 7-Jul-;2 18:15		GETLIN -- NXCH.

						subttl	GETLIN -- NXCH.

					;;;	Get the next character and return it's flag bits.
					;
					;	Input
					;	  F	LH  line processing flags (global to all characters)
					;	Output
					;	  F	RH  flag bits for character
					;	  CHR	RH  character
					;
	406512'	56 70 43 50 16 00 		sixbit	/NXCH./
	406513'	260 17 0 00 406150'	nxch.:	pushj	p,ichr.		;get the next character
	406514'	540 00 0 11 405267'		hrr	f,cbits(c)	;get the character type bits

	406515'	602 00 0 00 000004 		trne	f,cf.ign	;ignore this character?
	406516'	254 00 0 00 406513'		jrst	nxch.		;yes

	406517'	332 00 0 00 000135'		skipe	echflg		;characters are being echoed?
	406520'	620 00 0 00 000030 		trz	f,cf.cr!cf.ff	;no, didn't echo <CR> or <LF>,<VT>,<FF>

	406521'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 21
WARMAC	MAC	 7-Jul-;2 18:15		GETLIN -- DISP.

						subttl	GETLIN -- DISP.

					;;;	DISP. -- Display the current input line in response to ^R.
					;
	406522'	44 51 63 60 16 00 		sixbit	/DISP./
	406523'	336 00 0 00 000000#	disp.:	skipn	hungup
	406524'	051 03 0 00 415137'		outstr	[byte (7) 15,12]
	406525'	335 00 0 00 000135'		skipge	echflg		;is echoing turned on?
	406526'	260 17 0 00 405677'		pushj	p,echon		;no, turn it on

	406527'	210 01 0 00 000142'		movn	t1,chrcnt	;negative number of characters in buffer
	406530'	515 01 0 01 777777 		hrlzi	t1,-1(t1)
	406531'	541 01 0 00 000142'		hrri	t1,linbuf-1

	406532'	252 01 0 00 406546'	disp.2:	aobjp	t1,disp.4	;no more characters to echo
	406533'	550 11 0 01 000000 		hrrz	c,(t1)		;get character from buffer
	406534'	301 11 0 00 000007 		cail	c,007
	406535'	303 11 0 00 000015 		caile	c,015
	406536'	301 11 0 00 000040 		cail	c,040
	406537'	254 00 0 00 406543'		jrst	disp.3		;printing character
	406540'	336 00 0 00 000000#		skipn	hungup
	406541'	051 01 0 00 415157'		outchr	["^"]
	406542'	271 11 0 00 000100 		addi	c,100
	406543'	336 00 0 00 000000#	disp.3:	skipn	hungup
	406544'	051 01 0 00 000011 		outchr	c
	406545'	254 00 0 00 406532'		jrst	disp.2

	406546'	263 17 0 00 000000 	disp.4:	popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 22
WARMAC	MAC	 7-Jul-;2 18:15		GETLIN -- ECHG.

						subttl	GETLIN -- ECHG.

					;;;	ECHG. -- Toggle echo in response to ^G input.
					;
	406547'	45 43 50 47 16 00 		sixbit	/ECHG./
	406550'	335 00 0 00 000135'	echg.:	skipge	echflg		;echo on?
	406551'	324 17 0 00 405677'		pjrst	echon		;no, turn echo on
	406552'	324 17 0 00 405705'		pjrst	echoff		;yes, turn echo off
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 23
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OUT/SKIP

						subttl	Output -- OUT/SKIP

					;;;	OUT -- output an asciz string, optionally followed by a number
					;	of <CR><LF>.
					;
					;		CALL OUT (str,n)
					;
					;	str is either the address of an asciz string, else the address
					;	of the actual address (indirect bit won't be set).  n is the
					;	number of <CR><LF> to output after the string.
					;
						entry	out
	406553'	57 65 64 00 00 00 		sixbit	/OUT/
	406554'	201 12 1 16 000000 	out:	movei	p1,@0(arg)	;address of string to output
	406555'	322 12 0 00 405254'		jumpe	p1,cpopj
	406556'	200 01 0 12 000000 		move	t1,(p1)		;get first word of string
	406557'	607 01 0 00 777777 		tlnn	t1,777777
	406560'	200 12 0 12 000000 		move	p1,(p1)		;was really the address of an address
	406561'	260 17 0 00 406710'		pushj	p,ostr.

	406562'	200 01 1 16 000001 		move	t1,@1(arg)	;get number of <CR><LF>s to output
	406563'	254 00 0 00 406566'		jrst	skip.1		;go do it

						entry	skip		;output specified number of <CR><LF>s
	406564'	63 53 51 60 00 00 		sixbit	/SKIP/
	406565'	200 01 1 16 000000 	skip:	move	t1,@0(arg)	;get number of <CR><LF>s to output

	406566'	361 01 0 00 405254'	skip.1:	sojl	t1,cpopj
						ochr	cr^
						  xlist
						  list
						^
						ochr	lf^
						  xlist
						  list
						^
	406573'	254 00 0 00 406566'		jrst	skip.1
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 24
WARMAC	MAC	 7-Jul-;2 18:15		Output -- TAB/SPACES/OSPC./OCRL./CRLF

						subttl	Output -- TAB/SPACES/OSPC./OCRL./CRLF

					;;;	TAB -- absolute tab to column
					;
					;		CALL TAB (col)
					;
						entry	tab
	406574'	64 41 42 00 00 00 		sixbit	/TAB/
	406575'	200 05 1 16 000000 	tab:	move	x1,@0(arg)
	406576'	274 05 0 00 000000#	tab.:	sub	x1,hcpos
	406577'	201 11 0 00 000040 		movei	c," "
	406600'	363 05 0 00 405254'		sojle	x1,cpopj
	406601'	260 17 0 00 406077'		pushj	p,ochr.
	406602'	254 00 0 00 406600'		jrst	.-2


					;;;	SPACES -- relative tab (output n spaces)
					;
					;		CALL SPACES (n)
					;
						entry	spaces
	406603'	63 60 41 43 45 63 		sixbit	/SPACES/
	406604'	200 05 1 16 000000 	spaces:	move	x1,@0(arg)
	406605'	201 11 0 00 000040 	spcs.:	movei	c,sp
	406606'	361 05 0 00 405254'		sojl	x1,cpopj
	406607'	260 17 0 00 406077'		pushj	p,ochr.
	406610'	254 00 0 00 406606'		jrst	.-2



					;;;	SPACE/OSPC. -- Output a space.
					;
					;		PUSHJ	P,OSPC.
					;
						entry	space
	406611'	63 60 41 43 45 00 		sixbit	/SPACE/
	406612'				space:
	406612'	201 11 0 00 000040 	ospc.:	movei	c,sp		;get a space
	406613'	260 17 0 00 406077'		pushj	p,ochr.		;and output it
	406614'	263 17 0 00 000000 		popj	p,


					;;;	OCRL./CRLF -- Output <CR><LF> if not at left margin or previous
					;	output line wasn't blank.
					;
					;		PUSHJ	P,OCRL.
					;
						entry	crlf
	406615'	43 62 54 46 00 00 		sixbit	/CRLF/
	406616'				crlf:
	406616'	333 00 0 00 000000#	ocrl.:	skiple	blank		;any blank lines yet?
	406617'	332 00 0 00 000000#		skipe	hcpos		;and at left margin?
	406620'	254 00 0 00 406622'		jrst	.+2
	406621'	263 17 0 00 000000 		popj	p,		;yes, don't output another blank line

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 24-1
WARMAC	MAC	 7-Jul-;2 18:15		Output -- TAB/SPACES/OSPC./OCRL./CRLF

	406622'	201 11 0 00 000015 		movei	c,cr
	406623'	260 17 0 00 406077'		pushj	p,ochr.
	406624'	201 11 0 00 000012 		movei	c,lf		;get a line feed
	406625'	260 17 0 00 406077'		pushj	p,ochr.
	406626'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 25
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OUTC/OUT2C/OUTW/OUT2W

						subttl	Output -- OUTC/OUT2C/OUTW/OUT2W

						entry	outc		;output a single, left justified character
	406627'	57 65 64 43 00 00 		sixbit	/OUTC/
	406630'	135 11 0 00 415160'	outc:	ldb	c,[point 7,@0(arg),6]
	406631'	260 17 0 00 406077'		pushj	p,ochr.
	406632'	263 17 0 00 000000 		popj	p,


						entry	out2c		;output two left justified characters
	406633'	57 65 64 22 43 00 		sixbit	/OUT2C/
	406634'	135 11 0 00 415160'	out2c:	ldb	c,[point 7,@0(arg),6]
	406635'	260 17 0 00 406077'		pushj	p,ochr.
	406636'	135 11 0 00 415161'		ldb	c,[point 7,@0(arg),13]
	406637'	260 17 0 00 406077'		pushj	p,ochr.
	406640'	263 17 0 00 000000 		popj	p,


						entry	outw		;output a single left justified word
	406641'	57 65 64 67 00 00 		sixbit	/OUTW/
	406642'	200 01 1 16 000000 	outw:	move	t1,@0(arg)	;get word
	406643'	202 01 0 00 001767'		movem	t1,tmp+0
	406644'	402 00 0 00 001770'		setzm	tmp+1
	406645'	201 12 0 00 001767'		movei	p1,tmp
	406646'	260 17 0 00 406710'		pushj	p,ostr.
	406647'	263 17 0 00 000000 		popj	p,


						entry	out2w		;output two words
	406650'	57 65 64 22 67 00 		sixbit	/OUT2W/
	406651'	200 01 1 16 000000 	out2w:	move	t1,@0(arg)	;get first word
	406652'	202 01 0 00 001767'		movem	t1,tmp+0
	406653'	200 01 1 16 000001 		move	t1,@1(arg)	;get second word
	406654'	202 01 0 00 001770'		movem	t1,tmp+1
	406655'	402 00 0 00 001771'		setzm	tmp+2
	406656'	201 12 0 00 001767'		movei	p1,tmp
	406657'	260 17 0 00 406710'		pushj	p,ostr.
	406660'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 26
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OTIM

						subttl	Output -- OTIM

						;Output the time in the format hh:mm:ss
						;
						;	CALL OTIM (TIME)

						entry	otim
	406661'	57 64 51 55 00 00 		sixbit	/OTIM/
	406662'	200 05 1 16 000000 	otim:	move	x1,@0(arg)
	406663'	230 05 0 00 415162'		idiv	x1,[^D1000*^D60*^D60]
	406664'	231 06 0 00 165140 		idivi	x2,^D1000*^D60
	406665'	231 07 0 00 001750 		idivi	x3,^D1000
	406666'	201 01 0 05 000000 		movei	t1,(x1)
	406667'	260 17 0 00 406702'		pushj	p,o2d		;output the hours
						ochr	":"^
						  xlist
						  list
						^
	406672'	201 01 0 06 000000 		movei	t1,(x2)
	406673'	260 17 0 00 406702'		pushj	p,o2d		;output the minutes
						ochr	":"^
						  xlist
						  list
						^
	406676'	201 01 0 07 000000 		movei	t1,(x3)
	406677'	260 17 0 00 406702'		pushj	p,o2d		;output the seconds
	406700'	263 17 0 00 000000 		popj	p,

	406701'	57 22 44 00 00 00 		sixbit	/O2D/
	406702'	231 01 0 00 000012 	o2d:	idivi	t1,^D10
	406703'	201 11 0 01 000060 		movei	c,"0"(t1)	;output first digit
	406704'	260 17 0 00 406077'		pushj	p,ochr.
	406705'	201 11 0 02 000060 		movei	c,"0"(t2)	;output second digit
	406706'	260 17 0 00 406077'		pushj	p,ochr.
	406707'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 27
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OSTR./OSTB./O2DG./O2DB./OSIX.

						subttl	Output -- OSTR./OSTB./O2DG./O2DB./OSIX.

					;;;	OSTR. -- Output the asciz string pointed to by P1.
					;
	406710'	505 12 0 00 440700 	ostr.:	hrli	p1,(point 7)
	406711'	134 11 0 00 000012 	ostr.x:	ildb	c,p1
	406712'	322 11 0 00 405254'		jumpe	c,cpopj
	406713'	260 17 0 00 406077'		pushj	p,ochr.
	406714'	254 00 0 00 406711'		jrst	ostr.x


					;;;	OSTB. -- Output the string pointed to by P1.  Either a null or
					;	blank terminates the string.  Output no more than 10 characters.
					;
	406715'	505 12 0 00 440700 	ostbx.:	hrli	p1,(point 7,0)
						save	<x1,x2>^
						  xlist
						  list
						^
	406720'	201 05 0 00 000012 		movei	x1,^d10
	406721'	474 06 0 00 000000 		seto	x2,		; pad out to 10 columns
	406722'	254 00 0 00 406730'		jrst	ostb.1

	406723'	505 12 0 00 440700 	ostb.:	hrli	p1,(point 7)
	406724'				ostb.x:	save	<x1,x2>^
						  xlist
						  list
						^
	406726'	400 06 0 00 000000 		setz	x2,
	406727'	201 05 0 00 000012 		movei	x1,^D10

	406730'	134 11 0 00 000012 	ostb.1:	ildb	c,p1
	406731'	302 11 0 00 000000 		caie	c,0
	406732'	306 11 0 00 000040 		cain	c," "
	406733'	254 00 0 00 406736'		jrst	ostb.2
	406734'	260 17 0 00 406077'		pushj	p,ochr.
	406735'	367 05 0 00 406730'		sojg	x1,ostb.1

	406736'				ostb.2:
	406736'	322 06 0 00 406743'		jumpe	x2,ostb.4
	406737'	363 05 0 00 406743'	ostb.3:	sojle	x1,ostb.4
	406740'	201 11 0 00 000040 		movei	c," "
	406741'	260 17 0 00 406077'		pushj	p,ochr.
	406742'	254 00 0 00 406737'		jrst	ostb.3
	406743'				ostb.4:
						restor	<x2,x1>^
						  xlist
						  list
						^
	406751'	263 17 0 00 000000 		popj	p,


					;;;	O2DG. -- output the 2 digit decimal number from X1.
					;
					;		MOVE	X1,number
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 27-1
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OSTR./OSTB./O2DG./O2DB./OSIX.

					;		PUSHJ	P,O2DG.
					;
	406752'	57 22 44 47 16 00 		sixbit	/O2DG./
	406753'				o2dg.:	save	<x1,x2>^
						  xlist
						  list
						^
	406755'	231 05 0 00 000144 		idivi	x1,^D100	;ignore any overflow digits
	406756'	201 05 0 06 000000 		movei	x1,(x2)
	406757'	231 05 0 00 000012 		idivi	x1,^D10		;split into constituent digits
	406760'	201 11 0 05 000060 		movei	c,"0"(x1)	;get tens
	406761'	260 17 0 00 406077'		pushj	p,ochr.
	406762'	201 11 0 06 000060 		movei	c,"0"(x2)	;get ones
	406763'	260 17 0 00 406077'		pushj	p,ochr.
						restor	<x2,x1>^
						  xlist
						  list
						^
	406772'	263 17 0 00 000000 		popj	p,


					;;;	O2DB. -- Output a 2 digit number, suppress leading 0.
					;
	406773'				o2db.:	save	<x1,x2>^
						  xlist
						  list
						^
	406775'	231 05 0 00 000012 		idivi	x1,^D10
	406776'	201 11 0 05 000060 		movei	c,"0"(x1)
	406777'	306 11 0 00 000060 		cain	c,"0"
	407000'	201 11 0 00 000040 		movei	c," "
	407001'	260 17 0 00 406077'		pushj	p,ochr.
	407002'	201 11 0 06 000060 		movei	c,"0"(x2)
	407003'	260 17 0 00 406077'		pushj	p,ochr.
						restor	<x2,x1>^
						  xlist
						  list
						^
	407012'	263 17 0 00 000000 		popj	p,


					;;;	OSIX. -- output the sixbit word from X1 using the field width
					;	in X2.
					;
					;		MOVE	X1,[sixbit /str/]
					;		PUSHJ	P,OSIX.
					;
	407013'	57 63 51 70 16 00 		sixbit	/OSIX./
	407014'				osix.:	save	<x1,c+1>^
						  xlist
						  list
						^
	407016'	200 12 0 00 000005 		move	c+1,x1		;sixbit word to output
	407017'	201 05 0 00 000006 		movei	x1,6		;output exactly 6 characters
	407020'	400 11 0 00 000000 	osix.1:	setz	c,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 27-2
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OSTR./OSTB./O2DG./O2DB./OSIX.

	407021'	246 11 0 00 000006 		lshc	c,6		;get character
	407022'	271 11 0 00 000040 		addi	c,040		;change it to ascii
	407023'	260 17 0 00 406077'		pushj	p,ochr.
	407024'	367 05 0 00 407020'		sojg	x1,osix.1
						restor	<c+1,x1>^
						  xlist
						  list
						^
	407033'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 28
WARMAC	MAC	 7-Jul-;2 18:15		Output -- ODEC./OOCT.

						subttl	Output -- ODEC./OOCT.

					;;;	ODEC. -- output the decimal number from X1 using the field width
					;	in X2.
					;
					;		MOVE	X1,number
					;		MOVEI	X2,field width
					;		PUSHJ	P,ODEC.
					;
	407034'	57 44 45 43 16 00 		sixbit	/ODEC./
	407035'				odec.:	save	<x3>^
						  xlist
						  list
						^
	407036'	201 07 0 00 000012 		movei	x3,^D10		;radix 10
	407037'	260 17 0 00 407062'		pushj	p,onum.		;output the number
						restor	<x3>^
						  xlist
						  list
						^
	407043'	263 17 0 00 000000 		popj	p,


					;;;	OOCT. -- output the octal number from X1 using the field width in
					;	X2.
					;
					;		MOVE	X1,number
					;		MOVEI	X2,field width
					;		PUSHJ	P,OOCT.
					;
	407044'	57 57 43 64 16 00 		sixbit	/OOCT./
	407045'				ooct.:	save	<x3>^
						  xlist
						  list
						^
	407046'	201 07 0 00 000010 		movei	x3,^D8		;radix 8
	407047'	260 17 0 00 407062'		pushj	p,onum.		;output the number
						restor	<x3>^
						  xlist
						  list
						^
	407053'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 29
WARMAC	MAC	 7-Jul-;2 18:15		Output -- ONUM./OSN1./OSN2./OSN3.

						subttl	Output -- ONUM./OSN1./OSN2./OSN3.

					;;;	In the following output routines, the field width has the
					;	following meanings:
					;
					;	w > 0 --> pad out to field width (blanks before numbers and after
					;		  after strings) or truncate if neccessary.
					;	w = 0 --> use free format (take up just as much space as needed).
					;	w < 0 --> pad out to field width, expand field if neccessary.
					;
					;	The actual field width used is always returned in the same AC
					;	that the original field width was passed in (X2).


					;;;	ONUM. -- output the number from X1, using the field width in X2
					;	and the radix in X3.
					;
					;		MOVE	X1,number
					;		MOVEI	X2,width
					;		MOVEI	X3,radix
					;		PUSHJ	P,ONUM.
					;
					;	entry ONUM. -- Output sign if negative.
					;	entry OSN1. -- Output sign if non-zero.
					;	entry OSN2. -- Output sign always.  0 counts as positive.
					;	entry OSN3. -- Output sign always.  0 counts as negative.
					;
	407054'	322 05 0 00 407062'	osn1.:	jumpe	x1,onum.	;-1 --> -1 ; 0 --> 0 ; 1 --> +1
	407055'	325 05 0 00 407057'	osn2.:	jumpge	x1,.+2		;-1 --> -1 ; 0 --> +0 ; 1 --> +1
	407056'	323 05 0 00 407060'	osn3.:	jumple	x1,.+2		;-1 --> -1 ; 0 --> -0 ; 1 --> +1
	407057'	334 02 0 00 415221'		skipa	t2,["+"]
	407060'	201 02 0 00 000055 		movei	t2,"-"
	407061'	254 00 0 00 407065'		jrst	onum.1
	407062'	321 05 0 00 407064'	onum.:	jumpl	x1,.+2		;negative; output sign
	407063'	634 02 0 00 000002 		tdza	t2,t2
	407064'	201 02 0 00 000055 		movei	t2,"-"

	407065'				onum.1:	save	<x1,x4>^
						  xlist
						  list
						^
	407067'	214 10 0 00 000006 		movm	x4,x2		;get abs(field width)
	407070'	211 10 0 10 000000 		movni	x4,(x4)
	407071'	515 10 0 10 000000 		hrlzi	x4,(x4)		;-width,,0

						save	<[-1]>		^; save sentinel

						  xlist
						  list
	

	407073'	214 01 0 00 000005 		movm	t1,x1		;get number to output
	407074'	201 05 0 02 000000 		movei	x1,(t2)		;remember sign
	407075'	322 05 0 00 407100'		jumpe	x1,onum.2	;don't output sign
	407076'	253 10 0 00 407100'		aobjn	x4,.+2		;more room in field
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 29-1
WARMAC	MAC	 7-Jul-;2 18:15		Output -- ONUM./OSN1./OSN2./OSN3.

	407077'	327 06 0 00 407111'		jumpg	x2,onum.4	;field is full

	407100'	231 01 0 07 000000 	onum.2:	idivi	t1,(x3)		;get least significant digit
						save	<t2>		^; save it

						  xlist
						  list
	
	407102'	322 01 0 00 407107'		jumpe	t1,onum.3	;no more digits to strip off
	407103'	253 10 0 00 407100'		aobjn	x4,onum.2	;more room in field
	407104'	323 06 0 00 407100'		jumple	x2,onum.2	;free format or expand field if necessary
	407105'	254 00 0 00 407111'		jrst	onum.4		;overflow

	407106'	260 17 0 00 406612'		pushj	p,ospc.		;pad in leading space
	407107'	253 10 0 00 407106'	onum.3:	aobjn	x4,.-1		;field not full yet
	407110'	634 06 0 00 000006 		tdza	x2,x2		;field didn't overflow
	407111'	474 06 0 00 000000 	onum.4:	seto	x2,		;field did overflow

	407112'	332 11 0 00 000005 		skipe	c,x1
	407113'	260 17 0 00 406077'		pushj	p,ochr.		;output sign

	407114'				onum.5:	restor	<c>		^; get digit

						  xlist
						  list
	
	407117'	321 11 0 00 407125'		jumpl	c,onum.6	;-1 signals end of number
	407120'	271 11 0 00 000060 		addi	c,"0"		;change to character code
	407121'	322 06 0 00 407123'		jumpe	x2,.+2		;field overflowed?
	407122'	201 11 0 00 000052 		movei	c,"*"		;yes, output stars instead
	407123'	260 17 0 00 406077'		pushj	p,ochr.		;output character
	407124'	254 00 0 00 407114'		jrst	onum.5		;loop for remaining digits

	407125'	201 06 0 10 000000 	onum.6:	movei	x2,(x4)		;get actual field width used
						restor	<x4,x1>^
						  xlist
						  list
						^
	407134'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 30
WARMAC	MAC	 7-Jul-;2 18:15		Output -- ODEC/OSDEC

						subttl	Output -- ODEC/OSDEC

					;;;	ODEC -- Output decimal number (-1, 0, 1)
					;;;	OSDEC -- Output signed decimal number (-1, 0, +1)
					;
					;		CALL ODEC/OSDEC (n,w)
					;
					;	n is number to output
					;	w is field width
					;
						entry	odec,osdec	;output decimal number
	407135'	334 01 0 00 415234'	osdec:	skipa	t1,[osn1.]
	407136'	201 01 0 00 407062'	odec:	movei	t1,onum.
						save	<x1,x2,x3>^
						  xlist
						  list
						^
	407142'	200 05 1 16 000000 		move	x1,@0(arg)	;get number
	407143'	200 06 1 16 000001 		move	x2,@1(arg)	;get field width
	407144'	201 07 0 00 000012 		movei	x3,^D10		;get radix
	407145'	260 17 0 01 000000 		pushj	p,(t1)		;output number
						restor	<x3,x2,x1>^
						  xlist
						  list
						^
	407157'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 31
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OFLT/OSFLT

						subttl	Output -- OFLT/OSFLT

					;;;	OFLT -- Output a fixed point decimal number (-1.0, 0.0, 1.0)
					;;;	OSFLT -- Output a signed fixed point decimal number (-1.0, -0.0, +1.0)
					;	(The sign is fixed at 1 fractional digit.).  Omit the decimal
					;	point and fractional digit if output format is set to short.
					;
					;		CALL OFLT (n,w)
					;
					;	n = number to output
					;	w = field width for integer part
					;
						entry	oflt,osflt
	407160'	337 00 1 16 000000 	osflt:	skipg	@0(arg)		;n > 0?
	407161'	334 01 0 00 415246'		skipa	t1,[osn3.]	;no, output as negative
	407162'	201 01 0 00 407055'		movei	t1,osn2.	;yes, positive, even if integer part is zero
	407163'	254 00 0 00 407165'		jrst	.+2
	407164'	201 01 0 00 407062'	oflt:	movei	t1,onum.
						save	<x1,x2,x3,x4>^
						  xlist
						  list
						^
	407171'	200 05 1 16 000000 		move	x1,@0(arg)	;get number to output
	407172'	231 05 0 00 000012 		idivi	x1,^D10		;split into integer and fraction
	407173'	214 10 0 00 000006 		movm	x4,x2
	407174'	200 06 1 16 000001 		move	x2,@1(arg)	;get field width
	407175'	201 07 0 00 000012 		movei	x3,^D10		;output in decimal
	407176'	260 17 0 01 000000 		pushj	p,(t1)		;output integer part
	407177'	335 00 0 00 000000#		skipge	oflg		;short format?
	407200'	254 00 0 00 407205'		jrst	oflt.1		;yes, truncate
	407201'	201 11 0 00 000056 		movei	c,"."
	407202'	260 17 0 00 406077'		pushj	p,ochr.
	407203'	201 11 0 10 000060 		movei	c,"0"(x4)	;get fractional digit
	407204'	260 17 0 00 406077'		pushj	p,ochr.
	407205'				oflt.1:	restor	<x4,x3,x2,x1>^
						  xlist
						  list
						^
	407221'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 32
WARMAC	MAC	 7-Jul-;2 18:15		Output -- ODISP

						subttl	Output -- ODISP

					;;;	ODISP -- output the symbol for the object whose display code
					;	is disp_code.  Use the long form if LNGBIT is set in OFLG,
					;	else use the short form.  Output a space after the symbol if
					;	space_flag > 0.
					;
					;		CALL ODISP (disp_code,space_flag)
					;
						entry	odisp
	407222'	57 44 51 63 60 00 		sixbit	/ODISP/
	407223'	200 01 1 16 000000 	odisp:	move	t1,@0(arg)	;get display code of object to output
	407224'	335 00 0 00 000001 		skipge	t1		; defensive - watch out for 777777
	407225'	400 01 0 00 000000 		setz	t1,
	407226'	231 01 0 00 000144 		idivi	t1,^D100	;t1 <-- object, t2 <-- index
	407227'	303 01 0 00 000012 		caile	t1,^d10		; defensive - watch out for "cloaked" ships
	407230'	403 01 0 00 000002 		setzb	t1,t2
	407231'	337 00 0 00 000000#		skipg	oflg
	407232'	201 12 1 01 407241'		movei	p1,@shtdsp(t1)	;short format
	407233'	333 00 0 00 000000#		skiple	oflg
	407234'	201 12 1 01 407266'		movei	p1,@lngdsp(t1)	;long format
	407235'	260 17 0 00 406710'		pushj	p,ostr.
	407236'	333 00 1 16 000001 		skiple	@1(arg)
	407237'	260 17 0 00 406612'		pushj	p,ospc.
	407240'	263 17 0 00 000000 		popj	p,

	407241'	000000	415263'		shtdsp:	[asciz	/./]
	407242'	000002	407253'			shtshp-1(t2)		;federation ship
	407243'	000002	407253'			shtshp-1(t2)		;empire ship
	407244'	000000	415264'			[asciz	/<>/]		;fed base
	407245'	000000	415265'			[asciz	/)(/]		;emp base
	407246'	000000	415266'			[asciz	/??/]		;romulan
	407247'	000000	415267'			[asciz	/ @/]		;neutral planet
	407250'	000000	415270'			[asciz	/+@/]		;Federation planet
	407251'	000000	415271'			[asciz	/-@/]		;Empire planet
	407252'	000000	415272'			[asciz	/*/]		;star
	407253'	000000	415273'			[asciz	/BH/]		;black hole

	407254'	114 000 000 000 000 	shtshp:	asciz	/L/
	407255'	116 000 000 000 000 		asciz	/N/
	407256'	123 000 000 000 000 		asciz	/S/
	407257'	126 000 000 000 000 		asciz	/V/
	407260'	131 000 000 000 000 		asciz	/Y/

	407261'	103 000 000 000 000 		asciz	/C/
	407262'	104 000 000 000 000 		asciz	/D/
	407263'	110 000 000 000 000 		asciz	/H/
	407264'	112 000 000 000 000 		asciz	/J/
	407265'	127 000 000 000 000 		asciz	/W/

	407266'	000000	415274'		lngdsp:	[asciz	/Empty Space/]
	407267'	000022	407300'			@lngshp-1(t2)		;federation ship
	407270'	000022	407300'			@lngshp-1(t2)		;empire ship
	407271'	000000	415277'			[asciz	/Fed Base/]
	407272'	000000	415301'			[asciz	/Emp Base/]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 32-1
WARMAC	MAC	 7-Jul-;2 18:15		Output -- ODISP

	407273'	000000	415303'			[asciz	/Romulan/]
	407274'	000000	415305'			[asciz	/Neu planet/]
	407275'	000000	415310'			[asciz	/Fed planet/]
	407276'	000000	415313'			[asciz	/Emp planet/]
	407277'	000000	415316'			[asciz	/Star/]
	407300'	000000	415317'			[asciz	/Black Hole/]

	407301'	000000	415322'		lngshp:	[asciz	/Lexington/]
	407302'	000000	415324'			[asciz	/Nimitz/]
	407303'	000000	415326'			[asciz	/Savannah/]
	407304'	000000	415330'			[asciz	/Vulcan/]
	407305'	000000	415332'			[asciz	/Yorktown/]

	407306'	000000	415334'			[asciz	/Cobra/]
	407307'	000000	415336'			[asciz	/Demon/]
	407310'	000000	415340'			[asciz	/Hawk/]
	407311'	000000	415341'			[asciz	/Jackal/]
	407312'	000000	415343'			[asciz	/Wolf/]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 33
WARMAC	MAC	 7-Jul-;2 18:15		Output -- ODEV

						subttl	Output -- ODEV

					;;;	ODEV -- Output the name of a device.  Use different formats
					;	depending on the value of OFLG (short, medium, or long).
					;
					;		CALL ODEV (dev_num)
					;
						entry	odev
	407313'	57 44 45 66 00 00 		sixbit	/ODEV/
	407314'	200 01 1 16 000000 	odev:	move	t1,@0(arg)	;get device number
	407315'	335 00 0 00 000000#		skipge	oflg
	407316'	201 12 0 01 407324'		movei	p1,shtdev-1(t1) ;short format
	407317'	336 00 0 00 000000#		skipn	oflg
	407320'	200 12 0 01 407335'		move	p1,meddev-1(t1) ;medium format
	407321'	333 00 0 00 000000#		skiple	oflg
	407322'	200 12 0 01 407346'		move	p1,lngdev-1(t1) ;long format
	407323'	260 17 0 00 406710'		pushj	p,ostr.
	407324'	263 17 0 00 000000 		popj	p,

	407325'	123 110 040 000 000 	shtdev:	asciz	/SH /		;deflector shields
	407326'	127 101 040 000 000 		asciz	/WA /		;warp engines
	407327'	111 115 040 000 000 		asciz	/IM /		;impulse engines
	407330'	114 123 040 000 000 		asciz	/LS /		;life support
	407331'	124 117 040 000 000 		asciz	/TO /		;torpedo tubes
	407332'	120 110 040 000 000 		asciz	/PH /		;phasers
	407333'	103 117 040 000 000 		asciz	/CO /		;computer
	407334'	122 101 040 000 000 		asciz	/RA /		;radio
	407335'	124 122 040 000 000 		asciz	/TR /		;tractor beam

	407336'	000000	415344'		meddev:	[asciz	/Shields /]
	407337'	000000	415346'			[asciz	/Warp /]
	407340'	000000	415350'			[asciz	/Impulse /]
	407341'	000000	415352'			[asciz	/Life Sup /]
	407342'	000000	415354'			[asciz	/Torps /]
	407343'	000000	415356'			[asciz	/Phasers /]
	407344'	000000	415360'			[asciz	/Computer /]
	407345'	000000	415362'			[asciz	/Radio /]
	407346'	000000	415364'			[asciz	/Tractor /]

	407347'	000000	415366'		lngdev:	[asciz	/Deflector Shields /]
	407350'	000000	415372'			[asciz	/Warp Engines /]
	407351'	000000	415375'			[asciz	/Impulse Engines /]
	407352'	000000	415401'			[asciz	/Life Support /]
	407353'	000000	415404'			[asciz	/Torpedo Tubes /]
	407354'	000000	415356'			[asciz	/Phasers /]
	407355'	000000	415360'			[asciz	/Computer /]
	407356'	000000	415362'			[asciz	/Radio /]
	407357'	000000	415407'			[asciz	/Tractor Beam /]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 34
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OCOND

						subttl	Output -- OCOND

					;;;	OCOND -- Output condition ([docked +] green, yellow, red)
					;
					;		CALL OCOND (condition)
					;
						entry	OCOND
	407360'	57 43 57 56 44 00 		sixbit	/OCOND/
	407361'	200 01 0 00 000000#	ocond:	move	t1,who		;get player index
	407362'	331 00 0 01 000000#		skipl	docked-1(t1)	;docked?
	407363'	254 00 0 00 407370'		jrst	ocon.1		;no, don't need "Docked+"
	407364'	201 12 0 00 415412'		movei	p1,[asciz /Docked+/]
	407365'	335 00 0 00 000000#		skipge	oflg		;short output format?
	407366'	201 12 0 00 415414'		movei	p1,[asciz /D+/]	;yes, use compressed format
	407367'	260 17 0 00 406710'		pushj	p,ostr.
	407370'	200 01 1 16 000000 	ocon.1:	move	t1,@0(arg)	;get ship condition code
	407371'	200 12 0 01 407375'		move	p1,lngcnd-1(t1)
	407372'	335 00 0 00 000000#		skipge	oflg		;short format?
	407373'	200 12 0 01 407400'		move	p1,shtcnd-1(t1)	;yes, get single character condition code
	407374'	260 17 0 00 406710'		pushj	p,ostr.
	407375'	263 17 0 00 000000 		popj	p,

	407376'	000000	415415'		lngcnd:	[asciz	/Green/]
	407377'	000000	415417'			[asciz	/Yellow/]
	407400'	000000	415421'			[asciz	/Red/]

	407401'	000000	415422'		shtcnd:	[asciz	/G/]
	407402'	000000	415423'			[asciz	/Y/]
	407403'	000000	415424'			[asciz	/R/]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 35
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OSTS./STAT

						subttl	Output -- OSTS./STAT

					;;;	OSTS. -- Output initial gripe line info.
					;
	407404'				osts.:	save	<x1,x2,x3,x4>^
						  xlist
						  list
						^

						ochr	"["^
						  xlist
						  list
						^
						ochr	"V"		^;output version number

						  xlist
						  list
	
	407414'	200 05 0 00 000000#		move	x1,versio	;get version number
	407415'	231 05 0 00 000012 		idivi	x1,^D10
	407416'	201 11 0 05 000060 		movei	c,"0"(x1)	;major version
	407417'	260 17 0 00 406077'		pushj	p,ochr.
	407420'	201 11 0 00 000056 		movei	c,"."
	407421'	260 17 0 00 406077'		pushj	p,ochr.
	407422'	201 11 0 06 000060 		movei	c,"0"(x2)	;minor version
	407423'	260 17 0 00 406077'		pushj	p,ochr.

	407424'	260 17 0 00 406612'		pushj	p,ospc.		;output date
	407425'	260 17 0 00 406612'		pushj	p,ospc.

	407426'	201 05 0 00 001767'		movei	x1,tmp		; get current date
	407427'	047 05 0 00 777657 		calli	x1,-121		; UNDAT. uuo
	407430'	255 00 0 00 000000 		  jfcl
	407431'	260 17 0 00 407502'		pushj	p,xfrtmp
	407432'	260 17 0 00 406612'		pushj	p,ospc.
	407433'	201 05 0 00 001767'		movei	x1,tmp		; get current time
	407434'	047 05 0 00 777660 		calli	x1,-120		; UNTIM. uuo
	407435'	255 00 0 00 000000 		  jfcl
	407436'	260 17 0 00 407502'		pushj	p,xfrtmp
	407437'	260 17 0 00 406612'		pushj	p,ospc.
	407440'	260 17 0 00 406612'		pushj	p,ospc.

	407441'	200 07 0 00 000000#		move	x3,who		;who to output user info for
	407442'	211 10 0 00 777700 		movni	x4,-100		;output all there is
	407443'	332 00 0 00 000000#		skipe	who		;Player in pre-game?
	407444'	254 00 0 00 407447'		jrst	osts.p		;no
	407445'	260 17 0 00 407570'		pushj	p,stat.y	;output rest of gripe info (same as user info)
	407446'	334 00 0 00 000000 		skipa
	407447'	260 17 0 00 407513'	osts.p:	pushj	p,stat.x
	407450'	260 17 0 00 406612'		pushj	p,ospc.
	407451'	200 05 0 00 000000#		move	x1,gameno	; output game #
	407452'	201 06 0 00 000005 		movei	x2,5
	407453'	260 17 0 00 407035'		pushj	p,odec.
	407454'	201 12 0 00 415425'		movei	p1,[asciz / B/]
	407455'	335 00 0 00 000000#		skipge	blhopt		;black holes in this game?
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 35-1
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OSTS./STAT

	407456'	260 17 0 00 406710'		pushj	p,ostr.		;yes, show it
	407457'	201 12 0 00 415426'		movei	p1,[asciz / R/]
	407460'	335 00 0 00 000000#		skipge	romopt		;romulan in this game?
	407461'	260 17 0 00 406710'		pushj	p,ostr.		;yes
						ochr	"]"^
						  xlist
						  list
						^
	407464'	260 17 0 00 406616'		pushj	p,ocrl.
						restor	<x4,x3,x2,x1>^
						  xlist
						  list
						^
	407501'	263 17 0 00 000000 		popj	p,

	407502'	200 05 0 00 415443'	xfrtmp:	move	x1,[point 7,tmp]
	407503'	134 11 0 00 000005 	xfrtm1:	ildb	c,x1
	407504'	336 00 0 00 000011 		skipn	c
	407505'	263 17 0 00 000000 		popj	p,
	407506'	260 17 0 00 406077'		pushj	p,ochr.
	407507'	254 00 0 00 407503'		jrst	xfrtm1


					;;;	STAT -- Output user info.
					;
						entry	stat
	407510'	63 64 41 64 00 00 		sixbit	/STAT/
	407511'	200 07 1 16 000001 	stat:	move	x3,@1(arg)	;get player to output info for
	407512'	210 10 1 16 000000 		movn	x4,@0(arg)	;get number of items to output

					;;;	STAT.X:	In-game output routine for user info.
					;
	407513'	347 10 0 00 407567'	stat.x:	aojg	x4,stat.1	;ship name
	407514'	200 12 0 07 407300'		move	p1,lngshp-1(x3)
	407515'	505 12 0 00 440700 		hrli	p1,(point 7)
	407516'	200 05 0 00 000000#		move	x1,hcpos	;remember where we started from
	407517'	260 17 0 00 406710'		pushj	p,ostr.		;output ship name
	407520'	274 05 0 00 000000#		sub	x1,hcpos	;negative number of spaces used
	407521'	271 05 0 00 000012 		addi	x1,^D10		;number of filler spaces needed
	407522'	260 17 0 00 406605'		pushj	p,spcs.

	407523'	347 10 0 00 407567'		aojg	x4,stat.1	;captain's name
	407524'	260 17 0 00 406612'		pushj	p,ospc.
					;	pushj	p,osix.
	407525'	200 05 0 07 000000#		move	x1,job+KNPLAY*<KNAM1-1>-1(x3) ;first half of name
	407526'	260 17 0 00 407014'		pushj	p,osix.
	407527'	200 05 0 07 000000#		move	x1,job+KNPLAY*<KNAM2-1>-1(x3) ;second half of name
	407530'	260 17 0 00 407014'		pushj	p,osix.

	407531'	347 10 0 00 407567'		aojg	x4,stat.1	;terminal speed
	407532'	260 17 0 00 406612'		pushj	p,ospc.
	407533'	200 05 0 07 000000#		move	x1,job+knplay*<kttysp-1>-1(x3)
	407534'	201 06 0 00 000004 		movei	x2,4
	407535'	260 17 0 00 407035'		pushj	p,odec.

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 35-2
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OSTS./STAT

	407536'	347 10 0 00 407567'		aojg	x4,stat.1	;PPN
	407537'	260 17 0 00 406612'		pushj	p,ospc.
	407540'	260 17 0 00 406612'		pushj	p,ospc.
	407541'	554 05 0 07 000000#		hlrz	x1,job+KNPLAY*<KPPN-1>-1(x3) ;project number
	407542'	211 06 0 00 000006 		movni	x2,6		;field width 6, expandable
	407543'	260 17 0 00 407045'		pushj	p,ooct.
	407544'	201 11 0 00 000054 		movei	c,","
	407545'	260 17 0 00 406077'		pushj	p,ochr.
	407546'	550 05 0 07 000000#		hrrz	x1,job+KNPLAY*<KPPN-1>-1(x3) ;programmer number
	407547'	400 06 0 00 000000 		setz	x2,		;use free format
	407550'	260 17 0 00 407045'		pushj	p,ooct.
	407551'	275 06 0 00 000006 		subi	x2,6
	407552'	254 00 0 00 407554'		jrst	.+2
	407553'	260 17 0 00 406612'		pushj	p,ospc.		;pad in a trailing blank
	407554'	341 06 0 00 407553'		aojl	x2,.-1		;go back for more

	407555'	347 10 0 00 407567'		aojg	x4,stat.1	;TTY number
	407556'	260 17 0 00 406612'		pushj	p,ospc.
	407557'	200 05 0 07 000000#		move	x1,job+KNPLAY*<KTTYN-1>-1(x3) ;TTY number
	407560'	260 17 0 00 407014'		pushj	p,osix.		; output in sixbit!

	407561'	347 10 0 00 407567'		aojg	x4,stat.1	;job number
	407562'	260 17 0 00 406612'		pushj	p,ospc.
	407563'	260 17 0 00 406612'		pushj	p,ospc.
	407564'	200 05 0 07 000000#		move	x1,job+KNPLAY*<KJOB-1>-1(x3) ;job number
	407565'	201 06 0 00 000003 		movei	x2,3		;field width of 3
	407566'	260 17 0 00 407035'		pushj	p,odec.

	407567'	263 17 0 00 000000 	stat.1:	popj	p,

					;;;	STAT.Y:	For use in Pre-game gripes only.
					;
	407570'	347 10 0 00 407644'	stat.y:	aojg	x4,stat.2	;ship name
	407571'	201 12 0 00 415444'		movei	p1,[asciz /Pre-game/]
	407572'	505 12 0 00 440700 		hrli	p1,(point 7)
	407573'	200 05 0 00 000000#		move	x1,hcpos	;remember where we started from
	407574'	260 17 0 00 406710'		pushj	p,ostr.		;output ship name
	407575'	274 05 0 00 000000#		sub	x1,hcpos	;negative number of spaces used
	407576'	271 05 0 00 000012 		addi	x1,^D10		;number of filler spaces needed
	407577'	260 17 0 00 406605'		pushj	p,spcs.

	407600'	347 10 0 00 407644'		aojg	x4,stat.2	;captain's name
	407601'	260 17 0 00 406612'		pushj	p,ospc.
	407602'	200 05 0 00 000000#		move	x1,nam1		;first half of name
	407603'	260 17 0 00 407014'		pushj	p,osix.
	407604'	200 05 0 00 000000#		move	x1,nam2		;second half of name
	407605'	260 17 0 00 407014'		pushj	p,osix.

	407606'	347 10 0 00 407644'		aojg	x4,stat.2	;terminal speed
	407607'	260 17 0 00 406612'		pushj	p,ospc.
	407610'	200 05 0 00 000000#		move	x1,ttyspd	;TTY speed
	407611'	201 06 0 00 000004 		movei	x2,4		;field width of 4
	407612'	260 17 0 00 407035'		pushj	p,odec.

	407613'	347 10 0 00 407644'		aojg	x4,stat.2	;PPN
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 35-3
WARMAC	MAC	 7-Jul-;2 18:15		Output -- OSTS./STAT

	407614'	260 17 0 00 406612'		pushj	p,ospc.
	407615'	260 17 0 00 406612'		pushj	p,ospc.
	407616'	554 05 0 00 000000#		hlrz	x1,ppn		;project number
	407617'	211 06 0 00 000006 		movni	x2,6		;field width 6, expandable
	407620'	260 17 0 00 407045'		pushj	p,ooct.
	407621'	201 11 0 00 000054 		movei	c,","
	407622'	260 17 0 00 406077'		pushj	p,ochr.
	407623'	550 05 0 00 000000#		hrrz	x1,ppn		;programmer number
	407624'	400 06 0 00 000000 		setz	x2,		;use free format
	407625'	260 17 0 00 407045'		pushj	p,ooct.
	407626'	275 06 0 00 000006 		subi	x2,6
	407627'	254 00 0 00 407631'		jrst	.+2
	407630'	260 17 0 00 406612'		pushj	p,ospc.		;pad in a trailing blank
	407631'	341 06 0 00 407630'		aojl	x2,.-1		;go back for more

	407632'	347 10 0 00 407644'		aojg	x4,stat.2	;TTY number
	407633'	260 17 0 00 406612'		pushj	p,ospc.
	407634'	200 05 0 00 000000#		move	x1,ttynum	;TTY number
	407635'	260 17 0 00 407014'		pushj	p,osix.

	407636'	347 10 0 00 407644'		aojg	x4,stat.2	;job number
	407637'	260 17 0 00 406612'		pushj	p,ospc.
	407640'	260 17 0 00 406612'		pushj	p,ospc.
	407641'	200 05 0 00 000000#		move	x1,jobnum	;job number
	407642'	201 06 0 00 000002 		movei	x2,2		;field width of 2
	407643'	260 17 0 00 407035'		pushj	p,odec.

	407644'	263 17 0 00 000000 	stat.2:	popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 36
WARMAC	MAC	 7-Jul-;2 18:15		Random number generator

						subttl	Random number generator


					;;;	SETRAN -- Initialize the random number generator.
					;
						entry	setran
	407645'	63 45 64 62 41 56 		sixbit	/SETRAN/
	407646'	336 01 1 16 000000 	setran:	skipn	t1,@0(arg)	;seed given?
	407647'	047 01 0 00 000023 		mstime	t1,		;no, make one up
	407650'	202 01 0 00 002023'		movem	t1,seed
	407651'	263 17 0 00 000000 		popj	p,


					;;;	IRAN -- Return an integer random integer between 1 and n, inclusive.
					;
					;		ir = IRAN(n)
					;
						entry	iran
	407652'	51 62 41 56 00 00 		sixbit	/IRAN/
	407653'	260 17 0 00 407663'	iran:	pushj	p,ran.		;get "random" number
	407654'	230 00 1 16 000000 		idiv	t0,@0(arg)	;scale it to desired range
	407655'	201 00 0 01 000001 		movei	t0,1(t1)
	407656'	263 17 0 00 000000 		popj	p,


					;;;	RAN -- Return a floating point random number n, where 0 <= n < 1.
					;
					;		r = RAN(dummy)
					;
						entry	ran
	407657'	62 41 56 00 00 00 		sixbit	/RAN/
	407660'	260 17 0 00 407663'	ran:	pushj	p,ran.		;get random number
	407661'	132 00 0 00 000200 		fsc	t0,200		;float it
	407662'	263 17 0 00 000000 		popj	p,


	407663'	200 01 0 00 002023'	ran.:	move	t1,seed		;get current seed
	407664'	606 01 0 00 777777 		trnn	t1,-1		;any low order bits set?
	407665'	541 01 0 00 774677 		hrri	t1,^D260543	;no, set some
	407666'	221 01 0 00 774677 		imuli	t1,^D260543	;a big prime number < 2^18
	407667'	621 01 0 00 400000 		tlz	t1,400000	;make sure it's positive
	407670'	202 01 0 00 002023'		movem	t1,seed
	407671'	200 00 0 00 000001 		move	t0,t1
	407672'	231 00 0 00 000401 		idivi	t0,^D257	;the first prime number > 2^8
	407673'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 37
WARMAC	MAC	 7-Jul-;2 18:15		PWR

						subttl	PWR

					;;;	PWR -- Raise a floating point number to an integer power.
					;
					;		PWR(f,n) = f^n
					;
						entry	pwr
	407674'	60 67 62 00 00 00 		sixbit	/PWR/
	407675'				pwr:	save	<x1,x2,x3>^
						  xlist
						  list
						^
	407700'	200 06 1 16 000000 		move	x2,@0(arg)
	407701'	200 07 1 16 000001 		move	x3,@1(arg)
	407702'	260 17 0 00 407716'		pushj	p,pwr.
	407703'	200 00 0 00 000005 		move	t0,x1
						restor	<x3,x2,x1>^
						  xlist
						  list
						^
	407715'	263 17 0 00 000000 		popj	p,


	407716'				pwr.:	save	<x3,x4>^
						  xlist
						  list
						^
	407720'	301 07 0 00 000005 		cail	x3,5		;small enough to compute without recursing?
	407721'	254 00 0 00 407735'		jrst	pwr.1		;no

	407722'	515 01 0 00 201400 		hrlzi	t1,(1.0)	;X2 ^ 0
	407723'	301 07 0 00 000001 		cail	x3,1
	407724'	200 01 0 00 000006 		move	t1,x2		;X2 ^ 1
	407725'	301 07 0 00 000002 		cail	x3,2
	407726'	164 01 0 00 000006 		fmpr	t1,x2		;X2 ^ 2
	407727'	301 07 0 00 000003 		cail	x3,3
	407730'	164 01 0 00 000006 		fmpr	t1,X2		;X2 ^ 3
	407731'	301 07 0 00 000004 		cail	x3,4
	407732'	164 01 0 00 000006 		fmpr	t1,X2		;X2 ^ 4
	407733'	202 01 0 00 000005 		movem	t1,x1
	407734'	254 00 0 00 407742'		jrst	pwr.2

	407735'	231 07 0 00 000002 	pwr.1:	idivi	x3,2		;split power in half
	407736'	260 17 0 00 407716'		pushj	p,pwr.		;compute the value of the first half
	407737'	164 05 0 00 000005 		fmpr	x1,x1		;compute the value of the two halves combined
	407740'	322 10 0 00 407742'		jumpe	x4,pwr.2	;did the original power divide evenly?
	407741'	164 05 0 00 000006 		fmpr	x1,x2		;no, add in one more

	407742'				pwr.2:	restor	<x4,x3>^
						  xlist
						  list
						^
	407750'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 38
WARMAC	MAC	 7-Jul-;2 18:15		SCAN -- SETSCN

						subttl	SCAN -- SETSCN

						entry	setscn
	407751'	63 45 64 63 43 56 		sixbit	/SETSCN/
	407752'	200 05 1 16 000000 	setscn:	move	x1,@0(arg)	;Hmin
	407753'	202 05 0 00 000000#		movem	x1,Hmin
	407754'	200 06 1 16 000002 		move	x2,@2(arg)	;Vmin
	407755'	202 06 0 00 000000#		movem	x2,Vmin
	407756'	200 07 1 16 000003 		move	x3,@3(arg)	;Vmax
	407757'	202 07 0 00 000000#		movem	x3,Vmax
	407760'	275 07 0 06 777777 		subi	x3,-1(x2)	;dV
	407761'	202 07 0 00 000000#		movem	x3,dV
	407762'	200 10 1 16 000001 		move	x4,@1(arg)	;Hmax
	407763'	202 10 0 00 000000#		movem	x4,Hmax
	407764'	275 10 0 05 777777 		subi	x4,-1(x1)	;dH
	407765'	202 10 0 00 000000#		movem	x4,dH

	407766'	201 12 0 06 777777 		movei	p1,-1(x2)
	407767'	221 12 0 00 000031 		imuli	p1,ksid
	407770'	201 01 0 05 777777 		movei	t1,-1(x1)
	407771'	231 01 0 00 000003 		idivi	t1,3
	407772'	271 12 0 01 000000 		addi	p1,(t1)
	407773'	270 12 0 02 405263'		add	p1,b12tbl-1(t2)

	407774'	200 05 0 00 000012 		move	x1,p1
	407775'	200 13 0 00 415465'		move	p2,[point 7,screen]
	407776'	200 06 0 00 000013 		move	x2,p2
	407777'	254 00 0 00 410005'		jrst	sets.2

	410000'	271 05 0 00 000031 	sets.1:	addi	x1,ksid
	410001'	200 12 0 00 000005 		move	p1,x1
	410002'	271 06 0 00 000011 		addi	x2,^D9
	410003'	200 13 0 00 000006 		move	p2,x2
	410004'	200 10 0 00 000000#		move	x4,dH

	410005'	134 01 0 00 000012 	sets.2:	ildb	t1,p1		;get object code from board
	410006'	306 01 0 00 007777 		cain	t1,7777		;cloaked ship?
	410007'	400 01 0 00 000000 		setz	t1,		;yes, show empty space
	410010'	231 01 0 00 000144 		idivi	t1,^D100	;get object code and index
	410011'	256 00 0 01 410023'		xct	objtbl(t1)	;get characters for object
	410012'	331 00 0 00 000000#		skipl	scnflg		;short scans omit the first char of pair
	410013'	136 01 0 00 000013 		idpb	t1,p2		;save them in temporary screen buffer
	410014'	136 02 0 00 000013 		idpb	t2,p2
	410015'	367 10 0 00 410005'		sojg	x4,sets.2	;finish remaining columns on row
	410016'	400 01 0 00 000000 		setz	t1,
	410017'	136 01 0 00 000013 		idpb	t1,p2		;terminate row with null byte
	410020'	367 07 0 00 410000'		sojg	x3,sets.1	;finish remaining rows

	410021'	263 17 0 00 000000 		popj	p,


	410022'	120 01 0 00 415466'		dmove	t1,[exp " ","!"] ;-1 = warning symbol
	410023'	120 01 0 00 415470'	objtbl:	dmove	t1,[exp " ","."] ; 0 = nothing
	410024'	260 17 0 00 410036'		pushj	p,getshp	 ; 1 = fed ship
	410025'	260 17 0 00 410036'		pushj	p,getshp	 ; 2 = emp ship
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 38-1
WARMAC	MAC	 7-Jul-;2 18:15		SCAN -- SETSCN

	410026'	120 01 0 00 415472'		dmove	t1,[exp "<",">"] ; 3 = fed base
	410027'	120 01 0 00 415474'		dmove	t1,[exp ")","("] ; 4 = emp base
	410030'	120 01 0 00 415476'		dmove	t1,[exp "?","?"] ; 5 = romulan
	410031'	120 01 0 00 415500'		dmove	t1,[exp " ","@"] ; 6 = neutral planet
	410032'	120 01 0 00 415501'		dmove	t1,[exp "@","F"] ; 7 = fed planet
	410033'	120 01 0 00 415503'		dmove	t1,[exp "@","E"] ; 8 = emp planet
	410034'	120 01 0 00 415505'		dmove	t1,[exp " ","*"] ; 9 = star
	410035'	120 01 0 00 415507'		dmove	t1,[exp " "," "] ; 10 = black hole

	410036'	270 02 0 00 415511'	getshp:	add	t2,[point 7,shtshp-1,6]
	410037'	201 01 0 00 000040 		movei	t1," "
	410040'	135 02 0 00 000002 		ldb	t2,t2
	410041'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 39
WARMAC	MAC	 7-Jul-;2 18:15		SCAN -- MARK

						subttl	SCAN -- MARK

						entry	mark
	410042'	55 41 62 53 00 00 		sixbit	/MARK/
	410043'	200 05 1 16 000001 	mark:	move	x1,@1(arg)	;horizontal center
	410044'	200 06 1 16 000002 		move	x2,@2(arg)	;radius
	410045'	200 01 0 00 000000#		move	t1,Hmin
	410046'	200 02 0 00 000000#		move	t2,Hmax
	410047'	260 17 0 00 410125'		pushj	p,reloc.
	410050'	323 06 0 00 405254'		jumple	x2,cpopj
	410051'	120 07 0 00 000005 		dmove	x3,x1		;X3 = Hf, X4 = dH

	410052'	200 05 1 16 000000 		move	x1,@0(arg)	;vertical center
	410053'	200 06 1 16 000002 		move	x2,@2(arg)
	410054'	200 01 0 00 000000#		move	t1,Vmin
	410055'	200 02 0 00 000000#		move	t2,Vmax
	410056'	260 17 0 00 410125'		pushj	p,reloc.	;X1 = Vf, X2 = dV
	410057'	323 06 0 00 405254'		jumple	x2,cpopj

	410060'	201 12 0 05 777777 		movei	p1,-1(x1)
	410061'	221 12 0 00 000031 		imuli	p1,ksid
	410062'	201 01 0 07 777777 		movei	t1,-1(x3)
	410063'	231 01 0 00 000003 		idivi	t1,3
	410064'	271 12 0 01 000000 		addi	p1,(t1)
	410065'	270 12 0 02 405263'		add	p1,b12tbl-1(t2)

	410066'	201 13 0 05 000000 		movei	p2,(x1)
	410067'	274 13 0 00 000000#		sub	p2,Vmin
	410070'	221 13 0 00 000011 		imuli	p2,^D9
	410071'	201 01 0 07 000000 		movei	t1,(x3)
	410072'	274 01 0 00 000000#		sub	t1,Hmin
	410073'	331 00 0 00 000000#		skipl	scnflg		;short scans are only half width
	410074'	271 01 0 01 000000 		addi	t1,(t1)
	410075'	231 01 0 00 000005 		idivi	t1,5
	410076'	271 13 0 01 000000 		addi	p2,(t1)
	410077'	270 13 0 02 405255'		add	p2,b7tbl-1(t2)

	410100'	200 05 0 00 000012 		move	x1,p1		;pointer to board
	410101'	200 07 0 00 000013 		move	x3,p2		;pointer to screen buffer
	410102'	201 03 0 10 000000 		movei	t3,(x4)		;distance to scan accross
	410103'	254 00 0 00 410111'		jrst	mark.2

	410104'	271 05 0 00 000031 	mark.1:	addi	x1,ksid		;next row of board
	410105'	200 12 0 00 000005 		move	p1,x1
	410106'	271 07 0 00 000011 		addi	x3,^D9		;next row of screen buffer
	410107'	200 13 0 00 000007 		move	p2,x3
	410110'	201 03 0 10 000000 		movei	t3,(x4)

	410111'	134 01 0 00 000012 	mark.2:	ildb	t1,p1		;get object code from board
	410112'	302 01 0 00 000000 		caie	t1,0		;empty space?
	410113'	306 01 0 00 007777 		cain	t1,7777	;or cloaked ship?
	410114'	334 01 0 00 415222'		skipa	t1,[-1]		;yes, get index to warning symbol
	410115'	231 01 0 00 000144 		idivi	t1,^D100
	410116'	256 00 0 01 410023'		xct	objtbl(t1)	;get code for object at that location
	410117'	331 00 0 00 000000#		skipl	scnflg		;short scans omit first char of pair
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 39-1
WARMAC	MAC	 7-Jul-;2 18:15		SCAN -- MARK

	410120'	136 01 0 00 000013 		idpb	t1,p2
	410121'	136 02 0 00 000013 		idpb	t2,p2
	410122'	367 03 0 00 410111'		sojg	t3,mark.2	;flag remaining columns
	410123'	367 06 0 00 410104'		sojg	x2,mark.1	;flag remaining rows
	410124'	263 17 0 00 000000 		popj	p,


					;	Input
					;	  X1: center
					;	  X2: radius
					;	  T1: min
					;	  T2: max
					;	Output
					;	  X1: first
					;	  X2: distance
					;
	410125'	201 03 0 05 000000 	reloc.:	movei	t3,(x1)
	410126'	271 03 0 06 000000 		addi	t3,(x2)
	410127'	303 03 0 02 000000 		caile	t3,(t2)
	410130'	201 03 0 02 000000 		movei	t3,(t2)
	410131'	275 05 0 06 000000 		subi	x1,(x2)
	410132'	305 05 0 01 000000 		caige	x1,(t1)
	410133'	201 05 0 01 000000 		movei	x1,(t1)
	410134'	275 03 0 05 000000 		subi	t3,(x1)
	410135'	571 06 0 03 000001 		hrrei	x2,1(t3)
	410136'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 40
WARMAC	MAC	 7-Jul-;2 18:15		SCAN -- SHWSCN

						subttl	SCAN -- SHWSCN

						entry	shwscn
	410137'	63 50 67 63 43 56 		sixbit	/SHWSCN/
	410140'	260 17 0 00 406616'	shwscn:	pushj	p,ocrl.
	410141'	260 17 0 00 410170'		pushj	p,labl.		;label horizontal sectors
	410142'	200 05 0 00 000000#		move	x1,Vmax		;first row to display
	410143'	200 06 0 00 000000#		move	x2,dV
	410144'	221 06 0 00 000011 		imuli	x2,^D9
	410145'	271 06 0 00 000000#		addi	x2,screen-^D9	;pointer to string for row
	410146'	254 00 0 00 410153'		jrst	shws.2


	410147'	275 05 0 00 000001 	shws.1:	subi	x1,1		;next row
	410150'	315 05 0 00 000000#		camge	x1,Vmin
	410151'	254 00 0 00 410166'		jrst	shws.3		;done
	410152'	275 06 0 00 000011 		subi	x2,^D9
	410153'	260 17 0 00 406773'	shws.2:	pushj	p,o2db.		;output row number
	410154'	260 17 0 00 406612'		pushj	p,ospc.
	410155'	201 12 0 06 000000 		movei	p1,(x2)
	410156'	260 17 0 00 406710'		pushj	p,ostr.		;display row
	410157'	260 17 0 00 406612'		pushj	p,ospc.
	410160'	260 17 0 00 406773'		pushj	p,o2db.
	410161'	260 17 0 00 406616'		pushj	p,ocrl.
	410162'	336 00 0 00 000000#		skipn	ccflg		;^C during output?
	410163'	254 00 0 00 410147'		jrst	shws.1		;no, continue scan output
	410164'	402 00 0 00 000000#		setzm	ccflg		;yes, clear it
	410165'	263 17 0 00 000000 		popj	p,		;and quit

	410166'	260 17 0 00 410170'	shws.3:	pushj	p,labl.
	410167'	263 17 0 00 000000 		popj	p,


	410170'				labl.:	save	<x1>^
						  xlist
						  list
						^
	410171'	260 17 0 00 406612'		pushj	p,ospc.
	410172'	200 05 0 00 000000#		move	x1,Hmin
	410173'	335 00 0 00 000000#		skipge	scnflg		;short scan format?
	410174'	271 05 0 00 000001 		addi	x1,1		;yes, make numbers line up over columns
	410175'	260 17 0 00 406612'		pushj	p,ospc.
	410176'	260 17 0 00 406612'		pushj	p,ospc.
	410177'	254 00 0 00 410203'		jrst	labl.2

	410200'	260 17 0 00 406612'	labl.1:	pushj	p,ospc.
	410201'	331 00 0 00 000000#		skipl	scnflg		;short scan?
	410202'	260 17 0 00 406612'		pushj	p,ospc.		;no, output 2 spaces between column numbers
	410203'	260 17 0 00 406773'	labl.2:	pushj	p,o2db.
	410204'	271 05 0 00 000002 		addi	x1,2		;label every second column
	410205'	335 00 0 00 000000#		skipge	scnflg
	410206'	271 05 0 00 000001 		addi	x1,1		;short scans label every third column
	410207'	317 05 0 00 000000#		camg	x1,Hmax
	410210'	254 00 0 00 410200'		jrst	labl.1
	410211'	260 17 0 00 406616'		pushj	p,ocrl.
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 40-1
WARMAC	MAC	 7-Jul-;2 18:15		SCAN -- SHWSCN

						restor	<x1>^
						  xlist
						  list
						^
	410215'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 41
WARMAC	MAC	 7-Jul-;2 18:15		Qmanager -- SETQH/SEQTM

						subttl	Qmanager -- SETQH/SEQTM

					Comment %

					The procedure to make a queue entry:
					 1.  Call RSRV. to reserve a spot in the queue.
					 2.  Make an entry into the queue data area.
					 3.  Call UPDT. to update the queue pointers and make the new entry
					     available to other jobs.

					The procedure to retrieve a queue entry:
					 1.  Call SRCH. to locate an entry intended for a particular user.
					 2.  Read the specified entry.
					 3.  Call REMV. to remove the user from the destination word of the
					     entry, and possibly remove the entry.

					Structure of the queue link lists:

						+-------+-------+
						|^first | ^last |
						+-------+-------+
					  QLNK:	| ^next | dbits |  \
						+-------+-------+   \
						| ^next | dbits |  QLEN
						+-------+-------+   /
						|   -1  | dbits |  /
						+-------+-------+

					All pointers (in the left half word) are relative to QLNK.
					The destination bits (right half word) are never zero if the pointer in
					the left half of the same word is nonzero.
					%


					;;;	SETQH -- Initialize the hit queue.
					;
						entry	setqh
	410216'	63 45 64 61 50 00 		sixbit	/SETQH/
	410217'	476 00 0 00 400014'	setqh:	setom	hitql-1		;link list header word
	410220'	402 00 0 00 400015'		setzm	hitql+0		;zero all entry words
	410221'	200 01 0 00 415515'		move	t1,[hitql+0,,hitql+1]
	410222'	251 01 0 00 400634'		blt	t1,hitql+knhit-1
	410223'	263 17 0 00 000000 		popj	p,


					;;;	SETQM -- Initialize the message queue.
					;
						entry	setqm
	410224'	63 45 64 61 55 00 		sixbit	/SETQM/
	410225'	476 00 0 00 403735'	setqm:	setom	msgql-1		;link list header word
	410226'	402 00 0 00 403736'		setzm	msgql+0		;zero all entry words
	410227'	200 01 0 00 415516'		move	t1,[msgql+0,,msgql+1]
	410230'	251 01 0 00 403775'		blt	t1,msgql+knmsg-1
	410231'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 42
WARMAC	MAC	 7-Jul-;2 18:15		Qmanager -- SHQA./SHQD.

						subttl	Qmanager -- SHQA./SHQD.

					ifn dbque., <
					
					;;;	SHQA./SHQD. -- Show addition to/deletion from queue (for
					;	debugging purposes only).
					;
					;	Input
					;	  X1	Address of queue link list
					;
					shqa.:	skipa	t1,["+"]	;adding entry to queue
					shqd.:	movei	t1,"-"		;removing entry from queue
						skipn	pasflg		; only if user has *password set!
						popj	p,
						save	<x1,x2,x3,p1,c>
						movei	x3,(t1)
					
						hrrzi	x1,(x1)		;addr of queue link list
						movei	p1,[asciz /[?Q/] ;unknown queue
						cain	x1,hitql
						movei	p1,[asciz /[HQ/] ;hit queue
						cain	x1,msgql
						movei	p1,[asciz /[MQ/] ;message queue
						pushj	p,ostr.
					
						movei	c,(x3)		;+/-
						pushj	p,ochr.
						pushj	p,ospc.
					
						hrrei	x3,(x2)		;entry index
						addi	x3,(x1)		;link list entry address
						hrrz	x3,(x3)		;get destination bits
					
						hrrei	x1,(x2)		;show entry index
						setz	x2,
						pushj	p,odec.
						pushj	p,ospc.
					
						tdza	x1,x1		;show who entry is intended for
					shq.1:	lsh	x3,-1
						jumpe	x3,shq.2
						movei	p1,shtshp(x1)	;pointer to first char of ship name
						trne	x3,1
						pushj	p,ostr.		;output first char of ship name
						aoja	x1,shq.1
					
					shq.2:	movei	p1,[byte (7) "]",cr,lf,0]
						pushj	p,ostr.
						skipn	hungup
						output	tty,
					
						restor	<c,p1,x3,x2,x1>
						popj	p,
					
					> ;end ifn debug.
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 43
WARMAC	MAC	 7-Jul-;2 18:15		Qmanager -- RSRV.

						subttl	Qmanager -- RSRV.

					;;;	RSRV. -- Reserve a spot in a queue.  If the queue is full, it
					;	must be because a player somehow died without first removing his
					;	queue entries, or else the hit and message routines don't know
					;	the player is dead and are therefore still sending messages to
					;	him.  So, in this case, take the player found in the destination
					;	of the first (oldest) queue entry, and remove that player from
					;	all queue entries.
					;
					;	Input
					;	  X1[L]	Negative length of queue link list
					;	  X1[R]	Address of queue link list
					;	Output
					;	  X2	Index of reserved entry
					;
					;	MOVE X1,[-QLEN,,QLNK]
					;	PUSHJ P,RSRV.
					;	X2 has index
					;
	410232'	200 01 0 00 415521'	rsrv.:	move	t1,[[asciz /RSRV./],,quelok]
	410233'	260 17 0 00 411776'		pushj	p,lock.		;single job access only
	410234'	332 00 0 00 000000#		skipe	lkfail		; if lock request failed,
	410235'	263 17 0 00 000000 		popj	p,		; then don't mess around
	410236'	260 17 0 00 410240'		pushj	p,qrsrv.	; do the reserve
	410237'	263 17 0 00 000000 		popj	p,


	410240'				qrsrv.:
	410240'	200 01 0 00 000005 	rsrv.1:	move	t1,x1		;get pointer to queue link list
	410241'	336 00 0 01 000000 		skipn	(t1)		;spot available?
	410242'	254 00 0 00 410262'		jrst	rsrv.4		;yes, go flag it
	410243'	253 01 0 00 410241'		aobjn	t1,.-2

						;Queue is full, so remove the player probably responsible
						;for it from all queue entries.

						save	<x3>^
						  xlist
						  list
						^
	410245'	554 01 0 05 777777 		hlrz	t1,-1(x1)	;get index to first (oldest) entry
	410246'	271 01 0 05 000000 		addi	t1,(x1)		;get addr of entry
	410247'	550 01 0 01 000000 		hrrz	t1,(t1)		;get destination bits of entry
	410250'	211 07 0 01 000000 		movni	x3,(t1)
	410251'	405 07 0 01 000000 		andi	x3,(t1)		;get single destination bit
	410252'	260 17 0 00 410324'	rsrv.2:	pushj	p,srch.x	;find entry destined for player
	410253'	254 00 0 00 410256'		  jrst	rsrv.3		;no more entries destined for him
	410254'	260 17 0 00 410351'		pushj	p,remv.x	;remove player from entry
	410255'	254 00 0 00 410252'		jrst	rsrv.2		;and all remaining entries
	410256'				rsrv.3:	restor	<x3>^
						  xlist
						  list
						^
	410261'	254 00 0 00 410240'		jrst	rsrv.1		;and start over
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 43-1
WARMAC	MAC	 7-Jul-;2 18:15		Qmanager -- RSRV.


						;Found an empty spot in queue.

	410262'	476 00 0 01 000000 	rsrv.4:	setom	(t1)		;reserve spot in queue
	410263'	275 01 0 05 000000 		subi	t1,(x1)		;get it's index
	410264'	551 06 0 01 000000 		hrrzi	x2,(t1)

	410265'	201 01 0 00 000000#		movei	t1,quelok
	410266'	260 17 0 00 412142'		pushj	p,unlo.
	410267'	263 17 0 00 000000 		popj	p,
						page
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 43-2
WARMAC	MAC	 7-Jul-;2 18:15		Qmanager -- RSRVHQ

						subttl	Qmanager -- RSRVHQ
					;	CALL RSRVHQ (q)
					; Called from FORTRAN level to reserve a spot in the hit queue.
					; The que spot is returned in q
					; If unable to reserve a spot, lkfail is set

	410270'				rsrvhq::
	410270'	402 00 0 00 000000#		setzm	lkfail		; new MAKHIT does not need this routine
	410271'	263 17 0 00 000000 		popj	p,


WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 44
WARMAC	MAC	 7-Jul-;2 18:15		Qmanager -- UPDT.

						subttl	Qmanager -- UPDT.

					;;;	UPDT. -- Update queue link list pointers to make new entry
					;	available.
					;
					;	Input
					;	  X1[R]	Address of queue link list
					;	  X2	Index to reserved spot
					;	  X3[R]	Destination bits
					;
	410272'	200 01 0 00 415527'	updt.:	move	t1,[[asciz /UPDT./],,quelok]
	410273'	260 17 0 00 411776'		pushj	p,lock.		;single job access only
	410274'	332 00 0 00 000000#		skipe	lkfail
	410275'	254 00 0 00 410272'		jrst	updt.		; we must update the queue!
	410276'	260 17 0 00 410300'		pushj	p,qupdt.	; do the actual update
	410277'	263 17 0 00 000000 		popj	p,


	410300'	570 01 0 05 777777 	qupdt.:	hrre	t1,-1(x1)	;index to last entry in queue link list
	410301'	271 01 0 05 000000 		addi	t1,(x1)		;address of last entry
	410302'	506 06 0 01 000000 		hrlm	x2,(t1)		;add new entry to chain
	410303'	542 06 0 05 777777 		hrrm	x2,-1(x1)	;new last entry
	410304'	201 01 0 06 000000 		movei	t1,(x2)		;index to new entry
	410305'	271 01 0 05 000000 		addi	t1,(x1)		;address of new entry
	410306'	562 07 0 01 000000 		hrrom	x3,(t1)		;save destination bits,,data

	410307'	201 01 0 00 000000#		movei	t1,quelok
	410310'	260 17 0 00 412142'		pushj	p,unlo.
					ifn dbque., <
						pushj	p,shqa.
					> ;end ifn debug.
	410311'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 45
WARMAC	MAC	 7-Jul-;2 18:15		Qmanager -- SRCH.

						subttl	Qmanager -- SRCH.

					;;;	SRCH. -- Search a queue link list for an entry to be received
					;	by a particular player.
					;
					;	Input
					;	  X1[R]	Address of queue link list
					;	  X3	Destination bit to check for
					;	Output
					;	  X2[R]	Index to entry
					;	  X2[L]	Address of previous entry
					;
					;	MOVEI X1,QLNK
					;	PUSHJ P,SRCH.
					;	  no matching entries found
					;	X2 contains index to entry
					;
	410312'	200 01 0 00 415532'	srch.:	move	t1,[[asciz /SRCH./],,quelok]
	410313'	260 17 0 00 411776'		pushj	p,lock.		;single job access only
	410314'	332 00 0 00 000000#		skipe	lkfail
	410315'	263 17 0 00 000000 		popj	p,
	410316'	260 17 0 00 410324'		pushj	p,srch.x
	410317'	254 00 0 00 410321'		  jrst	.+2
	410320'	350 00 0 17 000000 		aos	(p)
	410321'	201 01 0 00 000000#		movei	t1,quelok
	410322'	260 17 0 00 412142'		pushj	p,unlo.
	410323'	263 17 0 00 000000 		popj	p,

	410324'	515 06 0 05 777777 	srch.x:	hrlzi	x2,-1(x1)
	410325'	574 01 0 05 777777 		hlre	t1,-1(x1)	;index to first entry in queue
	410326'	321 01 0 00 410340'	srch.1:	jumpl	t1,srch.3	;end of chain, and no match
	410327'	271 01 0 05 000000 		addi	t1,(x1)		;address of entry
	410330'	612 07 0 01 000000 		tdne	x3,(t1)		;this entry for this player?
	410331'	254 00 0 00 410335'		jrst	srch.2		;yes
	410332'	515 06 0 01 000000 		hrlzi	x2,(t1)		;remember address of entry
	410333'	574 01 0 01 000000 		hlre	t1,(t1)		;get index to next entry
	410334'	254 00 0 00 410326'		jrst	srch.1

	410335'	275 01 0 05 000000 	srch.2:	subi	t1,(x1)
	410336'	541 06 0 01 000000 		hrri	x2,(t1)
	410337'	350 00 0 17 000000 		aos	(p)

	410340'	263 17 0 00 000000 	srch.3:	popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 46
WARMAC	MAC	 7-Jul-;2 18:15		Qmanager -- REMV.

						subttl	Qmanager -- REMV.

					;;;	REMV. -- Remove a player from the destination bits of a queue
					;	entry.  If no more destination bits are set, remove the entry
					;	from the queue.
					;
					;	Input
					;	  X1[R]	Address of queue link list
					;	  X2[L]	Address of entry preceding the entry to be removed
					;	  X2[R] Index to entry to remove
					;	  X3	Bit to zero in destination word
					;
	410341'	200 01 0 00 415535'	remv.:	move	t1,[[asciz /REMV./],,quelok]
	410342'	260 17 0 00 411776'		pushj	p,lock.		;single job access only
	410343'	332 00 0 00 000000#		skipe	lkfail		; if lock failed
	410344'	254 00 0 00 410341'		jrst	remv.		; then keep trying (we gotta remove him!)
	410345'	260 17 0 00 410351'		pushj	p,remv.x
	410346'	201 01 0 00 000000#		movei	t1,quelok
	410347'	260 17 0 00 412142'		pushj	p,unlo.
	410350'	263 17 0 00 000000 		popj	p,

	410351'				remv.x:
					ifn dbque., <
						pushj	p,shqd.
					> ;end ifn debug.
	410351'	201 01 0 05 000000 		movei	t1,(x1)		;address of queue link list
	410352'	271 01 0 06 000000 		addi	t1,(x2)		;address of entry to remove player from
	410353'	412 07 0 01 000000 		andcam	x3,(t1)		;zero out player's bit
	410354'	200 02 0 01 000000 		move	t2,(t1)		;get remaining destination bits
	410355'	602 02 0 00 777777 		trne	t2,777777	;any of them set?
	410356'	254 00 0 00 410365'		jrst	remv.2		;yes, done

	410357'	554 03 0 00 000006 		hlrz	t3,x2		;get address of preceding entry
	410360'	502 02 0 03 000000 		hllm	t2,(t3)		;forget about the removed entry
	410361'	325 02 0 00 410364'		jumpge	t2,remv.1	;wasn't last entry
	410362'	275 03 0 05 000000 		subi	t3,(x1)		;get index to preceding entry
	410363'	542 03 0 05 777777 		hrrm	t3,-1(x1)	;new last entry
	410364'	402 00 0 01 000000 	remv.1:	setzm	(t1)		;zero entry so it can be used again

	410365'	263 17 0 00 000000 	remv.2:	popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 47
WARMAC	MAC	 7-Jul-;2 18:15		Hit communication -- MAKHIT

						subttl	Hit communication -- MAKHIT

					;;;	MAKHIT -- Record a hit in the hit queue so the victim can receive
					;	a message that he's been hit.
					;
					;		SUBROUTINE MAKHIT
					;
					;	Uses these low segment common variables:
					;	DBITS	(18) Bits of players to receive the message
					;
					;	DISPFR	(18) DISP code of player who scored the hit
					;	DISPTO	(18) DISP code of player who received the hit
					;	IWHAT	( 4) The type of hit
					;	IHITA	(18) The size of the hit
					;	CRITDV	( 4) The critical device that was damaged
					;	CRITDM	(18) The amount of damage done to the device
					;	VFROM	( 7) The vertical coordinate of the source
					;	HFROM	( 7) The horizontal coordinate of the source
					;	VTO	( 7) The vertical coordinate of the destination
					;	HTO	( 7) The horizontal coordinate of the destination
					;	KLFLG	( 2) Swallowed by black hole flag
					;	SHCNFR	( 1)
					;	SHCNTO	( 1)
					;	SHSTFR	(10)
					;	SHSTTO	(10)
					;	SHJUMP	( 1)
					;
					;	Structure of hit queue entry:
					;
					;	DISPFR,,DISPTO
					;	IHITA,,CRITDM
					;	<IWHAT>B3 + <CRITDV>B7 + <VFROM>B14 + <HFROM>B21 + <VTO>B28 + <HTO>B35
					;	<KLFLG>B1 + <SHCNFR>B2 + <SHCNTO>B3 + <SHSTFR>B13 + <SHSTTO>B23
					;	  + <SHJUMP>B24
					;
						entry	makhit
	410366'	55 41 53 50 51 64 		sixbit	/MAKHIT/
	410367'	336 00 0 00 000000#	makhit:	skipn	dbits
	410370'	254 00 0 00 410525'		jrst	mhit.3		;no players to inform, so don't
	410371'	200 05 0 00 000000#		move	x1,who		; scan this ship's hit list for first
	410372'	370 00 0 00 000005 		sos	x1		; free entry or the oldest one
	410373'	221 05 0 00 000050 		imuli	x1,knhshp	; x1 = first entrh in hitql
	410374'	200 06 0 00 000005 		move	x2,x1
	410375'	201 01 0 00 000050 		movei	t1,knhshp	; scan this many entries
	410376'	200 03 0 00 400013'		move	t3,hitser	; = highest entry expected
	410377'	200 02 0 05 400015'	mhit.a:	move	t2,hitql(x1)	; get the queue entry
	410400'	606 02 0 00 777777 		trnn	t2,777777	; if this one is empty
						jrst	[move	x2,x1	; then use it
	410401'	254 00 0 00 415536'			 jrst	mhit.b]
	410402'	557 00 0 00 000002 		hlrzs	t2		; else check its age
	410403'	315 02 0 00 000003 		camge	t2,t3
						jrst	[move	t3,t2	; save the new oldest one
							 move	x2,x1
	410404'	254 00 0 00 415540'			 jrst	.+1]
	410405'	350 00 0 00 000005 		aos	x1
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 47-1
WARMAC	MAC	 7-Jul-;2 18:15		Hit communication -- MAKHIT

	410406'	367 01 0 00 410377'		sojg	t1,mhit.a
									; x2 now points to the oldest entry
	410407'	350 01 0 00 400013'	mhit.b:	aos	t1,hitser	; bump the serial number
	410410'	516 01 0 06 400015'		hrlzm	t1,hitql(x2)
	410411'	201 01 0 06 000000 		movei	t1,(x2)
	410412'	221 01 0 00 000004 		imuli	t1,4		;get offset into hit queue
	410413'	271 01 0 00 400635'		addi	t1,hitq		;get absolute address of entry

	410414'	200 02 0 00 000000#		move	t2,dispfr	;DISP code of source
	410415'	506 02 0 01 000000 		hrlm	t2,0(t1)
	410416'	200 02 0 00 000000#		move	t2,dispto	;DISP code of target
	410417'	542 02 0 01 000000 		hrrm	t2,0(t1)
	410420'	200 02 0 00 000000#		move	t2,ihita	;size of hit
	410421'	506 02 0 01 000001 		hrlm	t2,1(t1)
	410422'	200 02 0 00 000000#		move	t2,critdm	;amount of critical damage
	410423'	542 02 0 01 000001 		hrrm	t2,1(t1)
	410424'	200 02 0 00 000000#		move	t2,iwhat	;type of hit
	410425'	303 02 0 00 000000 		caile	t2,0
	410426'	303 02 0 00 000017 		caile	t2,^D15
	410427'	254 00 0 00 410431'		jrst	.+2
	410430'	254 00 0 00 410462'		jrst	mhit.1
	410431'	336 00 0 00 000000#		skipn	pasflg
	410432'	254 00 0 00 410462'		jrst	mhit.1
						save	<t1,t2,x1,x2>^
						  xlist
						  list
						^
	410437'	260 17 0 00 406616'		pushj	p,ocrl.
	410440'	201 12 0 00 415543'		movei	p1,[asciz /%Illegal IWHAT code in MAKHIT: /]
	410441'	260 17 0 00 406710'		pushj	p,ostr.
	410442'	200 05 0 00 000002 		move	x1,t2
	410443'	400 06 0 00 000000 		setz	x2,
	410444'	260 17 0 00 407035'		pushj	p,odec.
	410445'	260 17 0 00 406616'		pushj	p,ocrl.
						restor	<x2,x1,t2,t1>^
						  xlist
						  list
						^
	410462'				mhit.1:
	410462'	137 02 0 00 415566'		dpb	t2,[point 4,2(t1),3]
	410463'	200 02 0 00 000000#		move	t2,critdv	;device critically damaged
	410464'	137 02 0 00 415567'		dpb	t2,[point 4,2(t1),7]
	410465'	200 02 0 00 000000#		move	t2,Vfrom
	410466'	137 02 0 00 415570'		dpb	t2,[point 7,2(t1),14]
	410467'	200 02 0 00 000000#		move	t2,Hfrom
	410470'	137 02 0 00 415571'		dpb	t2,[point 7,2(t1),21]
	410471'	200 02 0 00 000000#		move	t2,Vto
	410472'	137 02 0 00 415572'		dpb	t2,[point 7,2(t1),28]
	410473'	200 02 0 00 000000#		move	t2,Hto
	410474'	137 02 0 00 415573'		dpb	t2,[point 7,2(t1),35]
	410475'	200 02 0 00 000000#		move	t2,klflg	;killed flag
	410476'	137 02 0 00 415574'		dpb	t2,[point 2,3(t1),1]
	410477'	337 02 0 00 000000#		skipg	t2,shcnfr		;+1
	410500'	400 02 0 00 000000 		setz	t2,			;-1 goes to 0 for queue storage
	410501'	137 02 0 00 415575'		dpb	t2,[point 1,3(t1),2]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 47-2
WARMAC	MAC	 7-Jul-;2 18:15		Hit communication -- MAKHIT

	410502'	200 02 0 00 000000#		move	t2,shcnto
	410503'	337 02 0 00 000000#		skipg	t2,shcnto
	410504'	400 02 0 00 000000 		setz	t2,
	410505'	137 02 0 00 415576'		dpb	t2,[point 1,3(t1),3]
	410506'	200 02 0 00 000000#		move	t2,shstfr
	410507'	137 02 0 00 415577'		dpb	t2,[point 10,3(t1),13]
	410510'	200 02 0 00 000000#		move	t2,shstto
	410511'	137 02 0 00 415600'		dpb	t2,[point 10,3(t1),23]
	410512'	200 02 0 00 000000#		move	t2,shjump
	410513'	137 02 0 00 415601'		dpb	t2,[point 1,3(t1),24]

	410514'	200 07 0 00 000000#		move	x3,dbits	;destination bits
	410515'	436 07 0 06 400015'		iorm	x3,hitql(x2)	; set the destination bits in queue
	410516'	200 01 0 00 000000#	mhit2a:	move	t1,dbits	;get bits of players to inform
	410517'	403 02 0 00 000000#		setzb	t2,dbits
	410520'	602 01 0 00 000001 	mhit.2:	trne	t1,1		;inform this guy?
	410521'	350 00 0 02 000000#		aos	hitflg(t2)	;yes, increment his hit flag
	410522'	242 01 0 00 777777 		lsh	t1,-1		;get bit for next guy
	410523'	340 02 0 00 000000 		aoj	t2,		;index for next guy's hit flag
	410524'	326 01 0 00 410520'		jumpn	t1,mhit.2	;inform next guy

	410525'	402 00 0 00 000000#	mhit.3:	setzm	dispfr
	410526'	402 00 0 00 000000#		setzm	dispto
	410527'	402 00 0 00 000000#		setzm	ihita
	410530'	402 00 0 00 000000#		setzm	critdm
	410531'	402 00 0 00 000000#		setzm	iwhat
	410532'	402 00 0 00 000000#		setzm	critdv
	410533'	402 00 0 00 000000#		setzm	Vfrom
	410534'	402 00 0 00 000000#		setzm	Hfrom
	410535'	402 00 0 00 000000#		setzm	Vto
	410536'	402 00 0 00 000000#		setzm	Hto
	410537'	402 00 0 00 000000#		setzm	klflg
	410540'	402 00 0 00 000000#		setzm	shcnfr
	410541'	402 00 0 00 000000#		setzm	shcnto
	410542'	402 00 0 00 000000#		setzm	shstfr
	410543'	402 00 0 00 000000#		setzm	shstto
	410544'	402 00 0 00 000000#		setzm	shjump
	410545'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 48
WARMAC	MAC	 7-Jul-;2 18:15		Hit communication -- GETHIT

						subttl	Hit communication -- GETHIT

					;;;	GETHIT -- Retrieve hit information from the hit queue for the
					;	specified player.
					;
					;		SUBROUTINE GETHIT (player)
					;
					;	Parameters are the same as in MAKHIT, except they are returned
					;	instead of set.
					;
						entry	gethit
	410546'	47 45 64 50 51 64 		sixbit	/GETHIT/
	410547'	200 01 1 16 000000 	gethit:	move	t1,@0(arg)	;index of player
	410550'	371 00 0 01 000000#		sosl	hitflg-1(t1)	;decrement hit count
	410551'	254 00 0 00 410573'		jrst	ghit.2		;there was at least one hit queued
	410552'	402 00 0 00 000000#	ghit.1:	setzm	dispfr
	410553'	402 00 0 00 000000#		setzm	dispto
	410554'	402 00 0 00 000000#		setzm	ihita
	410555'	402 00 0 00 000000#		setzm	critdm
	410556'	402 00 0 00 000000#		setzm	iwhat
	410557'	402 00 0 00 000000#		setzm	critdv
	410560'	402 00 0 00 000000#		setzm	Vfrom
	410561'	402 00 0 00 000000#		setzm	Hfrom
	410562'	402 00 0 00 000000#		setzm	Vto
	410563'	402 00 0 00 000000#		setzm	Hto
	410564'	402 00 0 00 000000#		setzm	klflg
	410565'	402 00 0 00 000000#		setzm	shcnfr
	410566'	402 00 0 00 000000#		setzm	shcnto
	410567'	402 00 0 00 000000#		setzm	shstfr
	410570'	402 00 0 00 000000#		setzm	shstto
	410571'	402 00 0 00 000000#		setzm	shjump
	410572'	263 17 0 00 000000 		popj	p,

	410573'	400 06 0 00 000000 	ghit.2:	setz	x2,		; index into hit queue
	410574'	200 07 0 01 000000#		move	x3,bits-1(t1)	;bit of player to check for
	410575'	201 01 0 00 000620 		movei	t1,knhit	; total number of entries in hit queue
	410576'	616 07 0 06 400015'	ghit.a:	tdnn	x3,hitql(x2)	; if this one is for this ship
	410577'	367 01 0 00 415602'		sojg	t1,[aoja	x2,ghit.a]
	410600'	323 01 0 00 410552'		jumple	t1,ghit.1		; jump if none found
	410601'	201 01 0 06 000000 		movei	t1,(x2)
	410602'	221 01 0 00 000004 		imuli	t1,4		;offset into hit queue
	410603'	271 01 0 00 400635'		addi	t1,hitq		;absolute location of entry

	410604'	554 02 0 01 000000 		hlrz	t2,0(t1)
	410605'	306 02 0 00 777777 		cain	t2,777777	; defensive
	410606'	400 02 0 00 000000 		setz	t2,
	410607'	202 02 0 00 000000#		movem	t2,dispfr	;DISP code of source
	410610'	550 02 0 01 000000 		hrrz	t2,0(t1)
	410611'	306 02 0 00 777777 		cain	t2,777777	; defensive
	410612'	400 02 0 00 000000 		setz	t2,
	410613'	202 02 0 00 000000#		movem	t2,dispto	;DISP code of destination
	410614'	554 02 0 01 000001 		hlrz	t2,1(t1)
	410615'	202 02 0 00 000000#		movem	t2,ihita	;size of hit
	410616'	550 02 0 01 000001 		hrrz	t2,1(t1)
	410617'	202 02 0 00 000000#		movem	t2,critdm	;amount of critical damage
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 48-1
WARMAC	MAC	 7-Jul-;2 18:15		Hit communication -- GETHIT

	410620'	135 02 0 00 415566'		ldb	t2,[point 4,2(t1),3]
	410621'	202 02 0 00 000000#		movem	t2,iwhat	;type of hit
	410622'	135 02 0 00 415567'		ldb	t2,[point 4,2(t1),7]
	410623'	202 02 0 00 000000#		movem	t2,critdv	;device critically damaged
	410624'	135 02 0 00 415570'		ldb	t2,[point 7,2(t1),14]
	410625'	202 02 0 00 000000#		movem	t2,Vfrom
	410626'	135 02 0 00 415571'		ldb	t2,[point 7,2(t1),21]
	410627'	202 02 0 00 000000#		movem	t2,Hfrom
	410630'	135 02 0 00 415572'		ldb	t2,[point 7,2(t1),28]
	410631'	202 02 0 00 000000#		movem	t2,Vto
	410632'	135 02 0 00 415573'		ldb	t2,[point 7,2(t1),35]
	410633'	202 02 0 00 000000#		movem	t2,Hto
	410634'	135 02 0 00 415574'		ldb	t2,[point 2,3(t1),1]
	410635'	202 02 0 00 000000#		movem	t2,klflg	;swallowed by black hole flag
	410636'	135 02 0 00 415575'		ldb	t2,[point 1,3(t1),2]
	410637'	606 02 0 00 000001 		trnn	t2,1		;0 in queue
	410640'	474 02 0 00 000000 		seto	t2,		;was really -1 on input
	410641'	202 02 0 00 000000#		movem	t2,shcnfr
	410642'	135 02 0 00 415576'		ldb	t2,[point 1,3(t1),3]
	410643'	606 02 0 00 000001 		trnn	t2,1
	410644'	474 02 0 00 000000 		seto	t2,
	410645'	202 02 0 00 000000#		movem	t2,shcnto
	410646'	135 02 0 00 415577'		ldb	t2,[point 10,3(t1),13]
	410647'	202 02 0 00 000000#		movem	t2,shstfr
	410650'	135 02 0 00 415600'		ldb	t2,[point 10,3(t1),23]
	410651'	202 02 0 00 000000#		movem	t2,shstto
	410652'	135 02 0 00 415601'		ldb	t2,[point 1,3(t1),24]
	410653'	202 02 0 00 000000#		movem	t2,shjump
	410654'	201 02 0 06 000000 		movei	t2,(x2)
	410655'	271 02 0 00 400015'		addi	t2,hitql	;index into destination list
	410656'	550 02 0 02 000000 		hrrz	t2,(t2)
	410657'	202 02 0 00 000000#		movem	t2,dbits	;destination bits
	410660'	412 07 0 06 400015'		andcam	x3,hitql(x2)	; remove this entry
	410661'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 49
WARMAC	MAC	 7-Jul-;2 18:15		Message communication -- MAKMSG

						subttl	Message communication -- MAKMSG

					;;;	MAKMSG -- Enter a message into the message queue.
					;
					;		SUBROUTINE MAKMSG (msg)
					;
					;	Uses the low segment variables DISPFR and DBITS, which tell who
					;	the message came from and who it's going to.  MSG is optional,
					;	and if not specified the message will be taken from the TTY.
					;
						entry	makmsg
	410662'	55 41 53 55 63 47 		sixbit	/MAKMSG/
	410663'	336 00 0 00 000000#	makmsg:	skipn	dbits
	410664'	263 17 0 00 000000 		popj	p,		;no guys to inform, so don't

	410665'	574 12 0 16 777777 		hlre	p1,-1(arg)	;neg number of args
	410666'	322 12 0 00 410675'		jumpe	p1,mmsg.1	;no arguments, so get input from TTY
	410667'	201 12 1 16 000000 		movei	p1,@0(arg)	;get address of string to send
	410670'	200 03 0 12 000000 		move	t3,(p1)		;get first word of string
	410671'	607 03 0 00 777777 		tlnn	t3,777777
	410672'	200 12 0 12 000000 		move	p1,(p1)		;arg was really address of address
	410673'	505 12 0 00 440700 		hrli	p1,(point 7)	;create pointer to source string
	410674'	254 00 0 00 410710'		jrst	mmsg.3

	410675'	200 12 0 00 415603'	mmsg.1:	move	p1,[point 36,linbuf]
	410676'	134 11 0 00 000012 	mmsg.2:	ildb	c,p1		;get char
	410677'	306 11 0 00 000073 		cain	c,";"		;start of message
	410700'	254 00 0 00 410710'		jrst	mmsg.3		;yes, message has already been typed
	410701'	326 11 0 00 410676'		jumpn	c,mmsg.2	;search rest of line
	410702'	201 12 0 00 415604'		movei	p1,[asciz /Msg: /]
	410703'	260 17 0 00 406710'		pushj	p,ostr.
	410704'	260 17 0 00 406431'		pushj	p,inli.		;get line of input
	410705'	332 00 0 00 000000#		skipe	ccflg		;^C?
	410706'	254 00 0 00 410742'		jrst	mmsg.5		;yes, no message sent
	410707'	200 12 0 00 415603'		move	p1,[point 36,linbuf]

	410710'	200 05 0 00 415606'	mmsg.3:	move	x1,[-knmsg,,msgql] ;message queue link list
	410711'	260 17 0 00 410232'		pushj	p,rsrv.		;reserve a spot in the message queue
	410712'	332 00 0 00 000000#		skipe	lkfail		; if lock failed,
	410713'	254 00 0 00 410710'		jrst	mmsg.3
	410714'	201 01 0 06 000000 		movei	t1,(x2)
	410715'	221 01 0 00 000021 		imuli	t1,msglen	;get offset into message queue
	410716'	270 01 0 00 415607'		add	t1,[point 7,msgq+1]
	410717'	514 02 0 00 000000#		hrlz	t2,dispfr	;from
	410720'	540 02 0 00 000000#		hrr	t2,dbits	;to
	410721'	202 02 0 01 777777 		movem	t2,-1(t1)
	410722'	211 02 0 00 000115 		movni	t2,<msglen-1>*5-3 ;max number of chars to store

	410723'	134 11 0 00 000012 	mmsg.4:	ildb	c,p1
	410724'	345 02 0 00 410726'		aojge	t2,.+2		;more room in buffer?
	410725'	136 11 0 00 000001 		idpb	c,t1		;yes, stick character into buffer
	410726'	200 03 0 11 405267'		move	t3,cbits(c)	;get character type bits
	410727'	606 03 0 00 000200 		trnn	t3,cf.eol	;end of line?
	410730'	254 00 0 00 410723'		jrst	mmsg.4		;no, keep on reading

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 49-1
WARMAC	MAC	 7-Jul-;2 18:15		Message communication -- MAKMSG

	410731'	201 11 0 00 000015 		movei	c,cr
	410732'	137 11 0 00 000001 		dpb	c,t1		;force a <CR>
	410733'	201 11 0 00 000012 		movei	c,lf
	410734'	136 11 0 00 000001 		idpb	c,t1		;force a <LF>
	410735'	400 11 0 00 000000 		setz	c,
	410736'	136 11 0 00 000001 		idpb	c,t1		;end message with null byte

	410737'	271 02 0 00 000115 		addi	t2,<msglen-1>*5-3 ;number of characters in message
	410740'	303 02 0 00 000002 		caile	t2,2		;more than 2 characters?
	410741'	254 00 0 00 410750'		jrst	mmsg.6		;yes
	410742'				mmsg.5:	movei	p1,[ascil <No message sent>^
						  asciz `No message sent
					`
	410742'	201 12 0 00 415610'		^]
	410743'	260 17 0 00 406710'		pushj	p,ostr.
	410744'	474 07 0 00 000000 		seto	x3,
	410745'	200 05 0 00 415606'		move	x1,[-knmsg,,msgql]
	410746'	260 17 0 00 410341'		pushj	p,remv.		;free up reserved spot
	410747'	254 00 0 00 410761'		jrst	mmsg.8

	410750'	200 07 0 00 000000#	mmsg.6:	move	x3,dbits	;destination bits
	410751'	260 17 0 00 410272'		pushj	p,updt.		;make queue entry
	410752'	200 01 0 00 000000#		move	t1,dbits	;get bits of players to inform
	410753'	400 02 0 00 000000 		setz	t2,
	410754'	602 01 0 00 000001 	mmsg.7:	trne	t1,1		;inform this player?
	410755'	350 00 0 02 000000#		aos	msgflg(t2)	;yes, increment his message count
	410756'	242 01 0 00 777777 		lsh	t1,-1		;get next player's bit
	410757'	340 02 0 00 000000 		aoj	t2,		;index of next player's mesage count
	410760'	326 01 0 00 410754'		jumpn	t1,mmsg.7	;inform next player

	410761'	402 00 0 00 000000#	mmsg.8:	setzm	dbits
	410762'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 50
WARMAC	MAC	 7-Jul-;2 18:15		Message communication -- GETMSG

						subttl	Message communication -- GETMSG

					;;;	GETMSG -- Retrieve a message from the message queue for the
					;	specified player.
					;
					;		SUBROUTINE GETMSG (player,msg)
					;
					;	Output
					;	  DISPFR  code for sender of message
					;	  DBITS   bits of all receivers of message
					;
						entry	getmsg
	410763'	47 45 64 55 63 47 		sixbit	/GETMSG/
	410764'	200 01 1 16 000000 	getmsg:	move	t1,@0(arg)	;index of player
	410765'	371 00 0 01 000000#		sosl	msgflg-1(t1)	;decrement message count
	410766'	254 00 0 00 410774'		jrst	gmsg.2		;there was a message waiting
	410767'	200 01 1 16 000000 	gmsg.1:	move	t1,@0(arg)
	410770'	402 00 0 01 000000#		setzm	msgflg-1(t1)
	410771'	402 00 0 00 000000#		setzm	dispfr
	410772'	402 00 0 00 000000#		setzm	dbits
	410773'	263 17 0 00 000000 		popj	p,

	410774'	201 10 1 16 000001 	gmsg.2:	movei	x4,@1(arg)	;address of array to store message in
	410775'	201 05 0 00 403736'		movei	x1,msgql	;address of message queue link list
	410776'	200 07 0 01 000000#		move	x3,bits-1(t1)	;bit of player to check for
	410777'	260 17 0 00 410312'		pushj	p,srch.		;get index into message queue
	411000'	254 00 0 00 410767'		  jrst	gmsg.1		;no entry -- something went wrong
	411001'	201 01 0 06 000000 		movei	t1,(x2)
	411002'	221 01 0 00 000021 		imuli	t1,msglen	;get relative index to message
	411003'	271 01 0 00 403776'		addi	t1,msgq		;get absolute index to message
	411004'	554 02 0 01 000000 		hlrz	t2,(t1)
	411005'	306 02 0 00 777777 		cain	t2,777777
	411006'	400 02 0 00 000000 		setz	t2,
	411007'	202 02 0 00 000000#		movem	t2,dispfr	;who sent the message
	411010'	550 02 0 01 000000 		hrrz	t2,(t1)
	411011'	306 02 0 00 777777 		cain	t2,777777
	411012'	402 02 0 00 000000 		setzm	t2,
	411013'	202 02 0 00 000000#		movem	t2,dbits	;who the message was sent to

	411014'	515 01 0 01 000001 		hrlzi	t1,1(t1)	;FROM,,0
	411015'	271 01 0 10 000000 		addi	t1,(x4)		;FROM,,TO
	411016'	251 01 0 10 000017 		blt	t1,msglen-2(x4)	;transfer message to array

	411017'	260 17 0 00 410341'		pushj	p,remv.		;remove entry from message queue
	411020'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 51
WARMAC	MAC	 7-Jul-;2 18:15		JOBSTA

						subttl	JOBSTA

						;Return various job related parameters.
						;
						;SUBROUTINE JOBSTA (job,nam1,nam2,ppn,TTY#,TTYspeed)

						entry	jobsta
	411021'	52 57 42 63 64 41 		sixbit	/JOBSTA/
						entry	usrprj
	411022'	554 00 0 00 414766'	usrprj:	hlrz	0,usppn.#		; return user's project #
	411023'	306 00 0 00 000337 		cain	0,337			; watch for devel. ppn
	411024'	201 00 0 00 070000 		movei	0,70000			; make it look like CIS staff
	411025'	263 17 0 00 000000 		popj	p,

					;	chkseq:		check jobs for continued activity
					;	call chkseq	(from GETCMD)

	411026'	46 62 43 43 50 53 		sixbit	/frcchk/
	411027'				frcchk::
	411027'	402 00 0 00 400000'		setzm	jsqtim
	411030'	254 00 0 00 411032'		jrst	chkseq		; force sequence check on new user
	411031'	43 50 53 63 45 61 		sixbit	/chkseq/
	411032'				chkseq::

	411032'	263 17 0 00 000000 		popj	p,		; ignore it for now!

	411033'	047 01 0 00 777570 		calli	t1,-210		; is it time to check?
	411034'	200 01 0 00 400000'		  move	t1,jsqtim	; in case of failure, do check now
	411035'	315 01 0 00 400000'		camge	t1,jsqtim
	411036'	263 17 0 00 000000 		popj	p,		; no
	411037'	271 01 0 00 000264 		addi	t1,^d60*3	; yes. set time for next check
	411040'	202 01 0 00 400000'		movem	t1,jsqtim
	411041'	201 01 0 00 000011 		movei	t1,^d9		; scan the table
	411042'	336 02 0 01 400001'	chksq0:	skipn	t2,jsqtab(t1)	; if this one active
	411043'	254 00 0 00 411067'		jrst	chksq1		; then
	411044'	514 03 0 00 000002 		hrlz	t3,t2		; get that job's sequence number
	411045'	541 03 0 00 000045 		hrri	t3,45
	411046'	047 03 0 00 000041 		gettab	t3,
	411047'	254 00 0 00 411053'		  jrst	chksq2		; failure - go free the ship
	411050'	430 03 0 00 000002 		xor	t3,t2		; if same seq #
	411051'	607 03 0 00 777777 		tlnn	t3,-1		;then
	411052'	254 00 0 00 411067'		  jrst	chksq1		;	check next ship
	411053'				chksq2:	save<t1>^
						  xlist
						  list
						^
	411054'	402 00 0 01 400000'		setzm	jsqtab-1(t1)
	411055'	201 02 0 01 000001 		movei	t2,1(t1)	; else free this ship
	411056'	261 17 0 00 000002 		push	p,t2
	411057'	201 16 0 17 000000 		movei	arg,0(p)
	411060'	261 17 0 00 000016 		push	p,arg
	411061'	201 16 0 17 000000 		movei	arg,0(p)
	411062'	260 17 0 00 000000*		pushj	p,free##
	411063'	274 17 0 00 415614'		sub	p,[2,,2]
						restore<t1>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 51-1
WARMAC	MAC	 7-Jul-;2 18:15		JOBSTA

						  xlist
						  list
						^
	411067'	365 01 0 00 411042'	chksq1:	sojge	t1,chksq0
	411070'	263 17 0 00 000000 		popj	p,

	411071'	52 57 42 63 64 41 		sixbit	/JOBSTA/
	411072'				jobsta:
	411072'	067 00 0 00 000000 		output	tty,			; flush tty buffer
	411073'	047 01 0 00 000030 		pjob	t1,
	411074'	202 01 1 16 000000 		movem	t1,@kjob-1(arg)	;job number

					;commented by merlyn (drforbin)
					;	move	t1,[	2,,[	1016
					;				-1
					;			   ]
					;		]
					;	trmop.	t1,			; get terminal's baud code
					;	  movei	t1,4			; assume 300 baud
					;	caile	t1,8			; don't show higher than 2400 baud
					;	  movei	t1,6
					;	move	t1,[	^d300		; 0 = undefined; assume 300
					;			^d110		; 1
					;			^d134		; 2
					;			^d150		; 3
					;			^d300		; 4
					;			^d600		; 5
					;			^d1200		; 6
					;			^d1800		; 7
					;			^d2400		; 8
					;		](t1)
					;	movem	t1,@kttysp-1(arg)



					;rewrite by merlyn (drforbin)

						move	t1,[	2,,[	.TORSP
									-1
								   ]
	411075'	200 01 0 00 415622'			]
	411076'	047 01 0 00 000116 		trmop.	t1,			; get terminal's baud code
	411077'	201 01 0 00 000007 		  movei	t1,7			; assume 300 baud
	411100'	303 01 0 00 000013 		caile	t1,13			; don't show higher than 2400 baud
	411101'	201 01 0 00 000011 		  movei	t1,11
						move	t1,[	^d300		; 0 = undefined; assume 300
								^d50		; 1
								^d75		; 2
								^d110		; 3
								^d134		; 4
								^d150		; 5
								^d200		; 6
								^d300		; 7
								^d600		; 8
								^d1200		; 9
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 51-2
WARMAC	MAC	 7-Jul-;2 18:15		JOBSTA

								^d1800		; 10
								^d2400		; 11
	411102'	200 01 0 01 415623'			](t1)
	411103'	202 01 1 16 000005 		movem	t1,@kttysp-1(arg)

					;end rewrite


	411104'	332 01 0 00 000000#		skipe	t1,who			; if ship is assigned
					;	jrst	[calli	t2,-46		;commented drforbin;then set up the sequence #
						jrst	[pjob	t2,		;added drforbin;then set up the sequence #
							 jfcl
							 movem	t1,jsqwho	; remember that we have it
							 movem	t2,jsqtab-1(t1)
							 jrst	.+1
	411105'	254 00 0 00 415637'			]
	411106'	400 02 0 00 000000 		setz	t2,
	411107'	047 01 0 00 000024 		getppn	t1,
	411110'	255 00 0 00 000000 		  jfcl
	411111'	316 01 0 00 415644'		camn	t1,[337,,2030]
	411112'	474 02 0 00 000000 		seto	t2,
	411113'	135 03 0 00 415645'		ldb	t3,[point 9,t1,8]
	411114'	306 03 0 00 000077 		cain	t3,077
	411115'	201 02 0 00 000001 		movei	t2,1
	411116'	202 02 0 00 001760'		movem	t2,debflg

					;changed by drforbin (merlyn)
					;replaced use of tmpcor ppn with standard monitor call
					;	move	t1,usppn.##		; transfer user's ppn


	411117'	047 01 0 00 000024 		getppn	t1,			;added drforin
	411120'	202 01 0 00 414766'		movem	t1,usppn.#		;added drforbin
	411121'	202 01 1 16 000003 		movem	t1,@kppn-1(arg)
	411122'	402 00 0 00 000354'		setzm	frebie
	411123'	554 01 0 00 000001 		hlrz	t1,t1
	411124'	305 01 0 00 070010 		caige	t1,70010
	411125'	476 00 0 00 000354'		setom	frebie
	411126'	640 01 0 00 077000 		trc	t1,77000
	411127'	606 01 0 00 077000 		trnn	t1,77000
	411130'	476 00 0 00 000354'		setom	frebie
	411131'	405 01 0 00 000007 		andi	t1,7
	411132'	306 01 0 00 000003 		cain	t1,3
	411133'	476 00 0 00 000354'		setom	frebie
					;drforbin below commented-Used by CIS for returing to fortran (user id #1 user id #2)
					;	move	t1,usid1.##		; and account id
					;	movem	t1,@knam1-1(arg)
					;	move	t1,usid2.##
					;	movem	t1,@knam2-1(arg)
	411134'	047 01 0 00 000034 		getlin	t1, ;tofix			; store tty name
	411135'	202 01 1 16 000004 		movem	t1,@4(arg)
					;all 3 commented below by drforbin(merlyn) was used by CIS for player name from cb handle us
					cbh. (user cb handle).
					;also remove usid1. (user id #1) CIS
	411136'	200 01 0 00 415646'		move	t1,[point 7,uscbh.]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 51-3
WARMAC	MAC	 7-Jul-;2 18:15		JOBSTA

					;	ldb	t2,[point 7,uscbh.,6];drforbin(merlyn)deleted ##	; if there is a CB h
					andle
						ldb	t2,[point 7,uscbh.,7];changed 6 to 7 right most bit	; if there is a CB h
	411137'	135 02 0 00 415647'	andle
	411140'	326 02 0 00 411173'		jumpn	t2,gnm2			; then use it as player's name
					;	skipe	usid1.##		; else if user has an acct ID
					;	jrst	gnm5			; then use that

	411141'	336 00 0 00 000000#	gnm:	skipn	hungup
	411142'	402 00 0 00 000002'		setzm	uscbh.
	411143'	402 00 0 00 000003'		setzm	uscbh.+1
	411144'	402 00 0 00 000000'		setzm	hand
	411145'	402 00 0 00 000001'		setzm	hand+1
	411146'	402 00 1 16 000001 		setzm	@knam1-1(arg)
	411147'	402 00 1 16 000002 		setzm	@knam2-1(arg)
						outstr	[asciz "
	411150'	051 03 0 00 415650'	Your name please: "]			; else ask for his/her name
					;	move	t1,[point 7,uscbh.];deleted drforbin(merlyn) #
	411151'	402 00 0 00 000000#		setzm	ccflg
	411152'	051 04 0 00 000002 	gnm0:	inchwl	t2
	411153'	302 02 0 00 000003 		caie	t2,03			; if ^C
	411154'	332 00 0 00 000000#		skipe	ccflg
	411155'	263 17 0 00 000000 		popj	p,			; return if ^C while doing this
	411156'	322 02 0 00 411152'		jumpe	t2,gnm0
	411157'	306 02 0 00 000015 		cain	t2,15
	411160'	254 00 0 00 411152'		jrst	gnm0
	411161'	302 02 0 00 000012 		caie	t2,12
	411162'	306 02 0 00 000033 		cain	t2,33
	411163'	254 00 0 00 411170'		jrst	gnm1
	411164'	306 02 0 00 000007 		cain	t2,7
	411165'	254 00 0 00 411170'		jrst	gnm1
	411166'	136 02 0 00 000001 		idpb	t2,t1
	411167'	254 00 0 00 411152'		jrst	gnm0

	411170'	201 02 0 00 000000 	gnm1:	movei	t2,0
	411171'	136 02 0 00 000001 		idpb	t2,t1
	411172'	200 01 0 00 415646'		move	t1,[point 7,uscbh.]	;deleted # drforbin

	411173'	200 02 0 00 415655'	gnm2:	move	t2,[point 6,hand]	;added 'hand' as variable (DF) drforbin
	411174'	402 00 0 00 001767'		setzm	tmp
	411175'	402 00 0 00 001770'		setzm	tmp+1

	411176'	134 03 0 00 000001 	gnm3:	ildb	t3,t1
	411177'	322 03 0 00 411206'		jumpe	t3,gnm4
	411200'	301 03 0 00 000141 		cail	t3,"a"
	411201'	303 03 0 00 000172 		caile	t3,"z"
	411202'	640 03 0 00 000040 		trc	t3,40
	411203'	136 03 0 00 000002 		idpb	t3,t2
	411204'	312 02 0 00 415656'		came	t2,[point 6,hand+1,35]	;same as above(DF) drforbin
	411205'	254 00 0 00 411176'		jrst	gnm3

	411206'	200 01 0 00 000000'	gnm4:	move	t1,hand			;same as above(DF) drforbin
	411207'	322 01 0 00 411141'		jumpe	t1,gnm
	411210'	202 01 1 16 000001 		movem	t1,@knam1-1(arg)
	411211'	200 01 0 00 000001'		move	t1,hand+1
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 51-4
WARMAC	MAC	 7-Jul-;2 18:15		JOBSTA

	411212'	202 01 1 16 000002 		movem	t1,@knam2-1(arg)
	411213'				gnm5:
					;***	CIS change:

	411213'	263 17 0 00 000000 		popj	p,

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 52
WARMAC	MAC	 7-Jul-;2 18:15		INPUT/CLEAR

						subttl	INPUT/CLEAR

						entry	input
	411214'	51 56 60 65 64 00 		sixbit	/INPUT/
	411215'	333 00 0 00 000141'	input:	skiple	bufptr		;any part of multiple command line left?
	411216'	254 00 0 00 411242'		jrst	inpt.2		;yes, go get it
	411217'	335 00 0 00 000136'		skipge	iniflg		;input from DECWAR.INI?
	411220'	254 00 0 00 411242'		jrst	inpt.2		;yes, always return input ready
	411221'	337 01 1 16 000000 		skipg	t1,@0(arg)	;get # of milliseconds to wait for input
	411222'	254 00 0 00 411235'		jrst	inpt.1		;he doesn't want us to wait
	411223'	200 01 0 00 000356'		move	t1,locked	; don't keep database while hibernating
	411224'	202 01 0 00 000357'		movem	t1,svlock
	411225'	332 00 0 00 000001 		skipe	t1
	411226'	260 17 0 00 412142'		pushj	p,unlo.
	411227'	200 01 1 16 000000 		move	t1,@0(arg)
	411230'	505 01 0 00 000010 		hrli	t1,(HB.RTC)	;wake when character is ready
	411231'	047 01 0 00 000072 		hiber	t1,		;wait for command
	411232'	254 04 0 00 000000 		  halt
	411233'	332 01 0 00 000357'		skipe	t1,svlock
						jrst	[pushj	p,lock.
							 skipe	lkfail
							 jrst	.-1
	411234'	254 00 0 00 415657'			 jrst	.+1]
	411235'	400 00 0 00 000000 	inpt.1:	setz	0,		;assume wake because of time out
	411236'	332 00 0 00 000000#		skipe	hungup		; if user hung up
	411237'	254 00 0 00 411242'		jrst	inpt.2		; then we will force "input"
	411240'	051 13 0 00 000000 		skpinc			;input waiting?
	411241'	332 00 0 00 000000#		  skipe	ccflg		;or ^C interrupt?
	411242'	474 00 0 00 000000 	inpt.2:	seto	0,		;yes, flag input ready
						save<0>^
						  xlist
						  list
						^
						restore<0>^
						  xlist
						  list
						^
	411247'	263 17 0 00 000000 		popj	p,


						entry	clear
	411250'	43 54 45 41 62 00 		sixbit	/CLEAR/
	411251'	332 00 0 00 000000#	clear:	skipe	hungup		; if job is not hungup
	411252'	051 11 0 00 000000 		clrbfi			;clear the input buffer
	411253'	476 00 0 00 000141'		setom	bufptr		;clear multiple command line
	411254'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 53
WARMAC	MAC	 7-Jul-;2 18:15		BLKSET/BLKMOV/LOCF

						subttl	BLKSET/BLKMOV/LOCF

					;;;	BLKSET -- Fill a array or data area with a value.
					;
					;		CALL BLKSET (array,value,size)
					;
						entry	blkset
	411255'	42 54 53 63 45 64 		sixbit	/BLKSET/
	411256'	200 01 1 16 000001 	blkset:	move	t1,@1(arg)	;get value
	411257'	202 01 1 16 000000 		movem	t1,@0(arg)	;store it in the first word
	411260'	201 01 1 16 000000 		movei	t1,@0(arg)
	411261'	505 01 0 01 000000 		hrli	t1,(t1)
	411262'	340 01 0 00 000000 		aoj	t1,
	411263'	201 02 0 01 777776 		movei	t2,-2(t1)
	411264'	270 02 1 16 000002 		add	t2,@2(arg)
	411265'	251 01 0 02 000000 		blt	t1,(t2)
	411266'	263 17 0 00 000000 		popj	p,


					;;;	BLKMOV -- Move a block of data.
					;
					;		call BLKMOV (from,to,nwords)
					;
						entry	blkmov
	411267'	42 54 53 55 57 66 		sixbit	/BLKMOV/
	411270'	505 01 1 16 000000 	blkmov:	hrli	t1,@0(arg)
	411271'	541 01 1 16 000001 		hrri	t1,@1(arg)
	411272'	201 02 0 01 777777 		movei	t2,-1(t1)
	411273'	270 02 1 16 000002 		add	t2,@2(arg)
	411274'	251 01 0 02 000000 		blt	t1,(t2)
	411275'	263 17 0 00 000000 		popj	p,


					;;;	LOCF -- Return the location of a variable.
					;
					;		addr = LOCF(var)
					;
						entry	locf
	411276'	54 57 43 46 00 00 		sixbit	/LOCF/
	411277'	201 00 1 16 000000 	locf:	movei	0,@0(16)
	411300'	263 17 0 00 000000 		popj	17,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 54
WARMAC	MAC	 7-Jul-;2 18:15		DAYTIM/RUNTIM/ETIM/PAUSE

						subttl	DAYTIM/RUNTIM/ETIM/PAUSE

						;Return the current time of day.
						;
						;	CALL DAYTIM (DTIM)

						entry	daytim
	411301'	44 41 71 64 51 55 		sixbit	/DAYTIM/
	411302'	047 00 0 00 000023 	daytim:	mstime	0,
	411303'	202 00 1 16 000000 		movem	0,@0(arg)
	411304'	263 17 0 00 000000 		popj	p,


						;Return the current run time.
						;
						;	CALL RUNTIM (RTIM)

						entry	runtim
	411305'	62 65 56 64 51 55 		sixbit	/RUNTIM/
	411306'	400 00 0 00 000000 	runtim:	setz	0,
	411307'	047 00 0 00 000027 		runtim	0,
	411310'	202 00 1 16 000000 		movem	0,@0(arg)
	411311'	263 17 0 00 000000 		popj	p,


						;Return the amount of time elapsed since the given time.
						;The given time is in milliseconds past midnight, and may
						;exceed 24*60*60*1000.
						;If the given time is yet to come, return a negative elapsed
						;time.  This routine will not return an elapsed time with
						;an absolute value greater than 12 -- it returns the smallest
						;of the values
						;   abs(TIM0) - current_time
						;   abs(TIM0) - current_time + 12 hours
						;
						;	dT = ETIM (TIM0)

						entry	etim
	411312'	45 64 51 55 00 00 		sixbit	/ETIM/
	411313'	047 00 0 00 000023 	etim:	mstime	0,
	411314'	274 00 1 16 000000 		sub	0,@0(arg)
	411315'	315 00 0 00 415666'		camge	0,[-<^D1000*^D60*^D60*^D12>]
	411316'	274 00 0 00 415667'		sub	0,[-<^D1000*^D60*^D60*^D24>]
	411317'	313 00 0 00 415670'		camle	0,[^D1000*^D60*^D60*^D12]
	411320'	274 00 0 00 415671'		sub	0,[^D1000*^D60*^D60*^D24]
	411321'	263 17 0 00 000000 		popj	p,


						;Pause for the specified number of milliseconds.
						;
						;	CALL PAUSE (time)

						entry	pause
	411322'	60 41 65 63 45 00 		sixbit	/PAUSE/

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 54-1
WARMAC	MAC	 7-Jul-;2 18:15		DAYTIM/RUNTIM/ETIM/PAUSE


					;both comments and mstime calls added by merlyn


	411323'				pause:
	411323'	337 00 1 16 000000 		skipg	@0(arg)		; if hibernate time .le. 0
	411324'	263 17 0 00 000000 		popj	p,		; then don't hibernate!
	411325'	200 01 0 00 000356'		move	t1,locked
	411326'	202 01 0 00 000357'		movem	t1,svlock
	411327'	332 00 0 00 000001 		skipe	t1
	411330'	260 17 0 00 412142'		pushj	p,unlo.
	411331'	200 01 1 16 000000 		move	t1,@0(arg)
	411332'	323 01 0 00 411350'		jumple	t1,paus.3
	411333'	303 01 0 00 023420 		caile	t1,^d10000		; if > 10 seconds, make it 10 seconds
	411334'	201 01 0 00 023420 		movei	t1,^d10000
					;	idivi	t1,^d333		; convert ms to (approx) unitics
	411335'	047 03 0 00 000023 		mstime	t3,			; get current UTC
					;	  setz	t3,
	411336'	270 03 0 00 000001 		add	t3,t1			; t3 holds end of time period
	411337'	200 01 1 16 000000 		move	t1,@0(arg)		; get MS again
	411340'	303 01 0 00 023420 		caile	t1,^d10000
	411341'	201 01 0 00 023420 		movei	t1,^d10000

	411342'	047 01 0 00 000072 	paus.4:	hiber	t1,
	411343'	254 04 0 00 000000 		  halt

	411344'	047 02 0 00 000023 		mstime	t2,		; get current UTC
					;	  setz	t2,
	411345'	201 01 0 00 001750 		movei	t1,^d1000	; hibernate extra second
	411346'	315 02 0 00 000003 		camge	t2,t3		; if not time to wake up yet
	411347'	254 00 0 00 411342'		jrst	paus.4
	411350'	332 01 0 00 000357'	paus.3:	skipe	t1,svlock
						jrst	[pushj	p,lock.
							 skipe	lkfail
							 jrst	.-1
	411351'	254 00 0 00 415672'			 jrst	.+1]
	411352'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 55
WARMAC	MAC	 7-Jul-;2 18:15		PRGNAM/USRNAM

						subttl	PRGNAM/USRNAM

					;;;	PRGNAM -- Change the name of the program.
					;
					;		CALL PRGNAM (name)
					;
						entry	prgnam
	411353'	60 47 62 56 41 55 		sixbit	/PGRNAM/
	411354'				prgnam:
	411354'	263 17 0 00 000000 		popj	p,

					;;;	USRNAM -- Change the name of the user in the JOB array.
					;
					;		f = USRNAM (index)
					;
					;	where index is the number of the token preceding the name.
					;	f is true if the name got set (non zero), otherwise it's false.
					;
						entry	usrnam
	411355'	65 63 62 56 41 55 		sixbit	/USRNAM/
	411356'	400 00 0 00 000000 	usrnam:	setz	t0,		;get set to return false
	411357'	336 12 1 16 000000 		skipn	p1,@0(arg)	;get token index
	411360'	254 00 0 00 411370'		jrst	usrn.2		;first token, so start scanning at first char

	411361'	200 12 0 12 000000#		move	p1,ptrlst-1(p1)	;get ptr to first char of token preceding name
	411362'	336 11 0 12 000000 	usrn.1:	skipn	c,(p1)		;get char of token
	411363'	254 00 0 00 411417'		jrst	usrn.5		;end of line, and no name found
	411364'	504 11 0 11 405267'		hrl	c,cbits(c)	;get character type bits
	411365'	607 11 0 00 010000 		tlnn	c,cf.dlm	;delimiter (end of token)?
	411366'	344 12 0 00 411362'		aoja	p1,usrn.1	;no, keep looking

	411367'	344 12 0 00 411371'		aoja	p1,.+2		;skip to first char of new name
	411370'	201 12 0 00 000143'	usrn.2:	movei	p1,linbuf	;pointer to first char of input line
	411371'	200 13 0 00 415676'		move	p2,[point 6,tmp];stick it here for right now
	411372'	402 00 0 00 001767'		setzm	tmp+0
	411373'	402 00 0 00 001770'		setzm	tmp+1

	411374'	201 01 0 00 000014 		movei	t1,^D12		;copy at most 12 characters
	411375'	336 11 0 12 000000 	usrn.3:	skipn	c,(p1)		;get character from input line
	411376'	254 00 0 00 411407'		jrst	usrn.4		;end of line, so done
	411377'	303 11 0 00 000137 		caile	c,137		;lower case?
	411400'	620 11 0 00 000040 		trz	c,040		;yes, make upper case
	411401'	275 11 0 00 000040 		subi	c,040		;convert to sixbit
	411402'	325 11 0 00 411404'		jumpge	c,.+2
	411403'	271 11 0 00 000100 		addi	c,100		;oops, went the wrong way
	411404'	136 11 0 00 000013 		idpb	c,p2		;and stow it away
	411405'	271 12 0 00 000001 		addi	p1,1		;point to next char of input
	411406'	367 01 0 00 411375'		sojg	t1,usrn.3	;and get any more characters

	411407'	120 01 0 00 001767'	usrn.4:	dmove	t1,tmp
	411410'	326 01 0 00 411413'		jumpn	t1,.+3		;first half of name zero?
	411411'	326 02 0 00 411413'		jumpn	t2,.+2		;and second half of name zero?
	411412'	254 00 0 00 411417'		jrst	usrn.5		;yes, don't set name, and return false
	411413'	474 00 0 00 000000 		seto	t0,		;return true
	411414'	200 03 0 00 000000#		move	t3,who		;get index of player
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 55-1
WARMAC	MAC	 7-Jul-;2 18:15		PRGNAM/USRNAM

	411415'	202 01 0 03 000000#		movem	t1,JOB-1+<KNAM1-1>*KNPLAY(t3)
	411416'	202 02 0 03 000000#		movem	t2,JOB-1+<KNAM2-1>*KNPLAY(t3)

	411417'	476 00 0 00 000141'	usrn.5:	setom	bufptr		;SET NAME is last on line
	411420'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 56
WARMAC	MAC	 7-Jul-;2 18:15		CCTRAP

						subttl	CCTRAP

					;;;	CCTRAP -- Control action of ^C when not waiting for input.
					;
					;		CALL CCTRAP		!turn ^C off
					;		    or
					;		CALL CCTRAP (sub)	!trap to sub on ^C
					;
					;	The FORTRAN calling routine must declare sub to be external.
					;	^C will be disabled for the duration of the trap routine,
					;	but the original action will be automatically restored when
					;	the routine is finished (the trap routine may call CCTRAP,
					;	but it won't take affect until after the return from the
					;	original trap routine).
					;
						entry	cctrap
	411421'	43 43 64 62 41 60 		sixbit	/CCTRAP/
	411422'	201 01 1 16 000000 	cctrap:	movei	t1,@0(arg)	;get address of trap routine
	411423'	202 01 0 00 002003'		movem	t1,trpadr	;save it for ^C interrupt handler
	411424'	402 00 0 00 000000#		setzm	ccflg		;clear ^C flag
	411425'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 57
WARMAC	MAC	 7-Jul-;2 18:15		INTH.

						subttl	INTH.

					;;;	INTH. -- Interrupt handler.  Take care of ^C and fatal errors.
					;
					;	On trapped interrupt:
					;	If fatal error then
					;	  Abort.
					;	(If we get this far the interrupt must have been ^C.)
					;	Decrement CCFLG (sets it to TRUE if it was FALSE).
					;	If CCFLG < -10 then
					;	  Something must be wrong, so abort.
					;	Re-enable interrupt handler.
					;	If not already processing ^C interrupt then
					;	  Set ^C process flag.
					;	  Save the ACs.
					;	  If INCHWL instruction was interrupted then
					;	    Store ^C in character address (as if input had returned ^C).
					;	    Set interrupted PC to continue at instruction following the
					;	    input instruction.
					;	  Else if HIBER instr with wake on input selected was interrupted then
					;	    Set PC to continue at normal return from HIBER (satisfy input
					;	    ready condition).
					;	  Else if a trap routine is selected then
					;	    Execute the trap routine.
					;	  Restore the ACs.
					;	  Clear ^C process flag.
					;	Continue execution at the interrupted PC.
					;
	411426'				inth.:
	411426'	261 17 0 00 001777'		push	p,intadr	;set up stack with PC at time of interrupt
	411427'	335 00 0 00 000140'		skipge	ccflg.		; if already working on ^C
						  jrst	[setzm	intadr
	411430'	254 00 0 00 415677'			 popj	p,]
	411431'	476 00 0 00 000140'		setom	ccflg.		; cleared by GTKN. call
	411432'	476 00 0 00 000000#		setom	ccflg
	411433'	332 00 0 00 000000#		skipe	inwait		; if waiting for input
	411434'	350 00 0 17 000000 		aos	0(p)		; then don't continue with the inchwl
	411435'	402 00 0 00 001777'		setzm	intadr
	411436'	336 00 0 00 002003'		skipn	trpadr		; if a ^C trap processor given
	411437'	263 17 0 00 000000 		  popj	p,		; then do something about it
	411440'	352 00 0 00 002002'		aose	intflg		; if already processing ^C
	411441'	263 17 0 00 000000 		  popj	p,		; then don't do it again
	411442'	202 00 0 00 002004'		movem	0,savr+0	;save AC0 to AC16
	411443'	200 00 0 00 415701'		move	0,[1,,savr+1]
	411444'	251 00 0 00 002022'		blt	0,savr+16
	411445'	332 01 0 00 002003'		skipe	t1,trpadr	; safety first!
	411446'	260 17 0 01 000000 		pushj	p,(t1)		; do it
	411447'	200 16 0 00 415702'		move	16,[savr+0,,0]	;restore AC0 to AC16
	411450'	251 16 0 00 000016 		blt	16,16
	411451'	476 00 0 00 002002'		setom	intflg		;finished processing ^C interrupt
	411452'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 58
WARMAC	MAC	 7-Jul-;2 18:15		ABORT

						subttl	ABORT

					;;;	ABORT -- If you have to leave the hard way, at least die gracefully.
					;
					;	(Doesn't really do all of this yet)
					;	If we got this far, the high segment must be bashed, so:
					;	Rename high segment to itself to remove it from the swapper.
					;	Set ENDFLG to true so all players will die on their next turn.
					;	Issue message to all players.
					;	Log the error.
					;	Exit.
					;
	411453'	336 00 0 00 000000#	abort:	skipn	hungup
						outstr	[asciz "
					The center of the galaxy has exploded!
					This game and all living things are
					now ended!
	411454'	051 03 0 00 415703'	"]
	411455'	200 01 0 00 002001'		move	t1,intsav	;restore only bashed AC
	411456'	336 00 0 00 000000#		skipn	hungup	
	411457'	067 00 0 00 000000 		output	tty,
	411460'	336 00 0 00 000000*		skipn	.JBDDT		;DDT loaded?
	411461'	254 00 0 00 411465'		jrst	abor.1		;no, do normal error exit
	411462'	336 00 0 00 000000#		skipn	hungup
	411463'	051 03 0 00 415726'		outstr	[asciz /CONTINUE to finish up, DDT to examine error/]
	411464'	047 01 0 00 777776 		calli	1,-2		; "silent exit"
	411465'				d.::
	411465'	260 17 0 00 411475'	abor.1:	pushj	p,kilhgh	;remove high segment from swapper
	411466'	476 00 0 00 000000#		setom	endflg		;game is over
	411467'	402 00 0 00 000000#		setzm	dispfr		;who the message is coming from
	411470'	476 00 0 00 000000#		setom	dbits		;who it's going to
						argblk	<[asciz "The center of tha galaxy has exploded!"]>^
			000000			  t..==0
						  irp 
			000001		t..==t..+1

						  movei arg,[
							    -t..,,0
							    irp 
					exp [asciz "The center of tha galaxy has exploded!"]

	411471'	201 16 0 00 415750'			    ]+1
						^
	411472'	260 17 0 00 410663'		pushj	p,makmsg
						;log error
	411473'	254 00 0 00 405556'		jrst	monit
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 59
WARMAC	MAC	 7-Jul-;2 18:15		KILHGH/KILLOW

						subttl	KILHGH/KILLOW

					;to fix---drforbin-
					;;;	KILHGH -- Remove DECWAR high segment from the swapper.
					;
						entry	kilhgh
	411474'	53 51 54 50 47 50 		sixbit	/KILHGH/
	411475'	332 00 0 00 000000#	kilhgh:	skipe	dead		;high seg alread removed?
	411476'	263 17 0 00 000000 		popj	p,		;yes, don't kill it again

	411477'	400 01 0 00 000000 		setz	t1,
	411500'	200 02 0 00 000134'		move	t2,p.dev
	411501'	400 03 0 00 000000 		setz	t3,
	411502'	050 05 0 00 000001 		open	ren,t1
	411503'	254 00 0 00 411514'		  jrst	kilh.1

	411504'	200 01 0 00 000132'		move	t1,p.nam	;get name of binary file
	411505'	515 02 0 00 635062 		hrlzi	t2,'SHR'	;assume an extension of SHR
	411506'	403 03 0 00 000000 		setzb	t3,

	411507'	200 04 0 00 000133'		move	t4,p.ppn
	411510'	076 05 0 00 000001 		lookup	ren,t1
	411511'	254 00 0 00 411514'		  jrst	kilh.1

	411512'	200 04 0 00 000133'		move	t4,p.ppn
	411513'	055 05 0 00 000001 		rename	ren,t1		;remove high segment from swapper
	411514'				kilh.1:	  warn	<Can't remove DECWAR high segment from swapper>,kilh.2^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't remove DECWAR high segment from swapper>^
						  asciz `%Can't remove DECWAR high segment from swapper
					`
						^]
							jrst kilh.2
	411514'	254 00 0 00 415763'			]
						^
						movei	p1,[ascil <[DECWAR high segment removed from swapper]>^
						  asciz `[DECWAR high segment removed from swapper]
					`
	411515'	201 12 0 00 415770'		^]
	411516'	260 17 0 00 406710'		pushj	p,ostr.
	411517'	476 00 0 00 000000#		setom	dead
	411520'	336 00 0 00 000000#		skipn	hungup
	411521'	067 00 0 00 000000 		output	tty,
	411522'	255 00 0 00 000000 		jfcl
	411523'	263 17 0 00 000000 	kilh.2:	popj	p,


					;;;	KILLOW -- Get rid of once only low segment code (SETUP, etc.)
					;	and fix up the start address to do a RUN on DECWAR.
					;
						extern	a		;kill everything after this dummy subroutine
						entry	killow
	411524'	53 51 54 54 57 67 		sixbit	/KILLOW/
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 59-1
WARMAC	MAC	 7-Jul-;2 18:15		KILHGH/KILLOW

	411525'	332 00 0 00 411460*	killow:	skipe	.JBDDT		;DDT loaded?
	411526'	263 17 0 00 000000 		popj	p,		;yes, don't wipe out DDT

	411527'	201 01 0 00 411536'		movei	t1,start
	411530'	542 01 0 00 405560*		hrrm	t1,.JBSA	;on a START do a RUN instead
	411531'	201 01 0 00 000000*		movei	t1,a
	411532'	202 01 0 00 406030*		movem	t1,.JBFF
	411533'	047 01 0 00 000011 		core	t1,		;get rid of once only code
						  warn	<Can't remove once only code>^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't remove once only code>^
						  asciz `%Can't remove once only code
					`
						^]
							jrst .+1
	411534'	254 00 0 00 416010'			]
						^
	411535'	263 17 0 00 000000 		popj	p,

	411536'	200 01 0 00 000134'	start::	move	t1,p.dev
	411537'	202 01 0 00 001767'		movem	t1,tmp+0	;device
	411540'	200 01 0 00 000132'		move	t1,p.nam
	411541'	202 01 0 00 001770'		movem	t1,tmp+1	;name
	411542'	402 00 0 00 001771'		setzm	tmp+2		;extension
	411543'	402 00 0 00 001772'		setzm	tmp+3
	411544'	200 01 0 00 000133'		move	t1,p.ppn
	411545'	202 01 0 00 001773'		movem	t1,tmp+4	;PPN
	411546'	402 00 0 00 001774'		setzm	tmp+5		;core
	411547'	201 01 0 00 001767'		movei	t1,tmp
	411550'	254 00 0 00 002051'		jrst	rundec		;go run the game (from the low segment)
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 60
WARMAC	MAC	 7-Jul-;2 18:15		DEBUG

						subttl	DEBUG

						extern	unkcom,forhlp

						entry	timin,timout
	411551'	64 51 55 51 56 00 		sixbit	/TIMIN/
	411552'	260 17 0 00 411574'	timin:	pushj	p,timsrc	; find index in TIMNAM
	411553'	202 01 0 02 000472'		movem	t1,timlcn(t2)	; save name locally
	411554'	047 01 0 00 777570 		calli	t1,-210		; get UCT
	411555'	400 01 0 00 000000 		  setz	t1,
	411556'	202 01 0 02 000410'		movem	t1,timsta(t2)
	411557'	263 17 0 00 000000 		popj	p,

	411560'	64 51 55 57 65 64 		sixbit	/TIMOUT/
	411561'	260 17 0 00 411574'	timout:	pushj	p,timsrc	; get index
	411562'	312 01 0 02 000472'		came	t1,timlcn(t2)	; if not same name
	411563'	263 17 0 00 000000 		popj	p,		; forget it this time!
	411564'	350 00 0 02 000000#		aos	timcnt(t2)	; bump total count
	411565'	047 01 0 00 777570 		calli	t1,-210		; get current time
	411566'	400 01 0 00 000000 		  setz	t1,
	411567'	274 01 0 02 000410'		sub	t1,timsta(t2)	; t1 = unitics
	411570'	272 01 0 02 000000#		addm	t1,timtot(t2)
	411571'	313 01 0 02 000000#		camle	t1,timhi(t2)
	411572'	202 01 0 02 000000#		movem	t1,timhi(t2)
	411573'	263 17 0 00 000000 		popj	p,

	411574'	200 01 1 16 000000 	timsrc:	move	t1,@0(arg)	; search for the timer name
	411575'	201 02 0 00 000061 		movei	t2,^d49
	411576'	316 01 0 02 000000#		camn	t1,timnam(t2)
	411577'	263 17 0 00 000000 		popj	p,
	411600'	332 00 0 02 000000#		skipe	timnam(t2)
	411601'	367 02 0 00 411576'		sojg	t2,.-3
	411602'	336 00 0 00 000002 		skipn	t2
	411603'	200 01 0 00 416015'		move	t1,[asciz '?????']
	411604'	202 01 0 02 000000#		movem	t1,timnam(t2)
	411605'	402 00 0 02 000000#		setzm	timhi(t2)
	411606'	263 17 0 00 000000 		popj	p,
						entry	debug
	411607'	44 45 42 65 47 00 		sixbit	/DEBUG/
	411610'	335 00 0 00 000000#	debug:	skipge	pasflg		;has the user supplied the password?
	411611'	254 00 0 00 411617'		jrst	deb.1		;yes, he's ok
	411612'	201 12 0 00 000000*		movei	p1,unkcom	;"Unknown command"
	411613'	260 17 0 00 406710'		pushj	p,ostr.
	411614'	201 12 0 00 000000*		movei	p1,forhlp	;" -- for help type HELP"
	411615'	260 17 0 00 406710'		pushj	p,ostr.
	411616'	263 17 0 00 000000 		popj	p,

	411617'				deb.1:		; display the timers
						outstr	[asciz "
					Name	Calls	Total	High

	411617'	051 03 0 00 416017'	"]
	411620'	201 05 0 00 000061 		movei	x1,^d49
	411621'	336 00 0 05 000000#	deb.2:	skipn	timnam(x1)
	411622'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 60-1
WARMAC	MAC	 7-Jul-;2 18:15		DEBUG

	411623'	200 01 0 05 000000#		move	t1,timnam(x1)
	411624'	400 02 0 00 000000 		setz	t2,
	411625'	051 03 0 00 000001 		outstr	t1
	411626'	051 01 0 00 416025'		outchr	[11]
	411627'	200 01 0 05 000000#		move	t1,timcnt(x1)
	411630'	260 17 0 00 412113'		pushj	p,debdec
	411631'	051 01 0 00 416025'		outchr	[11]
	411632'	200 01 0 05 000000#		move	t1,timtot(x1)
	411633'	221 01 0 00 250600 		imuli	t1,^d60*^d60*^d24
	411634'	557 00 0 00 000001 		hlrzs	t1
	411635'	260 17 0 00 412113'		pushj	p,debdec
	411636'	051 01 0 00 416025'		outchr	[11]
	411637'	200 01 0 05 000000#		move	t1,timhi(x1)
	411640'	221 01 0 00 250600 		imuli	t1,^d60*^d60*^d24
	411641'	557 00 0 00 000001 		hlrzs	t1
	411642'	260 17 0 00 412113'		pushj	p,debdec
						outstr	[asciz "
	411643'	051 03 0 00 415137'	"]
	411644'	364 05 0 00 411621'		soja	x1,deb.2


WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 61
WARMAC	MAC	 7-Jul-;2 18:15		EQUAL

						subttl	EQUAL

					;;;	EQUAL -- compare equality of 2 strings.  The case of the characters
					;	doesn't matter.  Either null, space, or 5 characters is end of string.
					;
					;		v = EQUAL (str1,str2)
					;
					;	If str1 is exactly equal to str2, v is -2.
					;	If str1 is a substring of str2, v is -1.
					;	If str1 doesn't match str2 at all, v is 0.
					;
						entry	equal
	411645'	45 61 65 41 54 00 		sixbit	/EQUAL/
	411646'				equal:	save	<p1,p2>^
						  xlist
						  list
						^
	411650'	201 12 1 16 000000 		movei	p1,@0(arg)	;pointer to substring string
	411651'	201 13 1 16 000001 		movei	p2,@1(arg)	;pointer to master string
	411652'	260 17 0 00 411662'		pushj	p,equal.
						restor	<p2,p1>^
						  xlist
						  list
						^
	411661'	263 17 0 00 000000 		popj	p,

	411662'				equal.:	save	<p1,p2,c>^
						  xlist
						  list
						^
	411665'	505 12 0 00 440700 		hrli	p1,(point 7)
	411666'	505 13 0 00 440700 		hrli	p2,(point 7)
	411667'	200 01 0 00 000012 		move	t1,p1
	411670'	134 11 0 00 000001 		ildb	c,t1		;get first char of substring
	411671'	302 11 0 00 000000 		caie	c,000		;null?
	411672'	306 11 0 00 000040 		cain	c,040		;or space?
	411673'	254 00 0 00 411720'		jrst	equa.4		;yes; null substring always returns not equal

	411674'	201 01 0 00 000005 		movei	t1,5		;check at most 5 characters
	411675'	134 11 0 00 000012 	equa.1:	ildb	c,p1		;get char from substring
	411676'	302 11 0 00 000000 		caie	c,000		;null?
	411677'	306 11 0 00 000040 		cain	c,040		;or space?
	411700'	254 00 0 00 411712'		jrst	equa.2		;yes, no differences encountered
	411701'	303 00 0 00 000137 		caile	t0,137		;lower case?
	411702'	620 00 0 00 000040 		trz	t0,040		;yes, convert to upper case
	411703'	134 00 0 00 000013 		ildb	t0,p2		;get char from master string
	411704'	303 00 0 00 000137 		caile	t0,137		;lower case?
	411705'	620 00 0 00 000040 		trz	t0,040		;yes, convert to upper case
	411706'	302 00 0 11 000000 		caie	t0,(c)		;same?
	411707'	254 00 0 00 411720'		jrst	equa.4		;no, strings aren't equal
	411710'	367 01 0 00 411675'		sojg	t1,equa.1	;check remaining characters
	411711'	254 00 0 00 411716'		jrst	equa.3		;strings are equal

	411712'	211 00 0 00 000001 	equa.2:	movni	t0,1		;end of 1st string; assume substring match
	411713'	134 11 0 00 000013 		ildb	c,p2		;get next char from master string
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 61-1
WARMAC	MAC	 7-Jul-;2 18:15		EQUAL

	411714'	302 11 0 00 000000 		caie	c,000		;null?
	411715'	306 11 0 00 000040 		cain	c,040		;or space?
	411716'	211 00 0 00 000002 	equa.3:	movni	t0,2		;yes, exact match
	411717'	254 00 0 00 411721'		jrst	.+2
	411720'	400 00 0 00 000000 	equa.4:	setz	t0,		;strings aren't equal
						restor	<c,p2,p1>^
						  xlist
						  list
						^
	411732'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 62
WARMAC	MAC	 7-Jul-;2 18:15		LDIS

						subttl	LDIS

					;;;	LDIS(v1,h1,v2,h2,n) is TRUE if
					;	(v1,h1) is within n sectors of (v2,h2).
					;
						entry	ldis
	411733'	54 44 51 63 00 00 		sixbit	/LDIS/
	411734'	200 01 1 16 000000 	ldis:	move	t1,@0(arg)	;get vertical coordinate of first point
	411735'	274 01 1 16 000002 		sub	t1,@2(arg)	;get distance from second point
	411736'	214 01 0 00 000001 		movm	t1,t1
	411737'	313 01 1 16 000004 		camle	t1,@4(arg)	;within range?
	411740'	254 00 0 00 411745'		jrst	ldis.1		;no
	411741'	200 01 1 16 000001 		move	t1,@1(arg)	;get horizontal coordinate of first point
	411742'	274 01 1 16 000003 		sub	t1,@3(arg)	;get distance from second point
	411743'	214 01 0 00 000001 		movm	t1,t1
	411744'	313 01 1 16 000004 		camle	t1,@4(arg)	;within range?
	411745'	634 00 0 00 000000 	ldis.1:	tdza	0,0		;no, return FALSE
	411746'	474 00 0 00 000000 		seto	0,		;yes, return TRUE
	411747'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 63
WARMAC	MAC	 7-Jul-;2 18:15		INGAL

						subttl	INGAL

					;;;	INGAL(v,h) is TRUE if
					;	(v,h) is a legal coordinate (if it's in the "galaxy").
					;
						entry	ingal
	411750'	51 56 47 41 54 00 		sixbit	/INGAL/
	411751'	333 01 1 16 000000 	ingal:	skiple	t1,@0(arg)	;vertical coordinate too small?
	411752'	303 01 0 00 000113 		caile	t1,KGALV	;or too big?
	411753'	254 00 0 00 411756'		jrst	inga.1		;yes
	411754'	333 01 1 16 000001 		skiple	t1,@1(arg)	;horizontal coordinate too small?
	411755'	303 01 0 00 000113 		caile	t1,KGALH	;or too big?
	411756'	634 00 0 00 000000 	inga.1:	tdza	0,0		;yes, return FALSE
	411757'	474 00 0 00 000000 		seto	0,		;no, return TRUE
	411760'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 64
WARMAC	MAC	 7-Jul-;2 18:15		PDIST

						subttl	PDIST

					;;;	PDIST(v1,h1,v2,h2) = distance between points (v1,h1) and (v2,h2).
					;
						entry	pdist
	411761'	60 44 51 63 64 00 		sixbit	/PDIST/
	411762'	200 00 1 16 000000 	pdist:	move	t0,@0(arg)	;get vertical coordinate of first point
	411763'	274 00 1 16 000002 		sub	t0,@2(arg)	;get distance from second point
	411764'	214 00 0 00 000000 		movm	t0,t0
	411765'	200 01 1 16 000001 		move	t1,@1(arg)	;get horizontal coordinate of first point
	411766'	274 01 1 16 000003 		sub	t1,@3(arg)	;get distance from second point
	411767'	214 01 0 00 000001 		movm	t1,t1
	411770'	305 00 0 01 000000 		caige	t0,(t1)		;horizontal distance > vertical distance?
	411771'	201 00 0 01 000000 		movei	t0,(t1)		;yes, use horizontal distance instead
	411772'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 65
WARMAC	MAC	 7-Jul-;2 18:15		LOCK/LOCK./UNLOCK/UNLO.

						subttl	LOCK/LOCK./UNLOCK/UNLO.

					;;;	LOCK -- lock a critical data area (don't let anyone else write
					;	into it until you're done).
					;
					;		CALL LOCK (key,str)
					;
					;	where key is a high segment variable unique to the data area
					;	being protected, and str is a string to output (generally the
					;	name of the routine that called LOCK) when the lock is broken
					;	(the lock is broken if it has to try too many times to access
					;	the data -- it is assumed that somebody set the lock and didn't
					;	clear it for some reason after they were done).
					;
						entry	lock
	411773'	54 57 43 53 00 00 		sixbit	/LOCK/
	411774'				lock:

	411774'	551 01 1 16 000000 		hrrzi	t1,@0(arg)	;address of key
	411775'	202 01 0 00 000356'		movem	t1,locked


					;;;	LOCK. -- same as LOCK, but input is T1: str,,key
					;
	411776'				lock.:
	411776'	402 00 0 00 000000#		setzm	lkfail		; no failure
	411777'	402 00 0 00 000007'		setzm	hv.lok	; set to -1 if psi gets interrupt
	412000'	405 01 0 00 777777 		andi	t1,777777	; mask off possible trash
	412001'	201 02 0 00 000023 		movei	t2,knloks-1	; see if this lock already active
	412002'	312 01 0 02 000363'		came	t1,loktab(t2)
	412003'	365 02 0 00 412002'		sojge	t2,.-1
	412004'	331 00 0 00 000002 		skipl	t2		; if already locked by us,
	412005'	254 00 0 00 412026'		jrst	lock.3
	412006'	201 02 0 00 000023 		movei	t2,knloks-1	; scan for empty slot
	412007'	332 00 0 02 000363'		skipe	loktab(t2)
	412010'	365 02 0 00 412007'		sojge	t2,.-1
	412011'	335 00 0 00 000002 		skipge	t2		; if full
	412012'	200 00 0 00 200000 		move	t0,200000	; then take a fatal error trap right now!
	412013'	202 01 0 02 000363'		movem	t1,loktab(t2)	; remember this lock!
	412014'	542 01 0 00 002056'		hrrm	t1,queuen	; set up enq. code
	412015'	542 01 0 00 002054'		hrrm	t1,quereq
	412016'	200 02 0 00 000000#		move	t2,gameno
	412017'	302 01 0 00 000000#		caie	t1,frelok
	412020'	306 01 0 00 405204'		cain	t1,staupd		; all universes update same files
	412021'	400 02 0 00 000000 		setz	t2,
	412022'	137 02 0 00 416045'		dpb	t2,[point 6,queuen,17]
	412023'	200 02 0 00 416046'	lock.5:	move	t2,[2,,queue]	; get the queue or return
	412024'	047 02 0 00 000151 		enq.	t2,
	412025'	254 00 0 00 412027'		jrst	lock.0
	412026'				lock.3:
	412026'	263 17 0 00 000000 		popj	p,


	412027'				lock.0:
	412027'	302 02 0 00 000001 		caie	t2,1		; if not busy resourse
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 65-1
WARMAC	MAC	 7-Jul-;2 18:15		LOCK/LOCK./UNLOCK/UNLO.

						jrst	[caie	t2,13	; then if not out of memory
							 jrst	[outstr	[asciz "
					Fatal ENQ. error code "]
								 move	t1,t2		; report the error code
								 pushj	p,debdec
								 jrst	monit		; exit stage left!
								]
							 movei	t2,^d1000		; hibernate a second
							 hiber	t2,
							  jfcl
							 jrst	lock.5			; and try once again
	412030'	254 00 0 00 416060'			]
	412031'	201 02 0 00 000144 		movei	t2,^d100	; in case input waiting has awakwned us
	412032'	047 02 0 00 000072 		hiber	t2,
	412033'	255 00 0 00 000000 		  jfcl
	412034'	047 01 0 00 777570 		calli	t1,-210		; get uct
	412035'	400 01 0 00 000000 		  setz	t1,
	412036'	402 00 0 00 000000#		setzm	ccflg		; no ^C seen
	412037'	402 00 0 00 000140'		setzm	ccflg.
	412040'	271 01 0 00 000014 		addi	t1,^d4*3	; about 4 seconds
	412041'	201 02 0 00 011610 		movei	t2,^d5000	; hibernate for five seconds
	412042'	047 02 0 00 000072 	lock.1:	hiber	t2,
	412043'	255 00 0 00 000000 		  jfcl
	412044'	332 00 0 00 000007'		skipe	hv.lok	; if request has been granted,
	412045'	254 00 0 00 412026'		jrst	lock.3		; then exit
	412046'	047 02 0 00 777570 		calli	t2,-210		; get current UCT
	412047'	201 02 0 00 023420 		  movei	t2,^d10000	; force exit if failed
	412050'	315 02 0 00 000001 		camge	t2,t1
						jrst	[movei	t2,^d1000	; hibernate extra second
	412051'	254 00 0 00 416066'			 jrst	lock.1]
					;--	skipn	pasflg		; if debugger is running
					;--	jrst	lock.4
						outstr	[asciz "
	412052'	051 03 0 00 416070'	**** Lockup on queue "]
	412053'	550 01 0 00 002056'		hrrz	t1,queuen
	412054'	260 17 0 00 414723'		pushj	p,fndlok
	412055'	405 01 0 00 000077 		andi	t1,77
	412056'	271 01 0 00 000040 		addi	t1,40
	412057'	336 00 0 00 000000#		skipn	hungup
	412060'	051 01 0 00 000001 		outchr	t1
	412061'	336 00 0 00 000000#		skipn	hungup
	412062'	051 03 0 00 416075'		outstr	[asciz " by job "]
	412063'	201 01 0 00 002053'		movei	t1,queue	; get job number that has the lock
	412064'	201 02 0 00 000360'		movei	t2,whohas
	412065'	047 01 0 00 000153 		enqc.	t1,
	412066'	402 00 0 00 000360'		  setzm	whohas
	412067'	550 01 0 00 000360'		hrrz	t1,whohas
	412070'	306 01 0 00 777777 		cain	t1,-1
	412071'	400 01 0 00 000000 		setz	t1,
	412072'	260 17 0 00 412113'		pushj	p,debdec
	412073'	336 00 0 00 000000#		skipn	hungup
						outstr	[asciz "
	412074'	051 03 0 00 415137'	"]
					;--lock.4:	skipn	ccflg		; if user got tired and hit ^C
	412075'	254 00 0 00 412027'		jrst	lock.0		; then
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 65-2
WARMAC	MAC	 7-Jul-;2 18:15		LOCK/LOCK./UNLOCK/UNLO.

	412076'	550 01 0 00 002056'		hrrz	t1,queuen	; release our claim
	412077'	260 17 0 00 412142'		pushj	p,unlo.
	412100'	476 00 0 00 000000#		setom	lkfail		; tell caller we failed
	412101'	254 00 0 00 412026'		jrst	lock.3

	412102'	231 01 0 00 000010 	deboct:	idivi	t1,8
	412103'	506 02 0 17 000000 		hrlm	t2,0(p)
	412104'	332 00 0 00 000001 		skipe	t1
	412105'	260 17 0 00 412102'		pushj	p,deboct
	412106'	554 01 0 17 000000 	debcom:	hlrz	t1,0(p)
	412107'	271 01 0 00 000060 		addi	t1,"0"
	412110'	336 00 0 00 000000#		skipn	hungup
	412111'	051 01 0 00 000001 		outchr	t1
	412112'	263 17 0 00 000000 		popj	p,

	412113'	231 01 0 00 000012 	debdec:	idivi	t1,^d10
	412114'	506 02 0 17 000000 		hrlm	t2,0(p)
	412115'	332 00 0 00 000001 		skipe	t1
	412116'	260 17 0 00 412113'		pushj	p,debdec
	412117'	254 00 0 00 412106'		jrst	debcom





					;;;	UNLOCK -- make a data area available to other jobs again (after
					;	a lock to that area).
					;
					;		CALL UNLOCK (key)
					;
						entry	unlock
	412120'	65 56 54 57 43 53 		sixbit	/UNLOCK/
	412121'				unlock:
	412121'	201 01 1 16 000000 		movei	t1,@0(arg)
	412122'	402 00 0 00 000356'		setzm	locked
	412123'	260 17 0 00 412142'		pushj	p,unlo.
	412124'	263 17 0 00 000000 		popj	p,



					;;;	UNLO. -- same as lock, but input is T1: key
					;
	412125'				kilall::		; kill all current locks outstanding
	412125'	261 17 0 00 000006 		push	p,x2
	412126'	201 06 0 00 000023 		movei	x2,knloks-1
	412127'	332 01 0 06 000363'		skipe	t1,loktab(x2)
	412130'	260 17 0 00 412142'		pushj	p,unlo.
	412131'	365 06 0 00 412127'		sojge	x2,.-2
	412132'	262 17 0 00 000006 		pop	p,x2
	412133'	263 17 0 00 000000 		popj	p,

	412134'	72 41 60 54 57 53 		sixbit /zaplok/
	412135'				zaplok::
	412135'	201 06 0 00 000023 		movei	x2,knloks-1	; remove all queue entries
	412136'	332 01 0 06 000363'		skipe	t1,loktab(x2)
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 65-3
WARMAC	MAC	 7-Jul-;2 18:15		LOCK/LOCK./UNLOCK/UNLO.

	412137'	260 17 0 00 412142'		pushj	p,unlo.		; unlock this one
	412140'	365 06 0 00 412136'		sojge	x2,.-2
	412141'	263 17 0 00 000000 		popj	p,

	412142'				unlo.:
	412142'	542 01 0 00 002056'		hrrm	t1,queuen
	412143'	542 01 0 00 002054'		hrrm	t1,quereq
	412144'	201 02 0 00 000023 		movei	t2,knloks-1
	412145'	405 01 0 00 777777 		andi	t1,777777
	412146'	312 01 0 02 000363'		came	t1,loktab(t2)
	412147'	365 02 0 00 412146'		sojge	t2,.-1
	412150'	331 00 0 00 000002 		skipl	t2
	412151'	402 00 0 02 000363'		setzm	loktab(t2)
	412152'	200 02 0 00 000000#		move	t2,gameno		; include game # in lock
	412153'	302 01 0 00 000000#		caie	t1,frelok
	412154'	306 01 0 00 405204'		cain	t1,staupd		; this one is universal
	412155'	400 02 0 00 000000 		setz	t2,
	412156'	137 02 0 00 416045'		dpb	t2,[point 6,queuen,17]
	412157'	201 02 0 00 002053'		movei	t2,queue
	412160'	047 02 0 00 000152 		deq.	t2,
	412161'	306 02 0 00 000024 		cain	t2,24		; = "you don't have it dummy" error code
	412162'	263 17 0 00 000000 		popj	p,
						outstr	[asciz "
	412163'	051 03 0 00 416077'	Failure "]
	412164'	260 17 0 00 412102'		pushj	p,deboct
	412165'	051 03 0 00 416102'		outstr	[asciz " releasing "]
	412166'	550 01 0 00 002056'		hrrz	t1,queuen
	412167'	260 17 0 00 414723'		pushj	p,fndlok
	412170'	405 01 0 00 000077 		andi	t1,77
	412171'	271 01 0 00 000040 		addi	t1,40
	412172'	336 00 0 00 000000#		skipn	hungup
	412173'	051 01 0 00 000001 		outchr	t1
	412174'	336 00 0 00 000000#		skipn	hungup
						outstr	[asciz "
	412175'	051 03 0 00 415137'	"]
	412176'	263 17 0 00 000000 		popj	p,


WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 66
WARMAC	MAC	 7-Jul-;2 18:15		NEWS

						subttl	NEWS

					;;;	NEWS -- Display the DECWAR news file.
					;
						entry	news
	412177'	56 45 67 63 00 00 		sixbit	/NEWS/
	412200'				news:	save	<x1,x2,x3>^
						  xlist
						  list
						^
	412203'	553 00 0 00 000000*		hrrzs	.jbren##
	412204'	201 05 0 00 405112'		movei	x1,nwsfil
	412205'	260 17 0 00 405725'		pushj	p,open.		;open DECWAR.NWS for input
						  warn	<Can't read DECWAR.NWS>,news.5^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't read DECWAR.NWS>^
						  asciz `%Can't read DECWAR.NWS
					`
						^]
							jrst news.5
	412206'	254 00 0 00 416112'			]
						^
	412207'	260 17 0 00 406060'		pushj	p,seti.		;set up for input from news file

	412210'	400 07 0 00 000000 	news.1:	setz	x3,		;last char wasn't eol
	412211'	260 17 0 00 406150'	news.2:	pushj	p,ichr.		;get char from news file
	412212'	321 11 0 00 412246'		jumpl	c,news.4	;eof
	412213'	322 07 0 00 412215'		jumpe	x3,.+2		;last char was eol?
	412214'	302 11 0 00 000056 		caie	c,"."		;and this char is "."?
	412215'	254 00 0 00 412231'		jrst	news.3		;no, keep going

	412216'	260 17 0 00 405717'		pushj	p,ttyon		;clear ^O
	412217'	201 12 0 00 416117'		movei	p1,[asciz /Do you want to continue viewing the news file? /]
	412220'	260 17 0 00 406710'		pushj	p,ostr.
	412221'	260 17 0 00 406060'		pushj	p,seti.		;set up for input from TTY
	412222'	260 17 0 00 406200'		pushj	p,gtkn
	412223'	260 17 0 00 406060'		pushj	p,seti.		;set up for input from news file
	412224'	201 12 0 00 000000#		movei	p1,tknlst+0
	412225'	201 13 0 00 416131'		movei	p2,[asciz /YES/]
	412226'	260 17 0 00 411662'		pushj	p,equal.
	412227'	321 00 0 00 412210'		jumpl	t0,news.1	;yes
	412230'	254 00 0 00 412246'		jrst	news.4		;no, done

	412231'	260 17 0 00 406077'	news.3:	pushj	p,ochr.		;echo character
	412232'	301 11 0 00 000012 		cail	c,012
	412233'	303 11 0 00 000014 		caile	c,014
	412234'	254 00 0 00 412210'		jrst	news.1		;not eol
	412235'	474 07 0 00 000000 		seto	x3,		;eol
	412236'	336 00 0 00 000000#		skipn	ccflg		;^C was typed?
	412237'	335 00 0 00 412203*		skipge	.jbren##	; or ^P?
	412240'	254 00 0 00 412246'		jrst	news.4		;yes, quit
	412241'	336 01 0 00 000000#		skipn	t1,who		;is player in game yet?
	412242'	254 00 0 00 412211'		jrst	news.2		;no
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 66-1
WARMAC	MAC	 7-Jul-;2 18:15		NEWS

	412243'	335 00 0 01 000000#		skipge	alive-1(t1)	;alive?
	412244'	402 00 0 01 000000#		setzm	active-1(t1)	;yes, don't count as idle during news output
	412245'	254 00 0 00 412211'		jrst	news.2

	412246'	402 00 0 00 000000#	news.4:	setzm	ccflg		;in case exit because of ^C
	412247'	553 00 0 00 412237*		hrrzs	.jbren##	; or ^P
	412250'	260 17 0 00 406021'		pushj	p,close.	;close news file
	412251'	260 17 0 00 406060'		pushj	p,seti.		;restore original input file
	412252'				news.5:	restor	<x3,x2,x1>^
						  xlist
						  list
						^
	412263'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 67
WARMAC	MAC	 7-Jul-;2 18:15		GRIPE

						subttl	GRIPE

					;;;	GRIPE -- Prompt for and read a gripe from the current input,
					;	and add the gripe to the beginning of DECWAR.GRP
					;
						entry	gripe
	412264'	47 62 51 60 45 00 		sixbit	/GRIPE/
	412265'				gripe:
	412265'	332 03 0 00 000000#		skipe	t3,who		; if user is under RED alert
						jrst	[
						 	move	t1,shpcon+<KSPCON-1>*KNPLAY-1(t3)
						 	cain	t1,red		;condition red?
							jrst	[outstr	[asciz "
					You are not permitted to GRIPE
					while under RED alert!
					"]
								 popj	p,]
	412266'	254 00 0 00 416161'			jrst	.+1]
	412267'	260 17 0 00 413265'		pushj	p,eshp.		;erase ship from board unless condition red

	412270'	200 01 0 00 411532*		move	t1,.JBFF
	412271'	202 01 0 00 001761'		movem	t1,dbuf+.BFADR	;this is where the gripe buffer starts
	412272'	505 01 0 00 440700 		hrli	t1,(point 7)
	412273'	202 01 0 00 001762'		movem	t1,dbuf+.BFPTR	;pointer to first character space in buffer
	412274'	402 00 0 00 001763'		setzm	dbuf+.BFCTR	;buffer length is currently 0

						movei	p1,[ascil <Enter gripe, end with ^Z>^
						  asciz `Enter gripe, end with ^Z
					`
	412275'	201 12 0 00 416165'		^]
	412276'	336 00 0 00 000000#		skipn	addrck		; if processing an address check, don't
	412277'	260 17 0 00 406710'		pushj	p,ostr.
	412300'	200 05 0 00 416173'		move	x1,[grpfil,,grpfil]
	412301'	260 17 0 00 406041'		pushj	p,seto.		;set up for output to gripe buffer
	412302'	260 17 0 00 407404'		pushj	p,osts.		;output status line (version, date, time, etc.)

	412303'	332 00 0 00 000000#		skipe	addrck		; if address failure
	412304'	254 00 0 00 412336'		jrst	grip.a		; then dump the information
	412305'	201 06 0 00 000024 		movei	x2,grpsiz
	412306'	275 06 0 00 000001 	grip.1:	subi	x2,1
	412307'	260 17 0 00 406431'		pushj	p,inli.		;get input line
	412310'	332 00 0 00 000000#		skipe	ccflg		;^C?
	412311'	254 00 0 00 412627'		jrst	grip.8		;yes, abort gripe
	412312'	200 12 0 00 415603'		move	p1,[point 36,linbuf]
	412313'	260 17 0 00 406711'		pushj	p,ostr.x	;add line to gripe
	412314'	602 00 0 00 000040 		trne	f,cf.eof	;eof?
	412315'	254 00 0 00 412544'		jrst	grip.2		;yes, end of gripe
	412316'	260 17 0 00 406616'		pushj	p,ocrl.		;INLI. changes all eol to nul
	412317'	332 01 0 00 000000#		skipe	t1,who		;is player in game?
	412320'	331 00 0 01 000000#		skipl	alive-1(t1)	;and alive?
	412321'	254 00 0 00 412323'		jrst	.+2		;no
	412322'	402 00 0 01 000000#		setzm	active-1(t1)	;yes, don't count as idle during GRIPE input

	412323'	400 12 0 00 000000 		setz	p1,
	412324'	306 06 0 00 000002 		cain	x2,2
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 67-1
WARMAC	MAC	 7-Jul-;2 18:15		GRIPE

						movei	p1,[ascil <[Only 2 more message lines allowed]>^
						  asciz `[Only 2 more message lines allowed]
					`
	412325'	201 12 0 00 416174'		^]
	412326'	306 06 0 00 000000 		cain	x2,0
						movei	p1,[ascil <[Too many lines -- end of gripe]>^
						  asciz `[Too many lines -- end of gripe]
					`
	412327'	201 12 0 00 416204'		^]
	412330'	322 12 0 00 412306'		jumpe	p1,grip.1
	412331'	260 17 0 00 406041'		pushj	p,seto.		;restore output to tty
	412332'	260 17 0 00 406710'		pushj	p,ostr.		;output message
	412333'	260 17 0 00 406041'		pushj	p,seto.		;restore output to gripe file
	412334'	326 06 0 00 412306'		jumpn	x2,grip.1
	412335'	254 00 0 00 412552'		jrst	grip.3

					;;;	Here to write out the diagnostic dump from an address failure

	412336'				grip.a:
	412336'	331 00 0 00 000000#		skipl	addrck		; if doing a *Zap
	412337'	254 00 0 00 412541'		jrst	grip.z		; then write out the statistics into gripe file
						movei	p1,[asciz "**** Data out of bounds ****
					**** Command line:
	412340'	201 12 0 00 416213'	"]
	412341'	260 17 0 00 406710'		pushj	p,ostr.
	412342'	201 05 0 00 000000 		movei	x1,0
	412343'	200 11 0 05 000143'	grip.u:	move	c,linbuf(x1)
	412344'	307 11 0 00 000037 		caig	c,37		; if control char
						jrst	[movei	c,"^"	; then flag it
							 pushj	p,ochr.
							 move	c,linbuf(x1)
							 addi	c,"@"	; make ascii char
	412345'	254 00 0 00 416226'			 jrst	.+1]
	412346'	260 17 0 00 406077'		pushj	p,ochr.
	412347'	350 00 0 00 000005 		aos	x1
	412350'	305 05 0 00 000120 		caige	x1,maxcnt
	412351'	336 00 0 05 000142'		skipn	linbuf-1(x1)
	412352'	334 00 0 00 000000 		skipa
	412353'	254 00 0 00 412343'		jrst	grip.u
	412354'	260 17 0 00 406616'		pushj	p,crlf
	412355'	260 17 0 00 406616'		pushj	p,crlf
	412356'	550 05 0 00 000554'		hrrz	x1,stabuf	; = address of the bad instruction
	412357'	201 06 0 00 000006 		movei	x2,6
	412360'	260 17 0 00 412522'		pushj	p,oct.o
	412361'	260 17 0 00 406612'		pushj	p,ospc.
	412362'	260 17 0 00 406612'		pushj	p,ospc.
	412363'	200 05 0 00 000555'		move	x1,stabuf+1	; = the offending instruction
	412364'	201 06 0 00 000014 		movei	x2,^d12
	412365'	260 17 0 00 412522'		pushj	p,oct.o
	412366'	260 17 0 00 406612'		pushj	p,ospc.
	412367'	260 17 0 00 406612'		pushj	p,ospc.
	412370'	135 05 0 00 416233'		ldb	x1,[point 9,stabuf+1,8]	; output instr as: xxx xx,{@}xxxxxx{(xx)}
	412371'	201 06 0 00 000003 		movei	x2,3
	412372'	260 17 0 00 412522'		pushj	p,oct.o
	412373'	260 17 0 00 406612'		pushj	p,ospc.
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 67-2
WARMAC	MAC	 7-Jul-;2 18:15		GRIPE

	412374'	135 05 0 00 416234'		ldb	x1,[point 4,stabuf+1,12]	; = AC field
	412375'	201 06 0 00 000002 		movei	x2,2
	412376'	260 17 0 00 412522'		pushj	p,oct.o
	412377'	201 11 0 00 000054 		movei	c,","
	412400'	260 17 0 00 406077'		pushj	p,ochr.
	412401'	205 01 0 00 000020 		movsi	t1,(1b13)		; if @ bit set
	412402'	201 11 0 00 000100 		movei	c,"@"
	412403'	612 01 0 00 000555'		tdne	t1,stabuf+1	; then output "@"
	412404'	260 17 0 00 406077'		pushj	p,ochr.
	412405'	550 05 0 00 000555'		hrrz	x1,stabuf+1
	412406'	201 06 0 00 000006 		movei	x2,6
	412407'	260 17 0 00 412522'		pushj	p,oct.o
	412410'	135 05 0 00 416235'		ldb	x1,[point 4,stabuf+1,17]	; if index non zero
	412411'	322 05 0 00 412420'		jumpe	x1,grip.b	; then output (xx)
	412412'	201 11 0 00 000050 		movei	c,"("
	412413'	260 17 0 00 406077'		pushj	p,ochr.
	412414'	201 06 0 00 000002 		movei	x2,2
	412415'	260 17 0 00 412522'		pushj	p,oct.o
	412416'	201 11 0 00 000051 		movei	c,")"
	412417'	260 17 0 00 406077'		pushj	p,ochr.
	412420'	260 17 0 00 406616'	grip.b:	pushj	p,crlf
	412421'	554 05 0 00 000554'		hlrz	x1,stabuf		; = locked resource if any
	412422'	201 06 0 00 000006 		movei	x2,6
	412423'	332 00 0 00 000005 		skipe	x1
	412424'	260 17 0 00 412522'		pushj	p,oct.o
	412425'	260 17 0 00 406616'		pushj	p,crlf
	412426'	201 07 0 00 000000 		movei	x3,0		; dump the registers
	412427'	200 05 0 07 000556'	grip.c:	move	x1,stabuf+2(x3)
	412430'	201 06 0 00 000014 		movei	x2,^d12
	412431'	260 17 0 00 412522'		pushj	p,oct.o
	412432'	260 17 0 00 406612'		pushj	p,ospc.
	412433'	350 00 0 00 000007 		aos	x3
	412434'	606 07 0 00 000007 		trnn	x3,7		; if mod 8 = 0
	412435'	260 17 0 00 406616'		pushj	p,crlf		; then go to new line
	412436'	302 07 0 00 000020 		caie	x3,^d16		; if dumped 16 regs
	412437'	254 00 0 00 412427'		jrst	grip.c		; then
	412440'	260 17 0 00 406616'		pushj	p,crlf
	412441'	201 12 0 00 416236'		movei	p1,[asciz "*** PDL: "]
	412442'	260 17 0 00 406710'		pushj	p,ostr.
	412443'	201 05 0 00 000012'		movei	x1,pdl
	412444'	201 06 0 00 000006 		movei	x2,6
	412445'	260 17 0 00 412522'		pushj	p,oct.o
	412446'	260 17 0 00 406616'		pushj	p,crlf
	412447'	201 07 0 00 000000 		movei	x3,0		; dump pdl
	412450'	200 05 0 07 000012'	grip.t:	move	x1,pdl(x3)
	412451'	201 06 0 00 000014 		movei	x2,^d12
	412452'	260 17 0 00 412522'		pushj	p,oct.o
	412453'	260 17 0 00 406612'		pushj	p,ospc.
	412454'	350 00 0 00 000007 		aos	x3
	412455'	606 07 0 00 000007 		trnn	x3,7
	412456'	260 17 0 00 406616'		pushj	p,crlf
	412457'	201 01 0 07 000012'		movei	t1,pdl(x3)
	412460'	550 02 0 00 000575'		hrrz	t2,stabuf+2+17	; = rh of pdl pointer
	412461'	317 01 0 00 000002 		camg	t1,t2
	412462'	254 00 0 00 412450'		jrst	grip.t
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 67-3
WARMAC	MAC	 7-Jul-;2 18:15		GRIPE

	412463'	260 17 0 00 406616'		pushj	p,crlf

	412464'	201 12 0 00 416240'		movei	p1,[asciz "*** HITQL-1:"]
	412465'	260 17 0 00 406710'		pushj	p,ostr.
	412466'	201 05 0 00 400014'		movei	x1,hitql-1
	412467'	201 06 0 00 000006 		movei	x2,6
	412470'	260 17 0 00 412522'		pushj	p,oct.o
	412471'	260 17 0 00 406616'		pushj	p,crlf
	412472'	201 07 0 00 000001 		movei	x3,1
	412473'	200 05 0 07 400013'	griptt:	move	x1,hitql-2(x3)
	412474'	201 06 0 00 000014 		movei	x2,^d12
	412475'	260 17 0 00 412522'		pushj	p,oct.o
	412476'	260 17 0 00 406612'		pushj	p,ospc.
	412477'	606 07 0 00 000007 		trnn	x3,7
	412500'	260 17 0 00 406616'		pushj	p,crlf
	412501'	302 07 0 00 000623 		caie	x3,knhit+3
	412502'	344 07 0 00 412473'		aoja	x3,griptt
	412503'	260 17 0 00 406616'		pushj	p,crlf
	412504'	201 12 0 00 416243'		movei	p1,[asciz "*** LOKTAB:"]
	412505'	260 17 0 00 406710'		pushj	p,ostr.
	412506'	260 17 0 00 406616'		pushj	p,crlf
	412507'	201 07 0 00 000001 		movei	x3,1
	412510'	200 05 0 07 000362'	griptu:	move	x1,loktab-1(x3)
	412511'	201 06 0 00 000014 		movei	x2,^d12
	412512'	260 17 0 00 412522'		pushj	p,oct.o
	412513'	260 17 0 00 406612'		pushj	p,ospc.
	412514'	606 07 0 00 000007 		trnn	x3,7
	412515'	260 17 0 00 406616'		pushj	p,crlf
	412516'	302 07 0 00 000024 		caie	x3,knloks
	412517'	344 07 0 00 412510'		aoja	x3,griptu
	412520'	260 17 0 00 406616'		pushj	p,crlf
	412521'	254 00 0 00 412552'		jrst	grip.3		;	copy to gripe file

	412522'				oct.o:	save	<[-1]>^
						  xlist
						  list
						^
	412523'	200 01 0 00 000005 		move	t1,x1
	412524'	550 02 0 00 000001 	oct.01:	hrrz	t2,t1
						save <t2>^
						  xlist
						  list
						^
	412526'	242 01 0 00 777775 		lsh	t1,-3
	412527'	367 06 0 00 412524'		sojg	x2,oct.01
	412530'				oct.02:	restore <c>^
						  xlist
						  list
						^
	412533'	335 00 0 00 000011 		skipge	c
	412534'	263 17 0 00 000000 		popj	p,
	412535'	405 11 0 00 000007 		andi	c,7
	412536'	271 11 0 00 000060 		addi	c,"0"
	412537'	260 17 0 00 406077'		pushj	p,ochr.
	412540'	254 00 0 00 412530'		jrst	oct.02
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 67-4
WARMAC	MAC	 7-Jul-;2 18:15		GRIPE


	412541'	201 16 0 00 416252'	grip.z:	movei	arg,[[1]]
	412542'	260 17 0 00 414145'		pushj	p,shosta		; display to gripe buffer
	412543'	254 00 0 00 412552'		jrst	grip.3

	412544'	306 06 0 00 000023 	grip.2:	cain	x2,grpsiz-1	;any full lines entered?
	412545'	332 00 0 00 000143'		skipe	linbuf		;no, any chars on the first line?
	412546'	254 00 0 00 412550'		jrst	.+2		;yes, record gripe
	412547'	254 00 0 00 412627'		jrst	grip.8		;no, empty gripe; abort
	412550'	332 00 0 00 000143'		skipe	linbuf		;last line is blank?
	412551'	260 17 0 00 406616'		pushj	p,ocrl.		;no, end it with <CR><LF>
	412552'	201 12 0 00 416253'	grip.3:	movei	p1,[asciz /----------/]
	412553'	260 17 0 00 406710'		pushj	p,ostr.
	412554'	260 17 0 00 406616'		pushj	p,ocrl.
	412555'	200 06 0 00 001762'		move	x2,dbuf+.BFPTR	;address of word containing last gripe char
	412556'	505 06 0 06 000000 		hrli	x2,(x2)

	412557'	200 05 0 00 416173'	grip.4:	move	x1,[grpfil,,grpfil]
	412560'	260 17 0 00 405725'		pushj	p,open.		;open DECWAR.GRP
	412561'	254 00 0 00 412563'		  jrst	.+2
	412562'	254 00 0 00 412575'		jrst	grip.5
	412563'	550 01 0 00 002034'		hrrz	t1,leblk+1	;see why open failed
	412564'	302 01 0 00 000003 		caie	t1,ERFBM%
						warn	<Can't write DECWAR.GRP>,grip.8^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't write DECWAR.GRP>^
						  asciz `%Can't write DECWAR.GRP
					`
						^]
							jrst grip.8
	412565'	254 00 0 00 416264'			]
						^
						warn	<DECWAR.GRP being modified; trying again>^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%DECWAR.GRP being modified; trying again>^
						  asciz `%DECWAR.GRP being modified; trying again
					`
						^]
							jrst .+1
	412566'	254 00 0 00 416302'			]
						^
	412567'	201 01 0 00 005670 		movei	t1,ntry*slptim
	412570'	047 01 0 00 000072 		hiber	t1,
	412571'	254 04 0 00 000000 		  halt
	412572'	336 00 0 00 000000#		skipn	ccflg		;^C during wait?
	412573'	254 00 0 00 412557'		jrst	grip.4		;no, try again
	412574'	254 00 0 00 412627'		jrst	grip.8		;yes, forget it

	412575'	331 04 0 00 002036'	grip.5:	skipl	t4,leblk+3	;neg length of file,,0
						jrst	[setzm	leblk+3	; force to 0 (virgin file bug)
	412576'	254 00 0 00 416307'			 jrst	grip.7]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 67-5
WARMAC	MAC	 7-Jul-;2 18:15		GRIPE

	412577'	574 01 0 00 000004 		hlre	t1,t4		;neg # of words in current gripe file
	412600'	210 01 0 00 000001 		movn	t1,t1		;make it positive
	412601'	271 06 0 01 000000 		addi	x2,(t1)		;last word of core needed to read in gripe file
	412602'	201 01 0 06 000000 		movei	t1,(x2)
	412603'	317 01 0 00 406032*		camg	t1,.JBREL	;core already allocated?
	412604'	254 00 0 00 412607'		jrst	grip.6		;yes, don't need to allocate any more
	412605'	047 01 0 00 000011 		core	t1,
						  warn	<Can't get core to read DECWAR.GRP>,grip.8^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't get core to read DECWAR.GRP>^
						  asciz `%Can't get core to read DECWAR.GRP
					`
						^]
							jrst grip.8
	412606'	254 00 0 00 416321'			]
						^

	412607'	544 04 0 00 000006 	grip.6:	hlr	t4,x2		;build IOWD word for dump mode transfer
	412610'	202 04 0 00 001767'		movem	t4,tmp		;must be in low core (not in an AC) to work
	412611'	402 00 0 00 001770'		setzm	tmp+1
	412612'	056 03 0 00 001767'		in	grp,tmp		;append old gripes to new one in core
	412613'	254 00 0 00 412615'		jrst	.+2
						  warn	<Can't read DECWAR.GRP>,grip.8^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't read DECWAR.GRP>^
						  asciz `%Can't read DECWAR.GRP
					`
						^]
							jrst grip.8
	412614'	254 00 0 00 416333'			]
						^

	412615'	200 01 0 00 001761'	grip.7:	move	t1,dbuf+.BFADR	;address of output buffer
	412616'	275 01 0 06 000001 		subi	t1,1(x2)	;neg # of words in buffer
	412617'	504 01 0 00 001761'		hrl	t1,dbuf+.BFADR	;build IOWD word for dump mode transfer
	412620'	274 01 0 00 416340'		sub	t1,[1,,0]
	412621'	206 01 0 00 001767'		movsm	t1,tmp
	412622'	402 00 0 00 001770'		setzm	tmp+1
	412623'	075 03 0 00 000001 		useto	grp,1
	412624'	057 03 0 00 001767'		out	grp,tmp		;write new gripe file
	412625'	254 00 0 00 412627'		jrst	.+2
						  warn	<Can't write DECWAR.GRP>^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't write DECWAR.GRP>^
						  asciz `%Can't write DECWAR.GRP
					`
						^]
							jrst .+1
	412626'	254 00 0 00 416341'			]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 67-6
WARMAC	MAC	 7-Jul-;2 18:15		GRIPE

						^

	412627'	200 01 0 00 001761'	grip.8:	move	t1,dbuf+.BFADR	;reduce core to here
	412630'	202 01 0 00 002024'		movem	t1,fl.ff
	412631'	260 17 0 00 406021'		pushj	p,close.	;close gripe file & deallocate buffer space
	412632'	200 05 0 00 414772'		move	x1,[ttyfil,,ttyfil]
	412633'	260 17 0 00 406041'		pushj	p,seto.		;restore original output file
	412634'	260 17 0 00 413277'		pushj	p,pshp.		;put ship back on board
	412635'	402 00 0 00 000000#		setzm	ccflg		;clear ^C flag
	412636'	263 17 0 00 000000 		popj	p,


					;;;	OGCH. -- Output character to gripe buffer.
					;
	412637'	371 00 1 00 000265'	ogch.:	sosl	@obfctr		;any room in buffer?
	412640'	324 17 0 00 406115'		pjrst	ochr.x		;yes, add character normally

	412641'	550 01 0 00 001762'		hrrz	t1,dbuf+.BFPTR	;last word used in gripe buffer
	412642'	201 02 0 01 000024 		movei	t2,^D20(t1)	;allocate another 20 words
	412643'	317 02 0 00 412603*		camg	t2,.JBREL	;already there?
	412644'	254 00 0 00 412650'		jrst	ogch.1		;yes, no need for CORE UUO
	412645'	201 03 0 02 000000 		movei	t3,(t2)
	412646'	047 03 0 00 000011 		core	t3,
						  warn	<Can't get more core>,cpopj^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't get more core>^
						  asciz `%Can't get more core
					`
						^]
							jrst cpopj
	412647'	254 00 0 00 416353'			]
						^
	412650'	202 02 0 00 412270*	ogch.1:	movem	t2,.JBFF

	412651'	402 00 0 01 000001 		setzm	1(t1)		;zero out allocated words
	412652'	201 01 0 01 000002 		movei	t1,2(t1)
	412653'	505 01 0 01 777777 		hrli	t1,-1(t1)
	412654'	251 01 0 02 000000 		blt	t1,(t2)
	412655'	201 01 0 00 000144 		movei	t1,^D20*5	;number of character spaces allocated
	412656'	202 01 0 00 001763'		movem	t1,dbuf+.BFCTR
	412657'	254 00 0 00 412637'		jrst	ogch.
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 68
WARMAC	MAC	 7-Jul-;2 18:15		HELP -- HELP

						subttl	HELP -- HELP

					;;;	HELP -- On line DECWAR help system.  Give general info, command list,
					;	and text from help file on individual commands.
					;
					;	HELP		;give general info, direct to other sources of help
					;	HELP *		;give list of commands
					;	HELP keyword	;type text associated with keyword from help file
					;
						entry	help
	412660'	50 45 54 60 00 00 		sixbit	/HELP/
	412661'				help:
	412661'	332 03 0 00 000000#		skipe	t3,who		; if user is under RED alert
						jrst	[
						 	move	t1,shpcon+<KSPCON-1>*KNPLAY-1(t3)
						 	cain	t1,red		;condition red?
							jrst	[outstr	[asciz "
					You cannot get HELP while under
					RED alert!
					"]
								 popj	p,]
							jrst	.+1
	412662'	254 00 0 00 416374'			]
	412663'	260 17 0 00 413265'		pushj	p,eshp.		;remove ship from board
	412664'	400 07 0 00 000000 		setz	x3,		;index to current modifier

	412665'	331 00 0 00 000000#		skipl	typlst+1	;any modifiers?
	412666'	254 00 0 00 412672'		jrst	help.1		;yes
	412667'	260 17 0 00 412727'		pushj	p,hlpxtr	;give general help info
	412670'	254 00 0 00 412723'		jrst	help.4

	412671'	260 17 0 00 405717'		pushj	p,ttyon		;clear ^O

	412672'	271 07 0 00 000001 	help.1:	addi	x3,1		;index to next help item
	412673'	331 00 0 07 000000#		skipl	typlst(x3)	;end of list?
	412674'	332 00 0 00 000000#		skipe	ccflg		;or ^C typed?
	412675'	254 00 0 00 412723'		jrst	help.4		;yes, done

	412676'	201 12 0 07 000000#		movei	p1,tknlst(x3)	;build pointer to next item
	412677'	201 13 0 00 415272'		movei	p2,[asciz /*/]
	412700'	260 17 0 00 411662'		pushj	p,equal.
	412701'	325 00 0 00 412704'		jumpge	t0,help.2	;not HELP *
	412702'	260 17 0 00 413012'		pushj	p,hlpall
	412703'	254 00 0 00 412672'		jrst	help.1

	412704'	331 00 0 00 000000#	help.2:	skipl	pasflg		;password set?
	412705'	334 05 0 00 416400'		skipa	x1,[<-2*<kncmd-kscmd>>,,isaydo]
	412706'	200 05 0 00 416401'		move	x1,[<-2*kncmd>,,isaydo]
	412707'	400 06 0 00 000000 		setz	x2,
	412710'	260 17 0 00 413143'		pushj	p,slst.
	412711'	254 00 0 00 412713'		  jrst	.+2
	412712'	254 00 0 00 412720'		jrst	help.3
	412713'	325 05 0 00 412672'		jumpge	x1,help.1	;ambiguous, so don't try any more
	412714'	200 05 0 00 416402'		move	x1,[<-2*knxtr>,,xhelp]
	412715'	551 06 0 00 416403'		hrrzi	x2,[asciz /I don't know the term /]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 68-1
WARMAC	MAC	 7-Jul-;2 18:15		HELP -- HELP

	412716'	260 17 0 00 413143'		pushj	p,slst.
	412717'	254 00 0 00 412672'		  jrst	help.1

	412720'	201 12 0 13 000000 	help.3:	movei	p1,(p2)
	412721'	260 17 0 00 413023'		pushj	p,shlp.		;search help file and show info
	412722'	254 00 0 00 412672'		jrst	help.1

	412723'	402 00 0 00 000000#	help.4:	setzm	ccflg
	412724'	260 17 0 00 413277'		pushj	p,pshp.		;put ship back on board
	412725'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 69
WARMAC	MAC	 7-Jul-;2 18:15		HELP -- HLPXTR/HLPALL

						subttl	HELP -- HLPXTR/HLPALL

					;;;	HLPXTR -- Give general help info and list extra things help is
					;	available for (besides commands).
					;
						entry	hlpxtr
	412726'	50 54 60 70 64 62 		sixbit	/HLPXTR/
	412727'	201 12 0 00 412736'	hlpxtr:	movei	p1,xhlp1
	412730'	260 17 0 00 406710'		pushj	p,ostr.
	412731'	200 05 0 00 416410'		move	x1,[<-2*knxtr>,,xhelp]
	412732'	260 17 0 00 413240'		pushj	p,olst.
	412733'	201 12 0 00 412773'		movei	p1,xhlp2
	412734'	260 17 0 00 406710'		pushj	p,ostr.
	412735'	263 17 0 00 000000 		popj	p,

	412736'				xhlp1:	asciz /
	412736'	015 012 106 157 162 	For a list of commands type HELP *
	412737'	040 141 040 154 151 
	412740'	163 164 040 157 146 
	412741'	040 143 157 155 155 
	412742'	141 156 144 163 040 
	412743'	164 171 160 145 040 
	412744'	110 105 114 120 040 
	412745'	052 015 012 106 157 	For help on a particular command type HELP command
	412746'	162 040 150 145 154 
	412747'	160 040 157 156 040 
	412750'	141 040 160 141 162 
	412751'	164 151 143 165 154 
	412752'	141 162 040 143 157 
	412753'	155 155 141 156 144 
	412754'	040 164 171 160 145 
	412755'	040 110 105 114 120 
	412756'	040 143 157 155 155 
	412757'	141 156 144 015 012 
	412760'	015 012 102 145 163 	Besides commands, help is also available for:
	412761'	151 144 145 163 040 
	412762'	143 157 155 155 141 
	412763'	156 144 163 054 040 
	412764'	150 145 154 160 040 
	412765'	151 163 040 141 154 
	412766'	163 157 040 141 166 
	412767'	141 151 154 141 142 
	412770'	154 145 040 146 157 
	412771'	162 072 015 012 015 
	412772'	012 000 000 000 000 	/
	412773'				xhlp2:	asciz /
	412773'	015 012 125 160 160 	Upper case letters mark the shortest acceptable abbreviation.
	412774'	145 162 040 143 141 
	412775'	163 145 040 154 145 
	412776'	164 164 145 162 163 
	412777'	040 155 141 162 153 
	413000'	040 164 150 145 040 
	413001'	163 150 157 162 164 
	413002'	145 163 164 040 141 
	413003'	143 143 145 160 164 
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 69-1
WARMAC	MAC	 7-Jul-;2 18:15		HELP -- HLPXTR/HLPALL

	413004'	141 142 154 145 040 
	413005'	141 142 142 162 145 
	413006'	166 151 141 164 151 
	413007'	157 156 056 015 012 
	413010'	015 012 000 000 000 	/


					;;;	HLPALL -- Give list of all commands
					;
						entry	hlpall
	413011'	50 54 60 41 54 54 		sixbit	/HLPALL/
	413012'	260 17 0 00 406616'	hlpall:	pushj	p,ocrl.
						movei	p1,[ascil <Commands are:>^
						  asciz `Commands are:
					`
	413013'	201 12 0 00 416411'		^]
	413014'	260 17 0 00 406710'		pushj	p,ostr.
	413015'	260 17 0 00 406616'		pushj	p,ocrl.
	413016'	331 00 0 00 000000#		skipl	pasflg
	413017'	334 05 0 00 416415'		skipa	x1,[<-2*<kncmd-kscmd>>,,isaydo]
	413020'	200 05 0 00 416416'		move	x1,[<-2*kncmd>,,isaydo]
	413021'	260 17 0 00 413240'		pushj	p,olst.
	413022'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 70
WARMAC	MAC	 7-Jul-;2 18:15		HELP -- SHLP.

						subttl	HELP -- SHLP.

					;;;	SHLP. -- Search help file for keyword and type text associated
					;	with keyword.
					;
	413023'				shlp.:	save	<x2,x3,p1,p2>^
						  xlist
						  list
						^
	413027'	553 00 0 00 412247*		hrrzs	.jbren		; clear ^P flag
	413030'	402 00 0 00 000000#		setzm	ccflg		; and ^C flag
	413031'	260 17 0 00 406616'		pushj	p,ocrl.
	413032'	331 00 0 00 000000#		skipl	pasflg		;password set?
	413033'	254 00 0 00 413040'		jrst	shlp.1		;no, don't try special help file
	413034'	551 05 0 00 405125'		hrrzi	x1,hl1fil
	413035'	260 17 0 00 405725'		pushj	p,open.		;try help file with special commands documented
	413036'	254 00 0 00 413040'		  jrst	shlp.1		;no good; use normal help file
	413037'	254 00 0 00 413043'		jrst	shlp.2
	413040'	551 05 0 00 405143'	shlp.1:	hrrzi	x1,hl2fil
	413041'	260 17 0 00 405725'		pushj	p,open.		;try standard help file
						  warn	<Can't read help file>,shlp.e^
						  jrst [skipn	hungup		; if not hungup
							output	tty,		; then flush the tty buffer
							skipn	hungup
							outstr [ascil <%Can't read help file>^
						  asciz `%Can't read help file
					`
						^]
							jrst shlp.e
	413042'	254 00 0 00 416424'			]
						^
	413043'	260 17 0 00 406060'	shlp.2:	pushj	p,seti.		;set up for input from help file

	413044'	505 12 0 00 440700 		hrli	p1,(point 7)	;pointer to keyword being searched for
	413045'	474 06 0 00 000000 		seto	x2,		;not on right section yet
	413046'	260 17 0 00 406150'	shlp.3:	pushj	p,ichr.		;get next char from help file
	413047'	321 11 0 00 413113'	shlp.4:	jumpl	c,shlp.8	;eof
	413050'	306 11 0 00 000014 		cain	c,014		;form feed?
	413051'	254 00 0 00 413056'		jrst	shlp.5		;yes, ignore it, but count as eol
	413052'	323 06 0 00 413054'		jumple	x2,.+2		;not in right section yet
	413053'	260 17 0 00 406077'		pushj	p,ochr.		;type this section of help file
	413054'	302 11 0 00 000012 		caie	c,012		;eol?
	413055'	254 00 0 00 413046'		jrst	shlp.3		;no, don't check for section border

	413056'	336 00 0 00 000000#	shlp.5:	skipn	ccflg		;^C was typed?
	413057'	335 00 0 00 413027*		skipge	.jbren##	; or ^P?
	413060'	254 00 0 00 413122'		jrst	shlp.9		;yes, quit
	413061'	332 01 0 00 000000#		skipe	t1,who		;is player in game?
	413062'	331 00 0 01 000000#		skipl	alive-1(t1)	;and alive?
	413063'	254 00 0 00 413065'		jrst	.+2		;no
	413064'	402 00 0 01 000000#		setzm	active-1(t1)	;yes, don't count as idle during HELP output
	413065'	326 06 0 00 413067'		jumpn	x2,.+2		;ignore key word line of right section?
	413066'	344 06 0 00 413046'		aoja	x2,shlp.3	;yes, time to start typing it
	413067'	260 17 0 00 406150'		pushj	p,ichr.		;get first char of line
	413070'	302 11 0 00 000056 		caie	c,"."		;section border?
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 70-1
WARMAC	MAC	 7-Jul-;2 18:15		HELP -- SHLP.

	413071'	254 00 0 00 413047'		jrst	shlp.4		;no, false alarm
	413072'	327 06 0 00 413122'		jumpg	x2,shlp.9	;finished typing help text

	413073'	200 13 0 00 000012 		move	p2,p1		;get pointer to keyword being searched for
	413074'	201 07 0 00 000005 		movei	x3,5		;check at most 5 characters
	413075'	260 17 0 00 406150'	shlp.6:	pushj	p,ichr.		;get char from help file
	413076'	303 11 0 00 000137 		caile	c,137		;lower case?
	413077'	620 11 0 00 000040 		trz	c,040		;yes, make upper
	413100'	134 01 0 00 000013 		ildb	t1,p2		;get char from keyword
	413101'	302 01 0 00 000040 		caie	t1,040		;blank?
	413102'	306 01 0 00 000000 		cain	t1,000		;or null?
	413103'	254 00 0 00 413111'		jrst	shlp.7		;yes, end of keyword, and no mismatch
	413104'	303 01 0 00 000137 		caile	t1,137		;lower case?
	413105'	620 01 0 00 000040 		trz	t1,040		;yes, make upper
	413106'	302 11 0 01 000000 		caie	c,(t1)		;characters match?
	413107'	254 00 0 00 413046'		jrst	shlp.3		;no, this isn't the right section
	413110'	367 07 0 00 413075'		sojg	x3,shlp.6	;check remaining chars in keyword
	413111'	400 06 0 00 000000 	shlp.7:	setz	x2,
	413112'	254 00 0 00 413046'		jrst	shlp.3

	413113'	327 06 0 00 413122'	shlp.8:	jumpg	x2,shlp.9
	413114'	201 13 0 12 000000 		movei	p2,(p1)
	413115'	201 12 0 00 416431'		movei	p1,[asciz /%Can't find help on /]
	413116'	260 17 0 00 406710'		pushj	p,ostr.
	413117'	201 12 0 13 000000 		movei	p1,(p2)
	413120'	260 17 0 00 406723'		pushj	p,ostb.
	413121'	260 17 0 00 406616'		pushj	p,ocrl.

	413122'	260 17 0 00 406021'	shlp.9:	pushj	p,close.	;close help file
	413123'	260 17 0 00 406060'		pushj	p,seti.		;restore input from tty
	413124'				shlp.e:	restor	<p2,p1,x3,x2>^
						  xlist
						  list
						^
	413140'	553 00 0 00 413057*		hrrzs	.jbren##	; clear ^P flag
	413141'	402 00 0 00 000000#		setzm	ccflg		; and ^C
	413142'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 71
WARMAC	MAC	 7-Jul-;2 18:15		SLST./OLST.

						subttl	SLST./OLST.

					;;;	SLST. -- Search list.
					;
					;	Input
					;	  P1	pointer to word to search for
					;	  X1	-2*n,,addr
					;		addr = address of list of 2 word entries to search
					;		n = number of entries in the list
					;	  X2[L]	if negative, don't list ambiguous hits
					;	  X2[R]	address of warning message to output when no match is found
					;
					;	Output
					;	  P2	pointer to word in list that matched
					;	  X1	entry index (0..n-1)
					;
					;	Note	on the error return,
					;	  X1 < 0 if no match
					;	  X1 >= 0 if ambiguous match
					;
					;	PUSHJ P,SLST.
					;	  not a unique match
					;	P1 points to the matched entry, X1 contains it's index
					;
	413143'				slst.:	save	<x3,x4,p1>^
						  xlist
						  list
						^

	413146'	474 07 0 00 000000 		seto	x3,		;no matches yet
	413147'	400 10 0 00 000000 		setz	x4,		;address,,index of matching entry
	413150'	254 00 0 00 413155'		jrst	slst.2
	413151'	252 05 0 00 413207'	slst.1:	aobjp	x1,slst.6	;advance to next entry
	413152'	252 05 0 00 413207'		aobjp	x1,slst.6
	413153'	325 07 0 00 413155'		jumpge	x3,.+2		;any match yet?
	413154'	271 10 0 00 000001 		addi	x4,1		;no, increment entry index
	413155'	201 13 0 05 000000 	slst.2:	movei	p2,(x1)		;get addr of word to check
	413156'	260 17 0 00 411662'		pushj	p,equal.
	413157'	325 00 0 00 413151'		jumpge	slst.1		;no match

	413160'	347 07 0 00 413163'		aojg	x3,slst.3	;more than 1 match; ambiguous
	413161'	505 10 0 13 000000 		hrli	x4,(p2)		;remember which one matched
	413162'	254 00 0 00 413151'		jrst	slst.1

	413163'				slst.3:	save	<p1>^
						  xlist
						  list
						^
	413164'	302 07 0 00 000001 		caie	x3,1		;first ambiguous match?
	413165'	254 00 0 00 413176'		jrst	slst.4		;no, don't repeat message
	413166'	260 17 0 00 406723'		pushj	p,ostb.		;output ambiguous input
	413167'	201 12 0 00 416452'		movei	p1,[asciz / is ambiguous./]
	413170'	260 17 0 00 406710'		pushj	p,ostr.
	413171'	321 06 0 00 413203'		jumpl	x2,slst.5	;don't list ambiguous hits
						movei	p1,[ascil <  Could be:>^
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 71-1
WARMAC	MAC	 7-Jul-;2 18:15		SLST./OLST.

						  asciz `  Could be:
					`
	413172'	201 12 0 00 416455'		^]
	413173'	260 17 0 00 406710'		pushj	p,ostr.
	413174'	554 12 0 00 000010 		hlrz	p1,x4		;output first hit
	413175'	260 17 0 00 406723'		pushj	p,ostb.
	413176'	201 11 0 00 000054 	slst.4:	movei	c,","
	413177'	260 17 0 00 406077'		pushj	p,ochr.
	413200'	260 17 0 00 406612'		pushj	p,ospc.
	413201'	201 12 0 13 000000 		movei	p1,(p2)		;output this hit
	413202'	260 17 0 00 406723'		pushj	p,ostb.
	413203'				slst.5:	restor	<p1>^
						  xlist
						  list
						^
	413206'	325 06 0 00 413151'		jumpge	x2,slst.1

	413207'	322 07 0 00 413223'	slst.6:	jumpe	x3,slst.8	;unambiguous match
	413210'	400 05 0 00 000000 		setz	x1,		;assume ambiguous
	413211'	327 07 0 00 413221'		jumpg	x3,slst.7	;ambiguous
	413212'	474 05 0 00 000000 		seto	x1,
	413213'	201 07 0 12 000000 		movei	x3,(p1)		;remember address of input string
	413214'	201 12 0 06 000000 		movei	p1,(x2)		;address of warning message
	413215'	322 12 0 00 413226'		jumpe	p1,slst.9	;don't gripe if match not found
	413216'	260 17 0 00 406710'		pushj	p,ostr.
	413217'	201 12 0 07 000000 		movei	p1,(x3)		;output unknown input
	413220'	260 17 0 00 406723'		pushj	p,ostb.
	413221'	260 17 0 00 406616'	slst.7:	pushj	p,ocrl.
	413222'	254 00 0 00 413226'		jrst	slst.9

	413223'	554 13 0 00 000010 	slst.8:	hlrz	p2,x4
	413224'	551 05 0 10 000000 		hrrzi	x1,(x4)
	413225'	350 00 0 17 000000 		aos	(p)
	413226'				slst.9:	restor	<p1,x4,x3>^
						  xlist
						  list
						^
	413237'	263 17 0 00 000000 		popj	p,


					;;;	OLST. -- Output a list.
					;
					;	Input
					;	  X1	-2*n,,addr
					;		addr = addres of list of 2 word entries
					;		n = number of entries
					;
	413240'				olst.:	save	<x1,x2>^
						  xlist
						  list
						^
	413242'	201 06 0 00 000007 	olst.1:	movei	x2,7		;6 columns per line
	413243'	120 01 0 05 000000 	olst.2:	dmove	t1,(x1)		;get words to output
	413244'	124 01 0 00 001767'		dmovem	t1,tmp
	413245'	402 00 0 00 001771'		setzm	tmp+2
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 71-2
WARMAC	MAC	 7-Jul-;2 18:15		SLST./OLST.

	413246'	201 12 0 00 001767'		movei	p1,tmp
	413247'	260 17 0 00 406710'		pushj	p,ostr.		;output entry
	413250'	252 05 0 00 413255'		aobjp	x1,olst.3	;point to next entry
	413251'	252 05 0 00 413255'		aobjp	x1,olst.3
	413252'	367 06 0 00 413243'		sojg	x2,olst.2
	413253'	260 17 0 00 406616'		pushj	p,ocrl.		;start a new line
	413254'	254 00 0 00 413242'		jrst	olst.1

	413255'	260 17 0 00 406616'	olst.3:	pushj	p,ocrl.
						restor	<x2,x1>^
						  xlist
						  list
						^
	413264'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 72
WARMAC	MAC	 7-Jul-;2 18:15		ESHP./PSHP.

						subttl	ESHP./PSHP.

					;;;	ESHP. -- Erase a ship from the board (replace it with a 10) if
					;	it's condition isn't red.
					;
					;	Input
					;	  WHO	number of ship to remove from board
					;
	413265'	337 03 0 00 000000#	eshp.:	skipg	t3,who		;see whose ship to erase
	413266'	254 00 0 00 413276'		jrst	eshp.1		;nobody's
	413267'	200 01 0 03 000000#		move	t1,shpcon+<KSPCON-1>*KNPLAY-1(t3)
	413270'	306 01 0 00 000003 		cain	t1,red		;condition red?
	413271'	254 00 0 00 413276'		jrst	eshp.1		;yes, leave it there

	413272'	200 01 0 03 000000#		move	t1,shpcon+<KVPOS-1>*KNPLAY-1(t3) ;vertical position
	413273'	200 02 0 03 000000#		move	t2,shpcon+<KHPOS-1>*KNPLAY-1(t3) ;horizontal position
	413274'	201 03 0 00 001750 		movei	t3,^D1000	;make black hole
	413275'	260 17 0 00 413366'		pushj	p,sdsp.		;set display value
	413276'	263 17 0 00 000000 	eshp.1:	popj	p,


					;;;	PSHP. -- Put ship on board.
					;
					;	Input
					;	  WHO	ship number to put back on board
					;
	413277'	337 03 0 00 000000#	pshp.:	skipg	t3,who
	413300'	254 00 0 00 413311'		jrst	pshp.1
	413301'	331 00 0 03 000000#		skipl	alive-1(t3)	;alive?
	413302'	254 00 0 00 413276'		jrst	eshp.1		;no, forget it

	413303'	200 01 0 03 000000#		move	t1,shpcon+<KVPOS-1>*KNPLAY-1(t3)
	413304'	200 02 0 03 000000#		move	t2,shpcon+<KHPOS-1>*KNPLAY-1(t3)
	413305'	271 03 0 00 000144 		addi	t3,^D100	;code for fed ship
	413306'	303 03 0 00 000151 		caile	t3,^D100+KNPLAY/2
	413307'	271 03 0 00 000144 		addi	t3,^D100	;change to emp ship
	413310'	260 17 0 00 413366'		pushj	p,sdsp.
	413311'	263 17 0 00 000000 	pshp.1:	popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 73
WARMAC	MAC	 7-Jul-;2 18:15		DISP/DISPC/DISPX/SETDSP

						subttl	DISP/DISPC/DISPX/SETDSP

					;;;	DISP -- Return the code of a location on the board.
					;
					;	n = DISP(v,h)
					;
						entry	disp
	413312'	44 51 63 60 00 00 		sixbit	/DISP/
	413313'				disp:
					ifn debug., <
	413313'	260 17 0 00 413404'		pushj	p,chkc.		;check coordinate legality
					> ;end ifn debug.
	413314'	200 00 1 16 000001 		move	t0,@1(arg)	; H
	413315'	275 00 0 00 000001 		subi	t0,1		; H - 1
	413316'	231 00 0 00 000003 		idivi	t0,3		; (H - 1) / 3
	413317'	200 16 1 16 000000 		move	arg,@0(arg)	; V
	413320'	221 16 0 00 000031 		imuli	arg,ksid	; V * KSID
	413321'	271 00 0 16 777747 		addi	t0,-ksid(arg)	; (H - 1) / 3 + (V * KSID) - KSID
	413322'	270 00 0 01 405264'		add	t0,b12tbl(t1)	;build pointer
	413323'	135 00 0 00 000000 		ldb	t0,t0		;get contents of location in space
	413324'	306 00 0 00 007777 		cain	t0,7777		;12 bits of 1?
	413325'	474 00 0 00 000000 		seto	t0,		;yes, must be -1
					ifn debug., <
	413326'	260 17 0 00 413502'		pushj	p,chkd.		;check value of display code
					> ;end ifn debug.
	413327'	263 17 0 00 000000 		popj	p,


					;;;	DISPC -- Return DISP(v,h) div 100
					;
						entry	dispc
	413330'	44 51 63 60 43 00 		sixbit	/DISPC/
	413331'	260 17 0 00 413313'	dispc:	pushj	p,disp
	413332'	231 00 0 00 000144 		idivi	t0,^D100
	413333'	263 17 0 00 000000 		popj	p,


					;;;	DISPX -- Return DISP(v,h) mod 100
					;
						entry	dispx
	413334'	44 51 63 60 70 00 		sixbit	/DISPX/
	413335'	260 17 0 00 413313'	dispx:	pushj	p,disp
	413336'	231 00 0 00 000144 		idivi	t0,^D100
	413337'	201 00 0 01 000000 		movei	t0,(t1)
	413340'	263 17 0 00 000000 		popj	p,


					;;;	SETDSP -- Set the contents of a location on the board.
					;
					;	CALL SETDSP (v,h,n)
					;
						entry	setdsp
	413341'	63 45 64 44 63 60 		sixbit	/SETDSP/
	413342'				setdsp:
					ifn debug., <
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 73-1
WARMAC	MAC	 7-Jul-;2 18:15		DISP/DISPC/DISPX/SETDSP

	413342'	260 17 0 00 413404'		pushj	p,chkc.		;check coordinate legality
					> ;end ifn debug.
	413343'	200 00 1 16 000001 		move	t0,@1(arg)	; H
	413344'	275 00 0 00 000001 		subi	t0,1		; H - 1
	413345'	231 00 0 00 000003 		idivi	t0,3		; (H - 1) / 3
	413346'	200 02 1 16 000000 		move	t2,@0(arg)	; V
	413347'	221 02 0 00 000031 		imuli	t2,ksid		; V * KSID
	413350'	271 00 0 02 777747 		addi	t0,-ksid(t2)	; (H - 1) / 3 + (V * KSID) - KSID
	413351'	270 00 0 01 405264'		add	t0,b12tbl(t1)	;build pointer
					ifn debug., <
	413352'	135 01 0 00 000000 		ldb	t1,t0
	413353'	202 01 0 00 002050'		movem	t1,oldobj
					> ;end ifn debug.
	413354'	200 01 1 16 000002 		move	t1,@2(arg)	;get contents to deposit in space
	413355'	137 01 0 00 000000 		dpb	t1,t0		;stick it there
					ifn debug., <
	413356'	201 00 0 01 000000 		movei	t0,(t1)
	413357'	260 17 0 00 413502'		pushj	p,chkd.		;check value of display code
	413360'	336 00 0 00 000000#		skipn	pasflg
	413361'	263 17 0 00 000000 		popj	p,
					ifn dbzer., <
						jumpe	t0,.+2		;to see why ships disappear
					>
					> ;end ifn debug.
	413362'	263 17 0 00 000000 		popj	p,

					ifn dbzer., <
						save	<t0,t1,t2,t3,t4,x1,x2,p1,c>
						pushj	p,ocrl.
						movei	p1,[asciz /%Zeroing location /]
						pushj	p,ostr.
						move	x1,@0(arg)
						setz	x2,
						pushj	p,odec.
						pushj	p,ospc.
						move	x1,@1(arg)
						setz	x2,
						pushj	p,odec.
						movei	p1,[asciz / (was /]
						pushj	p,ostr.
						move	x1,oldobj
						setz	x2,
						pushj	p,odec.
						movei	p1,[byte (7) ")",015,012]
						pushj	p,ostr.
						pushj	p,trac.
						restor	<c,p1,x2,x1,t4,t3,t2,t1,t0>
						popj	p,
					> ;end ifn debug.


					;;;	GDSP. -- Return the contents of a location on the board.
					;
					;	Input
					;	  T1	Vpos
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 73-2
WARMAC	MAC	 7-Jul-;2 18:15		DISP/DISPC/DISPX/SETDSP

					;	  T2	Hpos
					;	Output
					;	  T3	Value
					;
	413363'	260 17 0 00 413375'	gdsp.:	pushj	p,gptr.		;get pointer to location
	413364'	134 03 0 00 000002 		ildb	t3,t2		;get object at location
	413365'	263 17 0 00 000000 		popj	p,


					;;;	SDSP. -- Set the value of a location on the board.
					;
					;	Input
					;	  T1	Vpos
					;	  T2	Hpos
					;	  T3	Value
					;
	413366'				sdsp.:	save	<t3>^
						  xlist
						  list
						^
	413367'	260 17 0 00 413375'		pushj	p,gptr.		;get pointer to location
						restor	<t3>^
						  xlist
						  list
						^
	413373'	136 03 0 00 000002 		idpb	t3,t2		;put object there
	413374'	263 17 0 00 000000 		popj	p,


					;;;	GPTR. -- Return a pointer to a location on the board.
					;
					;	Input
					;	  T1	Vpos
					;	  T2	Hpos
					;	Output
					;	  T2	pointer
					;
	413375'	201 02 0 02 777777 	gptr.:	movei	t2,-1(t2)	;Hpos - 1
	413376'	231 02 0 00 000003 		idivi	t2,3		;(Hpos - 1) / 3
	413377'	221 01 0 00 000031 		imuli	t1,ksid		;Vpos * KSID
	413400'	271 02 0 01 777747 		addi	t2,-ksid(t1)	;(Hpos-1) / 3 + (Vpos * Ksid) - Ksid
	413401'	270 02 0 03 405263'		add	t2,b12tbl-1(t3)	;build pointer to location
	413402'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74
WARMAC	MAC	 7-Jul-;2 18:15		CHKC./CHKD./TRAC.

						subttl	CHKC./CHKD./TRAC.

					ifn debug., <

					;;;	CHKC. -- Check coordinates for legality.  Since this is a debug
					;	routine, to be placed anywhere, don't bash any ACs.
					;	It is assumed that the calling routine was called from FORTRAN
					;	with
					;		CALL X (v,h)
					;
	413403'	43 50 53 43 16 00 		sixbit	/CHKC./
	413404'	336 00 0 00 000000#	chkc.:	skipn	pasflg
	413405'	263 17 0 00 000000 		popj	p,
						save	<t0>^
						  xlist
						  list
						^
	413407'	200 00 1 16 000000 		move	t0,@0(arg)	;check vertical coordinate
	413410'	303 00 0 00 000000 		caile	t0,0
	413411'	303 00 0 00 000113 		caile	t0,KGALV
	413412'	254 00 0 00 413423'		jrst	chkc.1
	413413'	200 00 1 16 000001 		move	t0,@1(arg)	;check horizontal coordinate
	413414'	303 00 0 00 000000 		caile	t0,0
	413415'	303 00 0 00 000113 		caile	t0,KGALH
	413416'	254 00 0 00 413423'		jrst	chkc.1
						restor	<t0>^
						  xlist
						  list
						^
	413422'	263 17 0 00 000000 		popj	p,

	413423'				chkc.1:	save	<t1,t2,t3,t4,x1,x2,p1,c>^
						  xlist
						  list
						^
	413433'	201 12 0 00 416510'		movei	p1,[asciz /%Illegal coordinate: /]
	413434'	260 17 0 00 406710'		pushj	p,ostr.
	413435'	400 06 0 00 000000 		setz	x2,
	413436'	200 05 1 16 000000 		move	x1,@0(arg)
	413437'	260 17 0 00 407035'		pushj	p,odec.
	413440'	260 17 0 00 406612'		pushj	p,ospc.
	413441'	200 05 1 16 000001 		move	x1,@1(arg)
	413442'	260 17 0 00 407035'		pushj	p,odec.
	413443'	260 17 0 00 406616'		pushj	p,ocrl.
	413444'	260 17 0 00 413620'		pushj	p,trac.
						restor	<c,p1,x2,x1,t4,t3,t2,t1>^
						  xlist
						  list
						^
						restor	<t0>^
						  xlist
						  list
						^
	413500'	263 17 0 00 000000 		popj	p,

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-1
WARMAC	MAC	 7-Jul-;2 18:15		CHKC./CHKD./TRAC.



					;;;	CHKD. -- Check display code for legality.  Since this is a debug
					;	routine, to be placed anywhere, don't bash any ACs.
					;
					;	Input
					;	  T0	Display code to check.
					;
	413501'	43 50 53 44 16 00 		sixbit	/CHKD./
	413502'	336 00 0 00 000000#	chkd.:	skipn	pasflg
	413503'	263 17 0 00 000000 		popj	p,
						save	<t1,t2,t3>^
						  xlist
						  list
						^
	413507'	550 01 0 00 000000 		hrrz	t1,t0
	413510'	231 01 0 00 000144 		idivi	t1,^D100
	413511'	303 01 0 00 000012 		caile	t1,^d10		; max object code
	413512'	254 00 0 00 413533'		jrst	chkd.1
	413513'	554 03 0 01 413604'		hlrz	t3,rngtbl(t1)	;get lower range
	413514'	305 02 0 03 000000 		caige	t2,(t3)
	413515'	254 00 0 00 413533'		jrst	chkd.1
	413516'	550 03 0 01 413604'		hrrz	t3,rngtbl(t1)	;get upper range
	413517'	303 02 0 03 000000 		caile	t2,(t3)
	413520'	254 00 0 00 413533'		jrst	chkd.1
						restor	<t3,t2,t1>^
						  xlist
						  list
						^
	413532'	263 17 0 00 000000 		popj	p,

	413533'				chkd.1:	save	<t0,t4,x1,x2,p1,c>^
						  xlist
						  list
						^
	413541'	201 12 0 00 416561'		movei	p1,[asciz /%Illegal display code: /]
	413542'	260 17 0 00 406710'		pushj	p,ostr.
	413543'	200 05 0 00 000000 		move	x1,t0
	413544'	400 06 0 00 000000 		setz	x2,
	413545'	260 17 0 00 407035'		pushj	p,odec.
	413546'	260 17 0 00 406616'		pushj	p,ocrl.
	413547'	260 17 0 00 413620'		pushj	p,trac.
						restor	<c,p1,x2,x1,t4,t0>^
						  xlist
						  list
						^
						restor	<t3,t2,t1>^
						  xlist
						  list
						^
	413603'	263 17 0 00 000000 		popj	p,

						radix	10
	413604'	000000	000000		rngtbl:	0,,0			;empty space
	413605'	000001	000005			1,,5			;federation ship
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-2
WARMAC	MAC	 7-Jul-;2 18:15		CHKC./CHKD./TRAC.

	413606'	000006	000012			6,,10			;empire ship
	413607'	000001	000012			1,,10			;federation base
	413610'	000001	000012			1,,10			;empire base
	413611'	000000	000001			0,,1			;romulan
	413612'	000001	000120			1,,80			;neutral planet
	413613'	000001	000120			1,,80			;federation planet
	413614'	000001	000120			1,,80			;empire planet
	413615'	000000	000000			0,,0			;star
	413616'	000000	000000			0,,0			;black hole
						radix	8



					;;;	TRAC. -- Trace back the subroutine calls.
					;
	413617'	64 62 41 43 16 00 		sixbit	/TRAC./
	413620'				trac.:	save	<x1,x2,x3>^
						  xlist
						  list
						^
	413623'	574 06 0 00 000017 		hlre	x2,p
	413624'	271 06 0 00 000047 		addi	x2,pdlsiz-1	;depth of sub nesting (TRAC. doesn't count)
	413625'	551 07 0 17 777777 		hrrzi	x3,-1(p)	;ptr to first return addr
	413626'	361 06 0 00 413635'	trac.1:	sojl	x2,trac.2	;done
	413627'	550 05 0 07 000000 		hrrz	x1,(x3)		;get return addr
	413630'	550 05 0 05 777777 		hrrz	x1,-1(x1)	;get addr of subroutine
	413631'	200 05 0 05 777777 		move	x1,-1(x1)	;get name of subroutine
	413632'	260 17 0 00 407014'		pushj	p,osix.		;output it
	413633'	260 17 0 00 406612'		pushj	p,ospc.		;end with <SP>
	413634'	364 07 0 00 413626'		soja	x3,trac.1
	413635'	260 17 0 00 406616'	trac.2:	pushj	p,ocrl.
	413636'	336 00 0 00 000000#		skipn	hungup
	413637'	067 00 0 00 000000 		output	tty,
						restor	<x3,x2,x1>^
						  xlist
						  list
						^
	413651'	263 17 0 00 000000 		popj	p,

					> ;end ifn debug.
						subttl	updsta/shosta - Player Status register


						entry	updcap		; update the "Captain" count for given ship
	413652'	201 01 0 00 405204'	updcap:	movei	t1,staupd	; lock the file
	413653'	260 17 0 00 411776'		pushj	p,lock.
	413654'	332 00 0 00 000000#		skipe	lkfail
	413655'	254 00 0 00 413652'		jrst	updcap		; we have to have it!
	413656'	402 00 0 00 000554'		setzm	stabuf
	413657'	200 01 0 00 416632'		move	t1,[stabuf,,stabuf+1]
	413660'	251 01 0 00 001753'		blt	t1,staend	; clear status buffer
	413661'	200 05 0 00 416633'		move	x1,[xwd stared,stared]
	413662'	260 17 0 00 405725'		pushj	p,open.
	413663'	254 00 0 00 413667'		jrst	updcax
	413664'	335 00 0 00 002036'		skipge	le.ppn
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-3
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

	413665'	066 06 0 00 001754'		input	sta,staiow
	413666'	070 06 0 00 000000 		close	sta,
	413667'				updcax:
	413667'	336 00 0 00 000000#		skipn	gameno		; if this is a new game
	413670'	350 00 0 00 000554'		aos	stabuf		;	bump the game number
	413671'	200 01 0 00 000554'		move	t1,stabuf	; save game number
	413672'	202 01 0 00 000000#		movem	t1,gameno
	413673'	332 00 0 00 000354'		skipe	frebie		; if free player running
						jrst	[
								move	x1,[xwd staupd,staupd]
								pushj	p,open.
								jrst	.+1
								output	sta,staiow
								close	sta,
								setzm	stabuf
								setzm	stabuf
								move	t1,[stabuf,,stabuf+1]
								blt	t1,staend
								move	x1,[xwd stfred,stfred]
								pushj	p,open.
								jrst	.+1
								skipge	le.ppn
								input	sta,staiow
								close	sta,
								move	t1,gameno
								movem	t1,stabuf
	413674'	254 00 0 00 416636'				jrst	.+1]
	413675'	200 01 1 16 000000 		move	t1,@0(arg)	; get ship number
	413676'	350 00 0 01 001554'		aos	stacap(t1)	; bump the counter
	413677'	200 05 0 00 416634'		move	x1,[xwd staupd,staupd]	; rewrite the file
	413700'	332 00 0 00 000354'		skipe	frebie
	413701'	200 05 0 00 416660'		move	x1,[xwd stfupd,stfupd]
	413702'	260 17 0 00 405725'		pushj	p,open.
	413703'	254 00 0 00 413706'		jrst	updcay
	413704'	067 06 0 00 001754'		output	sta,staiow
	413705'	070 06 0 00 000000 		close	sta,
	413706'	201 01 0 00 405204'	updcay:	movei	t1,staupd	; release the file
	413707'	260 17 0 00 412142'		pushj	p,unlo.
	413710'	336 00 0 00 000000#		skipn	hungup
	413711'	067 00 0 00 000000 		output	tty,
						outstr	[asciz "
	413712'	051 03 0 00 416661'	DECWAR game #"]
	413713'	200 05 0 00 000000#		move	x1,gameno
	413714'	201 06 0 00 000000 		movei	x2,0
	413715'	260 17 0 00 407035'		pushj	p,odec.
	413716'	336 00 0 00 000000#		skipn	hungup
	413717'	067 00 0 00 000000 		output	tty,
	413720'	336 00 0 00 000000#		skipn	hungup
						outstr	[asciz "

	413721'	051 03 0 00 416665'	This is mission #"]
	413722'	200 01 1 16 000000 		move	t1,@0(arg)
	413723'	200 05 0 01 001554'		move	x1,stacap(t1)
	413724'	201 06 0 00 000000 		movei	x2,0
	413725'	260 17 0 00 407035'		pushj	p,odec.
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-4
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

	413726'	336 00 0 00 000000#		skipn	hungup
	413727'	067 00 0 00 000000 		output	tty,
	413730'	336 00 0 00 000000#		skipn	hungup
						outstr	[asciz " for the
	413731'	051 03 0 00 416672'	"]
	413732'	200 01 1 16 000000 		move	t1,@0(arg)
	413733'	336 00 0 00 000000#		skipn	hungup
	413734'	051 03 1 01 407300'		outstr	@lngshp-1(t1)
	413735'	336 00 0 00 000000#		skipn	hungup
					;	outstr	[asciz "
					;"]
	413736'	336 00 0 00 000000#		skipn	hungup
	413737'	263 17 0 00 000000 		popj	p,

					;ALL commented out by drforbin(merlyn). not needed used by CIS for user pay/nopay status
					;	entry	chkpay		; return .true. if user is paying customer
					;chkpay:	seto	0,
					;	hlrz	t1,usppn.
					;	caige	t1,70010
					;	setz	0,
					;	andi	t1,7
					;	cain	t1,3
					;	setz	0,
					;	move	t1,ustat.##
					;	tlne	t1,(1b2)
					;	setz	0,
					;	popj	p,

						entry	pdwdoc
	413740'	067 00 0 00 000000 	pdwdoc:	output	tty,
						movei	t1,[	sixbit 'DSK'
								sixbit 'PDWDOC'
								exp 0,0,0,0
	413741'	201 01 0 00 416675'			]
	413742'	047 01 0 00 000035 		run	t1,
	413743'	255 00 0 00 000000 		  jfcl
	413744'	263 17 0 00 000000 		popj	p,	; Well, it should NEVER get here!!!!

						entry	updsta		; update the status file
	413745'				updsta:	
	413745'	200 01 1 16 000006 		move	t1,@6(arg)	; if score is too small
	413746'	305 01 0 00 001750 		caige	t1,^d1000
	413747'	263 17 0 00 000000 		popj	p,		; then don't record it!
	413750'	336 00 0 00 000000#		skipn	hungup
	413751'	067 00 0 00 000000 		output	tty,
	413752'	201 01 0 00 405204'		movei	t1,staupd	; lock up the stat file
	413753'	260 17 0 00 411776'		pushj	p,lock.
	413754'	332 00 0 00 000000#		skipe	lkfail
	413755'	254 00 0 00 413752'		jrst	.-3
	413756'	402 00 0 00 000554'		setzm	stabuf
	413757'	200 01 0 00 416632'		move	t1,[stabuf,,stabuf+1]
	413760'	251 01 0 00 001753'		blt	t1,staend
	413761'	200 05 0 00 416633'		move	x1,[xwd stared,stared]	; open the file in input mode
	413762'	260 17 0 00 405725'		pushj	p,open.
	413763'	254 00 0 00 414002'		jrst	updstx
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-5
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

	413764'	335 00 0 00 002036'		skipge	le.ppn			; if no file yet, don't read!
	413765'	066 06 0 00 001754'		input	sta,staiow
	413766'	070 06 0 00 000000 		close	sta,
	413767'	336 00 0 00 000354'		skipn	frebie		; if "free" user
	413770'	254 00 0 00 414002'		jrst	updstx		; then
	413771'	402 00 0 00 000554'		setzm	stabuf
	413772'	200 01 0 00 416632'		move	t1,[stabuf,,stabuf+1]
	413773'	251 01 0 00 001753'		blt	t1,staend
	413774'	200 05 0 00 416635'		move	x1,[xwd stfred,stfred]	; get free stats
	413775'	260 17 0 00 405725'		pushj	p,open.
	413776'	254 00 0 00 414002'		jrst	updstx
	413777'	335 00 0 00 002036'		skipge	le.ppn
	414000'	066 06 0 00 001756'		input	sta,stfiow
	414001'	070 06 0 00 000000 		close	sta,
	414002'	200 02 1 16 000011 	updstx:	move	t2,@9(arg)	; = ship #
	414003'	336 00 1 16 000007 		skipn	@7(arg)		; if ship was destroyed
						jrst	[aos	t1,stakil(t2)	; bump killed count
							 cain	t1,1		; if this is not first time
							 jrst	.+1		; then
						 	 skipn	hungup
							 output	tty,
						skipn	hungup
							 outstr	[asciz "

					Don't feel bad; the "]
						skipn	hungup
							 outstr	@lngshp-1(t2)
						skipn	hungup
							 outstr [asciz "
					has been destroyed "]
							 move	x1,stakil(t2)
							 sos	x1		; give count BEFORE this time!
							 setz	x2,
							 pushj	p,odec.
							 skipn	hungup
							 output	tty,
						skipn	hungup
							 outstr	[asciz " times
					out of "]
							 move	t2,@9(arg)
							 move	x1,stacap(t2)
							 setz	x2,
							 pushj	p,odec.
							 skipn	hungup
							 output	tty,
						skipn	hungup
							 outstr	[asciz " missions!
					"]
							 jrst	.+1
	414004'	254 00 0 00 416724'			]
	414005'	201 05 0 00 000557'		movei	x1,stabuf+3	; t2 is pointer into the buffer
	414006'	332 00 1 16 000010 		skipe	@8(arg)		; if Empire team
	414007'	271 05 0 00 000400 		addi	x1,^d256	; then move on to the Empire's database
					;--	skipn	@7(arg)		; if killed in action
					;--	addi	x1,knstat*^d10	; then move up to the Memorial list
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-6
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

	414010'	201 02 0 05 000000 		movei	t2,0(x1)
	414011'	200 03 1 16 000005 		move	t3,@5(arg)	; t3 holds current player's score
	414012'	201 01 0 00 000012 		movei	t1,knstat

	414013'	336 00 0 02 000000 	updst0:	skipn	0(t2)		; if file entry is null
	414014'	254 00 0 00 414024'		jrst	updst2		; then insert new data
	414015'	315 03 0 02 000006 		camge	t3,6(t2)	; if new lss old
	414016'	254 00 0 00 414134'		jrst	updst1		; then go to next entry
	414017'	312 03 0 02 000006 		came	t3,6(t2)	; if new eql old
	414020'	254 00 0 00 414024'		jrst	updst2		; then
	414021'	200 04 0 02 000007 		move	t4,7(t2)	; if new turns < old turns
	414022'	311 04 1 16 000006 		caml	t4,@6(arg)
	414023'	254 00 0 00 414134'		jrst	updst1		; then
	414024'	275 01 0 00 000013 	updst2:	subi	t1,knstat+1
						save	<t2,x1,x2>^
						  xlist
						  list
						^
	414030'	201 06 0 05 000000 		movei	x2,0(x1)	; scan for higher score for same PPN
	414031'	200 03 1 16 000000 		move	t3,@0(arg)	; = PPN
	414032'	307 02 0 06 000000 	upst2a:	caig	t2,0(x2)	; if at or beyond place of insertion
	414033'	254 00 0 00 414040'		jrst	upst2b		; then do the insertion
	414034'	316 03 0 06 000000 		camn	t3,0(x2)	; if same PPN
						jrst	[		; then ignore the lower placement
							 restore <x2,x1,t2>^
						  xlist
						  list
						^
							 skipn	@7(arg)		; if killed in action
							 jrst	updstf		; then update the file
							 jrst	updst9		; else just exit
	414035'	254 00 0 00 416771'			]
	414036'	271 06 0 00 000012 		addi	x2,^d10		; try next one
	414037'	254 00 0 00 414032'		jrst	upst2a

	414040'				upst2b:
	414040'	214 05 0 00 000001 		movm	x1,t1
	414041'	332 00 0 00 000000#		skipe	hungup
	414042'	254 00 0 00 414054'		jrst	updst5
	414043'	306 05 0 00 000001 		cain	x1,1		; if #1
						jrst	[outstr	[asciz "
					Congratulations, Captain! You
					are now in first place!
					"]
							 jrst	updst5
	414044'	254 00 0 00 417021'			]
	414045'	306 05 0 00 000012 		cain	x1,knstat		; if last place
						jrst	[skipn	hungup
							 outstr	[asciz "
					Well, Captain, you at least
					made tenth place!  Try harder
					next time! 
					"]
							 jrst	updst5
	414046'	254 00 0 00 417043'			]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-7
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

						outstr	[asciz "
	414047'	051 03 0 00 417046'	You have placed as number "]
	414050'	400 06 0 00 000000 		setz	x2,
	414051'	260 17 0 00 407035'		pushj	p,odec.
	414052'	067 00 0 00 000000 		output	tty,
						outstr	[asciz "!
	414053'	051 03 0 00 416156'	"]
	414054'				updst5:	restor <x2,x1,t2>^
						  xlist
						  list
						^
	414065'	332 00 0 00 000000#		skipe	hungup
	414066'	254 00 0 00 414071'		jrst	upst5a
	414067'	336 00 1 16 000007 		skipn	@7(arg)		; if he got killed
						outstr	[asciz "...at least the history books
					will remember you....
					for a while!
	414070'	051 03 0 00 417065'	"]
	414071'	201 04 0 05 000143 	upst5a:	movei	t4,knstat*^d10-1(x1)	; move old entries down one
	414072'				updst3:
	414072'	303 02 0 04 777766 		caile	t2,-^d10(t4)		; if moved all entries
	414073'	254 00 0 00 414077'		jrst	updst8			; then go insert new data
	414074'	200 03 0 04 777766 		move	t3,-^d10(t4)
	414075'	202 03 0 04 000000 		movem	t3,0(t4)
	414076'	364 04 0 00 414072'		soja	t4,updst3	; then do next one
	414077'	200 03 1 16 000000 	updst8:	move	t3,@0(arg)	; else move new data
	414100'	202 03 0 02 000000 		movem	t3,0(t2)	; PPN
	414101'	200 03 1 16 000001 		move	t3,@1(arg)
	414102'	202 03 0 02 000001 		movem	t3,1(t2)	; Captain's name-1
	414103'	200 03 1 16 000002 		move	t3,@2(arg)
	414104'	202 03 0 02 000002 		movem	t3,2(t2)	;    "      name-2
	414105'	200 03 1 16 000003 		move	t3,@3(arg)
	414106'	202 03 0 02 000003 		movem	t3,3(t2)	; Ship's name-1
	414107'	200 03 1 16 000004 		move	t3,@4(arg)
	414110'	202 03 0 02 000004 		movem	t3,4(t2)	;   "    name-2
					;	movei	t3,400000	;drforbin(CIS remove); get player's time & zone
					;	calli	t3,-211		;drforbin(CIS remove); GTADN. uuo (CIS)
	414111'	047 03 0 00 000014 		date	t3,		;added drforbin
					;	  setzb	t3,t4		;comment drforbin
	414112'	202 03 0 02 000005 		movem	t3,5(t2)	; save time
	414113'	200 04 1 16 000011 		move	t4,@9(arg)
	414114'	200 03 0 04 001554'		move	t3,stacap(t4)	; preserve mission #
	414115'	202 03 0 02 000011 		movem	t3,9(t2)
	414116'	200 03 1 16 000007 		move	t3,@7(arg)	; and killed flag
	414117'	506 03 0 02 000011 		hrlm	t3,9(t2)
	414120'	200 03 1 16 000005 		move	t3,@5(arg)
	414121'	202 03 0 02 000006 		movem	t3,6(t2)	; player's score
	414122'	200 03 1 16 000006 		move	t3,@6(arg)
	414123'	202 03 0 02 000007 		movem	t3,7(t2)	; number of turns
	414124'	200 05 0 00 416634'	updstf:	move	x1,[staupd,,staupd]
	414125'	332 00 0 00 000354'		skipe	frebie		; if free user
	414126'	200 05 0 00 416660'		move	x1,[stfupd,,stfupd]	; then update proper file
	414127'	260 17 0 00 405725'		pushj	p,open.
	414130'	254 00 0 00 414142'		  jrst	updst9
	414131'	067 06 0 00 001754'		output	sta,staiow
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-8
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

	414132'	070 06 0 00 000000 		close	sta,
	414133'	254 00 0 00 414142'		jrst	updst9		; go close the file and exit

	414134'	271 02 0 00 000012 	updst1:	addi	t2,^d10		; point to next entry
	414135'	367 01 0 00 414013'		sojg	t1,updst0
	414136'	336 00 0 00 000000#		skipn	hungup
						outstr	[asciz "
					Sorry, but you didn't make the
					cut!  Better luck next time!
	414137'	051 03 0 00 417103'	"]
	414140'	336 00 1 16 000007 		skipn	@7(arg)		; if killed in action
	414141'	254 00 0 00 414124'		jrst	updstf		; then make sure file is updated

	414142'	201 01 0 00 405204'	updst9:	movei	t1,staupd	; release the interlock
	414143'	260 17 0 00 412142'		pushj	p,unlo.
	414144'	263 17 0 00 000000 		popj	p,		; return to caller


						entry	shosta		; display the status file
	414145'				shosta:
	414145'	332 00 0 00 000354'		skipe	frebie
	414146'	334 05 0 00 416635'		skipa	x1,[xwd stfred,stfred]	; read DECWAF.STA
	414147'	200 05 0 00 416633'	shopay:	move	x1,[xwd	stared,stared]	; open in read mode
	414150'	260 17 0 00 405725'		pushj	p,open.
	414151'	263 17 0 00 000000 		  popj	p,			; DECWAR.STA not found
	414152'	066 06 0 00 001754'		input	sta,staiow		; read the data
	414153'	070 06 0 00 000000 		close	sta,
	414154'	200 01 0 00 000557'		move	t1,stabuf+3
	414155'	434 01 0 00 000723'		ior	t1,stabuf+3+knstat*^d10	; check for any high rollers
	414156'	434 01 0 00 001157'		ior	t1,stabuf+3+^d256
	414157'	434 01 0 00 001323'		ior	t1,stabuf+3+^d256+knstat*^d10
	414160'	336 00 0 00 000001 		skipn	t1
	414161'	254 00 0 00 414201'		jrst	shockp
	414162'	336 00 0 00 000000#		skipn	hungup
	414163'	067 00 0 00 000000 		output	tty,			; flush TTY: buffer
						movei	p1,[asciz "


					--------------

					The DECWAR Honor Roll

					(* indicates Missing in Action)

	414164'	201 12 0 00 417120'	"]
	414165'	260 17 0 00 406710'		pushj	p,ostr.
	414166'	200 01 0 00 002033'		move	t1,le.nam
	414167'	316 01 0 00 417141'		camn	t1,[sixbit 'DECWAF']
						jrst	[
							 movei	p1,[asciz "(**** non-paying users ****)

					"]
							 pushj	p,ostr.
	414170'	254 00 0 00 417151'			 jrst	.+1]

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-9
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

	414171'	200 01 0 00 000565'		move	t1,stabuf+9		; if hi Fed >= hi Emp
	414172'	315 01 0 00 001165'		camge	t1,stabuf+9+^d256
	414173'	254 00 0 00 414177'		jrst	shost1			; then
	414174'	260 17 0 00 414213'		pushj	p,dofed			; 	display Fed first
	414175'	260 17 0 00 414232'		pushj	p,doemp
	414176'	254 00 0 00 414201'		jrst	shockp

	414177'	260 17 0 00 414232'	shost1:	pushj	p,doemp			; else	display Emp first
	414200'	260 17 0 00 414213'		pushj	p,dofed

	414201'				shockp:
	414201'	332 00 0 00 000000#		skipe	ccflg			; if ^C entered
						  jrst	[setzm	ccflg		; then exit
	414202'	254 00 0 00 417154'			 popj	p,]
	414203'	336 00 0 00 000354'		skipn	frebie			; if freebie running
	414204'	263 17 0 00 000000 		popj	p,
	414205'	336 00 1 16 000000 		skipn	@0(arg)			; if freebie issued PREgame ST command
	414206'	263 17 0 00 000000 		popj	p,
	414207'	200 01 0 00 002033'		move	t1,le.nam		; if we just did the freebies
	414210'	312 01 0 00 417141'		came	t1,[sixbit "DECWAF"]
	414211'	263 17 0 00 000000 		popj	p,			; then do the income-producers!
	414212'	254 00 0 00 414147'		jrst	shopay

	414213'	336 00 0 00 000557'	dofed:	skipn	stabuf+3		; if living Federation Captains
	414214'	254 00 0 00 414223'		jrst	dofed0			; then
						movei	p1,[asciz "
					The Federation has awarded the
					following Captains the Emerald
					Star Cluster for outstanding
					service:

	414215'	201 12 0 00 417156'	"]
	414216'	260 17 0 00 406710'		pushj	p,ostr.
	414217'	201 05 0 00 000557'		movei	x1,stabuf+3
	414220'	260 17 0 00 414251'		pushj	p,dspsta		; display them
	414221'	332 00 0 00 000000#		skipe	ccflg			; if ^C typed
	414222'	263 17 0 00 000000 		  popj	p,
	414223'	336 00 0 00 000723'	dofed0:	skipn	stabuf+3+knstat*^d10	; if any that have expired
	414224'	263 17 0 00 000000 		  popj	p,
						movei	p1,[asciz "

					The Golden Galaxy Medal has been
					awarded in memory of these brave
					Captains:

	414225'	201 12 0 00 417204'	"]
	414226'	260 17 0 00 406710'		pushj	p,ostr.
	414227'	201 05 0 00 000723'		movei	x1,stabuf+3+knstat*^d10
	414230'	260 17 0 00 414251'		pushj	p,dspsta
	414231'	263 17 0 00 000000 		popj	p,

	414232'	336 00 0 00 001157'	doemp:	skipn	stabuf+3+^d256		; if any meritorous Empire Captains
	414233'	254 00 0 00 414242'		jrst	doemp0			; then display them
						movei	p1,[asciz "

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-10
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

					The following Captains have served
					their Empire well:

	414234'	201 12 0 00 417226'	"]
	414235'	260 17 0 00 406710'		pushj	p,ostr.
	414236'	201 05 0 00 001157'		movei	x1,stabuf+3+^d256
	414237'	260 17 0 00 414251'		pushj	p,dspsta
	414240'	332 00 0 00 000000#		skipe	ccflg
	414241'	263 17 0 00 000000 		  popj	p,
	414242'	336 00 0 00 001323'	doemp0:	skipn	stabuf+3+^d256+knstat*^d10
	414243'	263 17 0 00 000000 		  popj	p,
						movei	p1,[asciz "

					The Distinguished Service Cross
					has been posthumously awarded
					to the following Captains for
					their outstanding service:

	414244'	201 12 0 00 417243'	"]
	414245'	260 17 0 00 406710'		pushj	p,ostr.
	414246'	201 05 0 00 001323'		movei	x1,stabuf+3+^d256+knstat*^d10
	414247'	260 17 0 00 414251'		pushj	p,dspsta
	414250'	263 17 0 00 000000 		popj	p,

	414251'				dspsta:
	414251'	332 00 0 00 000000#		skipe	ccflg			; if ^C typed
	414252'	263 17 0 00 000000 		popj	p,			; then quit
						save	<x1,x2,x3,x4>^
						  xlist
						  list
						^
	414257'	201 07 0 00 000001 		movei	x3,1			; begin with #1
	414260'	200 10 0 00 000005 		move	x4,x1			; save pointer
						movei	p1,[asciz "
	414261'	201 12 0 00 417275'	Captain        Service # Credits"];pretty changes drforbin(merlyn)
	414262'	260 17 0 00 406710'		pushj	p,ostr.
					;	ldb	t1,[point 9,1+uster.##,8];edit here drforbin(merlyn)
	414263'	337 00 1 16 000000 		skipg	@0(arg)			; if doing *Zap then use long form
					;	cail	t1,^d64 ;drforbin
						jrst	[
							movei	p1,[asciz " Ship        Runtm Date"]
							pushj	p,ostr.
							jrst	.+1
	414264'	254 00 0 00 417311'			]
	414265'	260 17 0 00 406616'		pushj	p,crlf
	414266'	336 00 0 10 000000 	dspst0:	skipn	0(x4)			; if no more to do
	414267'	254 00 0 00 414367'		jrst	dspst1			; then exit
					;++
	414270'	201 11 0 00 000040 		movei	c," "
	414271'	554 01 0 10 000011 		hlrz	t1,9(x4)		; if killed in action
	414272'	336 00 0 00 000001 		skipn	t1
	414273'	201 11 0 00 000052 		movei	c,"*"			; then flag it
	414274'	260 17 0 00 406077'		pushj	p,ochr.
	414275'	200 05 0 10 000001 		move	x1,1(x4)		; output Captain's name
	414276'	260 17 0 00 407014'		pushj	p,osix.
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-11
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

	414277'	200 05 0 10 000002 		move	x1,2(x4)
	414300'	260 17 0 00 407014'		pushj	p,osix.
	414301'	260 17 0 00 406612'		pushj	p,ospc.
	414302'	554 05 0 10 000000 		hlrz	x1,0(x4)		; output PPN
	414303'	201 06 0 00 000006 		movei	x2,6
	414304'	260 17 0 00 407045'		pushj	p,ooct.
	414305'	201 11 0 00 000055 		movei	c,"-"
	414306'	260 17 0 00 406077'		pushj	p,ochr.
	414307'	550 05 0 10 000000 		hrrz	x1,0(x4)
	414310'	400 06 0 00 000000 		setz	x2,
	414311'	260 17 0 00 407045'		pushj	p,ooct.
	414312'	275 06 0 00 000005 		subi	x2,5
	414313'	260 17 0 00 406612'		pushj	p,ospc.
	414314'	341 06 0 00 414313'		aojl	x2,.-1
	414315'	200 05 0 10 000006 		move	x1,6(x4)		; points
	414316'	271 05 0 00 000500 		addi	x1,500			; round
	414317'	231 05 0 00 001750 		idivi	x1,^d1000
	414320'	201 06 0 00 000006 		movei	x2,^d6
	414321'	260 17 0 00 407035'		pushj	p,odec.
					;	ldb	t1,[point 9,1+uster.##,8]	; if wide terminal;edit drforbin(merlyn)
	414322'	200 01 0 00 000000#		move	t1,terwid
	414323'	333 00 1 16 000000 		skiple	@0(arg)				; or doing *Zap
	414324'	254 00 0 00 414327'		jrst	.+3
	414325'	305 01 0 00 000120 		caige	t1,^d80		;test;drforbin
	414326'	254 00 0 00 414366'		jrst	dspst2		; then
	414327'	260 17 0 00 406612'		pushj	p,ospc.
	414330'	201 12 0 10 000003 		movei	p1,3(x4)		; output ship's name
	414331'	260 17 0 00 406715'		pushj	p,ostbx.	; output to 10 spaces
	414332'	200 05 0 10 000007 		move	x1,7(x4)		; runtime
	414333'	271 05 0 00 072460 		addi	x1,^d30000		; round to nearest minute
	414334'	231 05 0 00 165140 		idivi	x1,^d60*^d1000	; convert to minutes
	414335'	201 06 0 00 000005 		movei	x2,^d5
	414336'	260 17 0 00 407035'		pushj	p,odec.
	414337'	260 17 0 00 406612'		pushj	p,ospc.


					;	movei	t1,400000		; get user's time zone
					;	calli	t1,-211-200000
					;	  setz	t1,
					;	movns	t1
					;	add	t1,5(x4)		; date/time
					;	move	t2,[exp 1b10+1b11+1b17]	;convert to string
					;	movei	t3,tmp
					;	calli	t1,-213
					;	jrst	dspst2
					;	movei	p1,tmp
					;	pushj	p,ostr.

	414340'	201 12 0 00 417314'		movei	p1,[asciz "   "];drforbin code
	414341'	260 17 0 00 406710'		pushj	p,ostr.
	414342'	200 01 0 10 000005 		move	t1,5(x4)
						dacon	t1,day#,month#,year#^
	414343'	231 01 0 00 000037 		idivi	t1,^D31
	414344'	271 02 0 00 000001 		addi	t2,1
	414345'	202 02 0 00 414764'		movem	t2,day#
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 74-12
WARMAC	MAC	 7-Jul-;2 18:15		updsta/shosta - Player Status register

	414346'	231 01 0 00 000014 		idivi	t1,^D12
	414347'	271 02 0 00 000001 		addi	t2,1
	414350'	202 02 0 00 414765'		movem	t2,month#
	414351'	271 01 0 00 003654 		addi	t1,^D1964
	414352'	275 01 0 00 003720 		subi	t1,^D2000
	414353'	202 01 0 00 414767'		movem	t1,year#
						^
	414354'	200 05 0 00 414764'		move	x1,day
	414355'	260 17 0 00 406753'		pushj	p,o2dg.
	414356'	201 12 0 00 417315'		movei	p1,[asciz "/"]
	414357'	260 17 0 00 406710'		pushj	p,ostr.
	414360'	200 05 0 00 414765'		move	x1,month
	414361'	260 17 0 00 406753'		pushj	p,o2dg.
	414362'	201 12 0 00 417315'		movei	p1,[asciz "/"]
	414363'	260 17 0 00 406710'		pushj	p,ostr.
	414364'	200 05 0 00 414767'		move	x1,year
	414365'	260 17 0 00 406753'		pushj	p,o2dg.;drforbin end code

	
	414366'	260 17 0 00 406616'	dspst2:	pushj	p,crlf
	414367'	271 10 0 00 000012 	dspst1:	addi	x4,knstat
	414370'	350 00 0 00 000007 		aos	x3
	414371'	307 07 0 00 000012 		caig	x3,knstat
	414372'	254 00 0 00 414266'		jrst	dspst0
						restor <x4,x3,x2,x1>^
						  xlist
						  list
						^
	414407'	336 00 0 00 000000#		skipn	hungup
	414410'	067 00 0 00 000000 		output	tty,
	414411'	263 17 0 00 000000 		popj	p,
	414412'	263 17 0 00 000000 		popj	p,
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75
WARMAC	MAC	 7-Jul-;2 18:15		END

						subttl	END

					; Get here on an APR trap (data out of bounds/pdl overflow)

	414413'	476 00 0 00 000000#	aprtrp:	setom	addrck		; we had a failure
	414414'	202 00 0 00 000556'		movem	0,stabuf+2	; save regs
	414415'	200 00 0 00 417332'		move	0,[1,,stabuf+3]
	414416'	251 00 0 00 000575'		blt	0,stabuf+21
	414417'	550 01 0 00 000000*		hrrz	t1,.jbtpc##	; save address
	414420'	552 01 0 00 000554'		hrrzm	t1,stabuf
	414421'	200 01 0 01 000000 		move	t1,0(t1)
	414422'	202 01 0 00 000555'		movem	t1,stabuf+1
	414423'	200 01 0 00 000356'		move	t1,locked		; preserve current locked address
	414424'	506 01 0 00 000554'		hrlm	t1,stabuf
	414425'	200 17 0 00 417333'		move	p,[iowd pdlsiz,stabuf+^d128]	; in case stack is messed up
	414426'	200 15 0 00 414771'		move	s,[iowd stksiz,stk]
	414427'	260 17 0 00 412265'		pushj	p,gripe		; put data into gripe file
	414430'	200 17 0 00 414770'		move	p,[iowd pdlsiz,pdl]
	414431'	332 01 0 00 000355'		skipe	t1,ftlerr	; if setftl called
	414432'	254 00 0 01 000000 		jrst	0(t1)		; then go there
	414433'	201 16 0 00 417335'		movei	16,[[5]]	; gen one of 5 possible fatal errors
	414434'	200 01 0 00 000000 		move	1,0
	414435'	051 03 1 01 000000 		outstr	@0(1)
	414436'	254 00 0 00 405556'		jrst	monit

	414437'				fmsgs:	exp	[asciz	"
					You have blundered into an ancient
					Romulan space mine.  Being made of a
					special plastic which is nearly trans-
					parent to nearly all wavelenths of 
					radiation, you are forgiven.
					Perhaps your crew also forgave you
					as their bodies went up in a blast
					of quarks!
	414437'	000000	417336'		"]

						exp	[asciz "
					A delayed-action virus, picked up
					by your Navigation Officer on
					Xyglion IV during R&R, has 
					spread throughout the entire crew.
					Unfortunately, the medical crew 
					has been unaware of it, and it has
					suddenly and simultaneously killed
					every living thing aboard.
	414440'	000000	417424'		"]

						exp	[asciz "
					Due to an oversight by the designers,
					the Doomsday device has detonated.
					Unfortunately, the information as to
					what caused it to happen will never
					be relayed home!
	414441'	000000	417512'		"]

WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-1
WARMAC	MAC	 7-Jul-;2 18:15		END

						exp	[asciz "
					Your ship's hull has been eaten through
					by a Space Mole, a creature about the
					size of a grape and composed of pure
					energy.  Fortunately, word of this new
					menace was sent homeward abord a distress
					beacon immediately prior to the final
					disruption of the ship's life support
					systems.
	414442'	000000	417555'		"]

						exp	[asciz "
					A slight navigational error has placed 
					your ship in a magnetic vortex.  This
					tremendous storm, equivalent to an
					Eartly tornado, has torn your ship
					apart.  The crew died almost instantly.
					Perhaps we will oneday capture the
					Romulan's Vortex Detector and be safe
					from this menace!
	414443'	000000	417650'		"]

						entry	aprset		; set fatal return for APR trap
	414444'	201 00 1 16 000000 	aprset:	movei	0,@0(arg)
	414445'	202 00 0 00 000355'		movem	0,ftlerr
	414446'	263 17 0 00 000000 		popj	p,
						page
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-2
WARMAC	MAC	 7-Jul-;2 18:15		*Zap	- clear statistics data files

						subttl *Zap	- clear statistics data files
						entry	stazap
	414447'				stazap:	outstr	[asciz "
	414447'	051 03 0 00 417742'	Zapping statistics logs...."]
	414450'	201 01 0 00 000554'		movei	t1,stabuf	; lock the files
	414451'	260 17 0 00 411776'		pushj	p,lock.
	414452'	332 00 0 00 000000#		skipe	lkfail
	414453'	254 00 0 00 414450'		jrst	.-3
	414454'	201 01 0 00 000001 		movei	t1,1			; tell gripe what's happening
	414455'	202 01 0 00 000000#		movem	t1,addrck
	414456'	260 17 0 00 412265'		pushj	p,gripe			; record the data
	414457'	201 01 0 00 001177 		movei	t1,5*^d128-1		; zap everything
	414460'	402 00 0 01 000554'		setzm	stabuf(t1)
	414461'	367 01 0 00 414460'		sojg	t1,.-1
	414462'	200 05 0 00 416634'		move	x1,[staupd,,staupd]
	414463'	260 17 0 00 405725'		pushj	p,open.
	414464'	254 00 0 00 414501'		  jrst	stzapx			; report failure
	414465'	067 06 0 00 001754'		output	sta,staiow
	414466'	070 06 0 00 000000 		close	sta,
	414467'	200 05 0 00 416660'		move	x1,[stfupd,,stfupd]	; zap freebies
	414470'	260 17 0 00 405725'		pushj	p,open.
	414471'	254 00 0 00 414501'		  jrst	stzapx
	414472'	067 06 0 00 001754'		output	sta,staiow
	414473'	070 06 0 00 000000 		close	sta,
	414474'	201 01 0 00 000554'	stzap0:	movei	t1,stabuf		; release the files
	414475'	260 17 0 00 412142'		pushj	p,unlo.
						outstr	[asciz "
					Finished!
	414476'	051 03 0 00 417750'	"]
	414477'	402 00 0 00 000000#		setzm	addrck
	414500'	263 17 0 00 000000 		popj	p,

	414501'				stzapx:	outstr	[asciz "

					Can't open file for output!

	414501'	051 03 0 00 417753'	"]
	414502'	254 00 0 00 414474'		jrst	stzap0
	414503'	263 17 0 00 000000 		popj	p,

						page
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-3
WARMAC	MAC	 7-Jul-;2 18:15		ROMSPK - The Romulan speaks!

						subttl	ROMSPK - The Romulan speaks!

						entry	romspk
	414504'				romspk:
						save <arg>^
						  xlist
						  list
						^
	414505'	332 00 0 00 000000#		skipe	player		; if the Romulan has just reincarnated
	414506'	254 00 0 00 414515'		jrst	rmspk0		; then
	414507'	201 16 0 00 417764'		movei	arg,[[3]]	; choose who gets the message
	414510'	260 17 0 00 407653'		pushj	p,iran
	414511'	200 01 0 00 000000 		move	t1,0
	414512'	202 01 0 00 001767'		movem	t1,tmp		; save the target population
						move	t1,-1+[	777777	; all
								000777	; humans (Federation)
								777000	; klingons (Empire)
	414513'	200 01 0 01 417764'				](t1)
	414514'	254 00 0 00 414520'		jrst	rmspk1

	414515'	200 01 0 00 000000#	rmspk0:	move	t1,who		; get bit for the talking player
	414516'	200 01 0 01 000000#		move	t1,bits-1(t1)
	414517'	402 00 0 00 001767'		setzm	tmp		; remember single player!
	414520'	202 01 0 00 000000#	rmspk1:	movem	t1,dbits
	414521'	201 01 0 00 000764 		movei	t1,dxrom*^d100
	414522'	202 01 0 00 000000#		movem	t1,dispfr	; say that the Romulan is speaking
						restore <arg>^
						  xlist
						  list
						^
	414526'	201 12 1 16 000000 		movei	p1,@0(arg)	; init pointer to destination string
	414527'	505 12 0 00 440700 		hrli	p1,(point 7,0)
	414530'	201 16 0 00 417774'		movei	arg,[[4]]	; get leadin
	414531'	260 17 0 00 407653'		pushj	p,iran
	414532'	370 01 0 00 000000 		sos	t1,0
						move	p2,[	point 7,[asciz "Death to "]
								point 7,[asciz "Destruction to "]
								point 7,[asciz "I will crush "]
								point 7,[asciz "Prepare to die, "]
	414533'	200 13 0 01 420012'			](t1)
	414534'	336 00 0 00 001767'		skipn	tmp		; if single player response
						move	p2,[	point 7,[asciz "You have aroused my wrath, "]
								point 7,[asciz "You will witness my vengence, "]
								point 7,[asciz "May you be attacked by a slime-devil, "]
								point 7,[asciz "I will reduce you to quarks, "]
	414535'	200 13 0 01 420051'			](t1)
	414536'	260 17 0 00 414565'		pushj	p,rmcopy	; copy to destination
	414537'	201 16 0 00 417335'		movei	arg,[[5]]	; get adjective
	414540'	260 17 0 00 407653'		pushj	p,iran
	414541'	370 13 0 00 000000 		sos	p2,0
						move	p2,[	point 7,[asciz "mindless "]
								point 7,[asciz "worthless "]
								point 7,[asciz "ignorant "]
								point 7,[asciz "idiotic "]
								point 7,[asciz "stupid "]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-4
WARMAC	MAC	 7-Jul-;2 18:15		ROMSPK - The Romulan speaks!

	414542'	200 13 0 13 420070'			](p2)
	414543'	260 17 0 00 414565'		pushj	p,rmcopy
	414544'	371 13 0 00 001767'		sosl	p2,tmp		; if broadcasting
						skipa	p2,[	point 7,[asciz "sub-Romulan "]
								point 7,[asciz "human "]
								point 7,[asciz "klingon "]
	414545'	334 13 0 13 420104'			](p2)
	414546'	260 17 0 00 414572'		pushj	p,rmgply	; else get player-specific quip
	414547'	260 17 0 00 414565'		pushj	p,rmcopy
	414550'	201 16 0 00 417335'		movei	arg,[[5]]	; get object
	414551'	260 17 0 00 407653'		pushj	p,iran
	414552'	370 13 0 00 000000 		sos	p2,0
						move	p2,[	point 7,[asciz "mutant"]
								point 7,[asciz "cretin"]
								point 7,[asciz "toad"]
								point 7,[asciz "worm"]
								point 7,[asciz "parasite"]
	414553'	200 13 0 13 420117'			](p2)
	414554'	260 17 0 00 414565'		pushj	p,rmcopy
	414555'	201 11 0 00 000163 		movei	c,"s"
	414556'	331 00 0 00 001767'		skipl	tmp			; if not single player
	414557'	136 11 0 00 000012 		idpb	c,p1			; then make the object plural
	414560'	201 11 0 00 000041 		movei	c,"!"
	414561'	136 11 0 00 000012 		idpb	c,p1
	414562'	400 11 0 00 000000 		setz	c,
	414563'	136 11 0 00 000012 		idpb	c,p1			; tack on a null
	414564'	263 17 0 00 000000 		popj	p,

	414565'	134 11 0 00 000013 	rmcopy:	ildb	c,p2		; copy (p2) to (p1)
	414566'	336 00 0 00 000011 		skipn	c
	414567'	263 17 0 00 000000 		popj	p,
	414570'	136 11 0 00 000012 		idpb	c,p1
	414571'	254 00 0 00 414565'		jrst	rmcopy

	414572'				rmgply:	
	414572'	201 16 0 00 417764'		movei	arg,[[3]]	; 33% chance of node-specific quip
	414573'	260 17 0 00 407653'		pushj	p,iran
	414574'	302 00 0 00 000001 		caie	0,1
	414575'	254 00 0 00 414620'		jrst	rmgprn		; else make up random one
	414576'	047 01 0 00 000034 		getlin	t1,		; get terminal name
	414577'	514 01 0 00 000001 		hrlz	t1,t1		; put node name in left half
	414600'	400 02 0 00 000000 		setz	t2,		; search node name table
	414601'	510 03 0 02 414627'	rmgpl0:	hllz	t3,nodnam(t2)
	414602'	322 03 0 00 414610'		jumpe	t3,rmgpl1	; jump if node not found
	414603'	312 01 0 00 000003 		came	t1,t3
	414604'	344 02 0 00 414601'		aoja	t2,rmgpl0
	414605'	550 13 0 02 414627'		hrrz	p2,nodnam(t2)	; found it! get quip
	414606'	505 13 0 00 440700 		hrli	p2,(point 7,0)
	414607'	263 17 0 00 000000 		popj	p,

	414610'	554 01 0 00 000001 	rmgpl1:	hlrz	t1,t1		; check for special node names
	414611'	405 01 0 00 000077 		andi	t1,77		; if 'CLx' or 'CSx'
	414612'	302 01 0 00 435400 		caie	t1,'CL '
	414613'	306 01 0 00 436300 		cain	t1,'CS '
						jrst	[move	p2,[point 7,[asciz "Columbus "]]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-5
WARMAC	MAC	 7-Jul-;2 18:15		ROMSPK - The Romulan speaks!

	414614'	254 00 0 00 420127'			 popj	p,]
	414615'	405 01 0 00 007777 		andi	t1,7777		; if 'Qxx'
	414616'	306 01 0 00 610000 		cain	t1,'Q  '
						jrst	[move	p2,[point 7,[asciz "Tymnet "]]
	414617'	254 00 0 00 420134'			 popj	p,]
	414620'	201 16 0 00 417335'	rmgprn:	movei	arg,[[5]]
	414621'	260 17 0 00 407653'		pushj	p,iran
	414622'	306 00 0 00 000005 		cain	0,5
						jrst	[move	t1,team		; use team basis
							 move	p2,-1+[	point 7,[asciz "human "]
									point 7,[asciz "klingon "]
								](t1)
	414623'	254 00 0 00 420136'			 popj	p,]
	414624'	370 01 0 00 000000 		sos	t1,0
						move	p2,[	point 7,[asciz "sub-Romulan "]
								point 7,[asciz "vertebrate "]
								point 7,[asciz "endo-skeletal "]
								point 7,[asciz "soft-skinned "]
	414625'	200 13 0 01 420152'			](t1)
	414626'	263 17 0 00 000000 		popj	p,

	414627'	415362	420156'		nodnam:	'AKR',,[asciz "Akron "]
	414630'	415641	420160'			'ANA',,[asciz "Anahiem "]
	414631'	416254	420162'			'ARL',,[asciz "Arlington "]
	414632'	416454	420165'			'ATL',,[asciz "Atlanta "]
	414633'	425763	420167'			'BOS',,[asciz "Boston "]
	414634'	434156	420171'			'CAN',,[asciz "Canton "]
	414635'	434751	420173'			'CGI',,[asciz "Chicago "]
	414636'	434757	420173'			'CGO',,[asciz "Chicago "]
	414637'	435156	420175'			'CIN',,[asciz "Cincinnatti "]
	414640'	436343	420200'			'CSC',,[asciz "ISD "]
	414641'	436367	420201'			'CSW',,[asciz "Wats user "]
	414642'	435447	420124'			'CLG',,[asciz "Columbus "]
	414643'	436654	420204'			'CVL',,[asciz "Cleveland "]
	414644'	444154	420207'			'DAL',,[asciz "Dallas "]
	414645'	444171	420211'			'DAY',,[asciz "Dayton "]
	414646'	444556	420213'			'DEN',,[asciz "Colorado "]
	414647'	444564	420215'			'DET',,[asciz "Detroit "]
	414650'	466467	420217'			'FTW',,[asciz "Fort Worth "]
	414651'	505765	420222'			'HOU',,[asciz "Houston "]
	414652'	515644	420224'			'IND',,[asciz "Indianapolis "]
	414653'	534351	420227'			'KCI',,[asciz "Kansas "]
	414654'	537064	420231'			'KXT',,[asciz "Knoxville "]
	414655'	544156	420234'			'LAN',,[asciz "Los Angeles "]
	414656'	545765	420237'			'LOU',,[asciz "Louisville "]
	414657'	554555	420242'			'MEM',,[asciz "Memphis "]
	414660'	555141	420244'			'MIA',,[asciz "Florida "]
	414661'	555156	420246'			'MIN',,[asciz "Minneapolis "]
	414662'	564653	420251'			'NFK',,[asciz "Norfolk "]
	414663'	565754	420253'			'NOL',,[asciz "Lousiana "]
	414664'	567143	420255'			'NYC',,[asciz "New York "]
	414665'	567146	420255'			'NYF',,[asciz "New York "]
	414666'	567156	420255'			'NYN',,[asciz "New York "]
	414667'	567167	420257'			'NYW',,[asciz "Wall Street "]
	414670'	605164	420262'			'PIT',,[asciz "Pittsburgh "]
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-6
WARMAC	MAC	 7-Jul-;2 18:15		ROMSPK - The Romulan speaks!

	414671'	605670	420265'			'PNX',,[asciz "Phoenix "]
	414672'	614241	420267'			'QBA',,[asciz "Quebec "]
	414673'	634541	420271'			'SEA',,[asciz "Seattle "]
	414674'	634641	420273'			'SFA',,[asciz "San Francisco "]
	414675'	634655	420276'			'SFM',,[asciz "California "]
	414676'	635257	420301'			'SJO',,[asciz "Silicon Gultch "]
	414677'	635443	420305'			'SLC',,[asciz "Salt Lake City "]
	414700'	636454	420311'			'STL',,[asciz "St. Louis "]
	414701'	646341	420314'			'TSA',,[asciz "Tucson "]
	414702'	646342	420314'			'TSB',,[asciz "Tucson "]
	414703'	674563	420316'			'WES',,[asciz "West Port "]
	414704'	676142	420321'			'WQB',,[asciz "Qube "]
	414705'	000000	000000			0					; end of table

						page
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-7
WARMAC	MAC	 7-Jul-;2 18:15		updnam	- update program's running name for tracking

						subttl	updnam	- update program's running name for tracking

					;	move	t1,newinfo
					;	move	t2,mask		; 77 in each position to be changed
					;	pushj	p,updnam

	414706'	263 17 0 00 000000 	updnam:	popj	17,

						save<t3>^
						  xlist
						  list
						^
	414710'	047 03 0 00 777764 		calli	t3,-14
	414711'	255 00 0 00 000000 		  jfcl
	414712'	404 01 0 00 000002 		and	t1,t2
	414713'	434 03 0 00 000002 		or	t3,t2
	414714'	430 03 0 00 000002 		xor	t3,t2
	414715'	434 03 0 00 000001 		or	t3,t1
	414716'	047 03 0 00 000043 		setnam	t3,
						restore<t3>^
						  xlist
						  list
						^
	414722'	263 17 0 00 000000 		popj	p,

					; FNDLOK	- translate lock address into six-bit chracter
					;	movei	t1,lokaddress
					;	pushj	p,fndlok
					; return with rh of t1 having the lock ID in all three 6-bit positions

	414723'				fndlok:
						save	<t2,t3>^
						  xlist
						  list
						^
	414725'	201 02 0 00 000000 		movei	t2,0
	414726'	336 00 0 02 414750'	fndlo1:	skipn	loknam(t2)
	414727'	254 00 0 00 414735'		jrst	fndlo2
	414730'	550 03 0 02 414750'		hrrz	t3,loknam(t2)
	414731'	312 03 0 00 000001 		came	t3,t1
	414732'	344 02 0 00 414726'		aoja	t2,fndlo1
	414733'	554 01 0 02 414750'		hlrz	t1,loknam(t2)
	414734'	254 00 0 00 414741'		jrst	fndlo3

	414735'	301 01 0 00 000000#	fndlo2:	cail	t1,board
	414736'	303 01 0 00 000000#		caile	t1,board+brdsiz-1	; if in the board
	414737'	334 01 0 00 420326'		skipa	t1,['???']		; then returh unknown lock
	414740'	201 01 0 00 424242 		movei	t1,'BBB'		; else return board flag
	414741'				fndlo3:	restore<t3,t2>^
						  xlist
						  list
						^
	414747'	263 17 0 00 000000 		popj	p,

	414750'	606060	000000#		loknam:	xwd	'PPP',plnlok
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-8
WARMAC	MAC	 7-Jul-;2 18:15		updnam	- update program's running name for tracking

	414751'	464646	000000#			xwd	'FFF',frelok
	414752'	616161	000000#			xwd	'QQQ',quelok
	414753'	565656	000000#			xwd	'NNN',numply
	414754'	636363	405204'			xwd	'SSS',staupd
	414755'	000000	000000			0

						page
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-9
WARMAC	MAC	 7-Jul-;2 18:15		updnam	- update program's running name for tracking


					;commented out COmpuserve's modifications (merlyn)
					;subttl cishng - establish a hang-up intercept (CIS monitor)
					;
					;	Search SYSMAC
					;opdef	getnam	[calli	-14]
					;OPDEF	STINI.	[CALLI	-162]
					;OPDEF	SCHNA.	[CALLI	-163]
					;OPDEF	SCHND.	[CALLI	-164]
					;OPDEF	SEVTA.	[CALLI	-165]
					;OPDEF	SEVTD.	[CALLI	-166]
					;OPDEF	DEBRK.	[CALLI	-174]
					;OPDEF	SRISW.	[CALLI	-175]
					;
					;cishng:	DMOVE	TA,[	-1
					;			[	2,,CHNTBL
					;				2,,LVLTBL
					;				0,,0
					;			]
					;		]
					;	STINI.	TA,
					;	  JRST	[OUTSTR	[ASCIZ "
					;? STINI. failed!
					;"]
					;		 jrst	rdwhst]
					;	DMOVE	TA,[	-1
					;			3,,1
					;		]
					;	SEVTA.	TA,
					;	  JRST	SEVFLD
					;	dmove	ta,[	-1
					;			104,,2
					;		]
					;	sevta.	ta,
					;	  jrst	sevfld
					;	DMOVE	TA,[	-1
					;			700000,,0
					;			]
					;	SCHNA.	TA,
					;	  JRST	SCHFLD
					;	popj	p,
					;;;
					;havenq:	setom	hv.lok		; tell lock. routine that we have resource
					;	movem	$v,save$v
					;	seto	$v,
					;	wake	$v,		; wake the lock. routine immediately
					;	  jfcl
					;	move	$v,save$v
					;	debrk.			; return to lock.
					;
					;hang:
					;	setom	hungup	; set hung up flag
					;	skipn	who		; if user has a ship, the he may have resource
					;	jrst	hang.4
					;	movem	$v,hang$v	; save a register
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-10
WARMAC	MAC	 7-Jul-;2 18:15		updnam	- update program's running name for tracking

					;	movem	ta,hangta	; and another
					;	movei	$v,knloks-1	; if the user has an interlock set
					;	skipn	loktab($v)
					;	sojge	$v,.-1
					;	jumpl	$v,hang.2	; then
					;	move	$v,lvltbl	; if executing a ttcall
					;hang.0:	move	ta,0($v)	; get the current instruction being executed
					;	camn	ta,[output 0,]	; or "output tty,"
					;	jrst	hang.1
					;	and	ta,[777000,,0]	; mask everything but instruction bits
					;	camn	ta,[xct]	; if doing an execute
					;	jrst	[hrrz	$v,0($v)	; then get the address of that instr.
					;		 cain	$v,$v		; if one of the saved regs
					;		 movei	$v,hang$v	; then map it into proper one
					;		 cain	$v,ta
					;		 movei	$v,hangta
					;		 jrst	hang.0]		; and look at the xct'ed instr.
					;	camn	ta,[ttcall]	; if doing a ttcall
					;hang.1:	aos	lvltbl		; then return to the ttcall + 1
					;	seto	$v,		; wake any hibernate going on
					;	wake	$v,
					;	  jfcl
					;	move	$v,hang$v
					;	move	ta,hangta
					;	debrk.			; return to main code
					;
					;hang.2:	movei	re,[who]	; release the player
					;	pushj	p,free##	; ... but good!
					;rdwhst:
					;hang.4:	debrk.	1,		; clear the interrupt system
					;	  jfcl
					;	reset			; clear bufferd I/O
					;	movei	ra,[	sixbit 'DSK'	; return to DWHOST
					;			sixbit 'DWHOST'
					;			exp 0,0,0,0
					;		]
					;	run	ra,
					;	  halt
					;
					;SCHFLD:	OUTSTR	[ASCIZ "
					;? SCHNA. failed!
					;"]
					;	jrst	rdwhst
					;SEVFLD:	OUTSTR	[ASCIZ "
					;?SEVTA> failed!
					;"]
					;	jrst	rdwhst
					;
					;chntbl:
					;	XWD	1,HANG
					;	xwd	2,havenq
					;
					;	lit		; put lits in hiseg


WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page 75-11
WARMAC	MAC	 7-Jul-;2 18:15		updnam	- update program's running name for tracking

					;below added by merlyn

						entry	onexit
	414756'	57 56 45 70 51 64 		sixbit	/onexit/
	414757'				onexit:
	414757'	047 01 0 00 000012 		monrt.
	
					;not used drforbin(merlyn)
						entry	pauses
	414760'	60 41 65 63 45 63 		sixbit	/pauses/
	414761'				pauses:
	414761'	201 01 1 16 000000 		movei 1,@0(arg)
	
	414762'	047 01 0 00 000031 		sleep 1,
	414763'	263 17 0 00 000000 		popj p,
	
						end

NO ERRORS DETECTED

HI-SEG. BREAK IS 420335
PROGRAM BREAK IS 002060
CPU TIME USED 00:01.208

74P CORE USED
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page S-1
WARMAC	MAC	 7-Jul-;2 18:15		SYMBOL TABLE

A		411531'	ext	CF.SPE		003203	spd	DISP.2		406532'		EXIT.		405554'	ent	
ABOR.1		411465'		CHKC.		413404'		DISP.3		406543'		F		000000		
ABORT		411453'		CHKC.1		413423'		DISP.4		406546'		F..		000000	spd	
ACTIVE	000000000000#	pol	CHKD.		413502'		DISPC		413331'	ent	FEDBIT		000100	spd	
ADDRCK	000000000000#	pol	CHKD.1		413533'		DISPFR	000000000000#	pol	FILOP.	047000	000155		
ALIVE	000000000000#	pol	CHKSEQ		411032'	int	DISPTO	000000000000#	pol	FL.FF		002024'		
ALLBIT		004000	spd	CHKSQ0		411042'		DISPX		413335'	ent	FMSGS		414437'		
ANUM.		406367'		CHKSQ1		411067'		DMPBUF		405713'	ent	FNDLO1		414726'		
ANUM.1		406377'		CHKSQ2		411053'		DOCKED	000000000000#	pol	FNDLO2		414735'		
ANUM.2		406407'		CHRCNT		000142'		DOEMP		414232'		FNDLO3		414741'		
ANUM.3		406415'		CLEAR		411251'	ent	DOEMP0		414242'		FNDLOK		414723'		
ANUM.4		406425'		CLOSE	070000	000000		DOFED		414213'		FO.BRH		002030'		
APRENB	047000	000016		CLOSE.		406021'		DOFED0		414223'		FO.DEV		002027'		
APRSET		414444'	ent	CLRBFI	051440	000000		DOTIME	000000000000#	pol	FO.FNC		002025'		
APRTRP		414413'		CLSBIT		020000	spd	DSPST0		414266'		FO.IOS		002026'		
ARG		000016		CMDBTS	000000000000#	pol	DSPST1		414367'		FO.LEB		002032'		
B12TBL		405264'		CMDTIM		011610		DSPST2		414366'		FO.NBF		002031'		
B7TBL		405256'		COMBLK		000000*	spd	DSPSTA		414251'		FOBLK		002025'		
BASBIT		000010	spd	COMKNT	000000000000#	pol	DV	000000000000#	pol	FORHLP		411614'	ext	
BASCMD		000002	spd	CORE	047000	000011		DXBHOL		000012	spd	FRCCHK		411027'	int	
BASE	000000000000#	pol	CPOPJ		405254'		DXEBAS		000004	spd	FREBIE		000354'		
BIT..		400000	spd	CPOPJ1		405253'		DXEPLN		000010	spd	FREE		415000'	ext	
BITS	000000000000#	pol	CR		000015		DXESHP		000002	spd	FRELOK	000000000000#	pol	
BLANK	000000000000#	pol	CRDBIT		000040	spd	DXFBAS		000003	spd	FTLERR		000355'		
BLHOPT	000000000000#	pol	CRITDM	000000000000#	pol	DXFPLN		000007	spd	GAGMSG	000000000000#	pol	
BLKMOV		411270'	ent	CRITDV	000000000000#	pol	DXFSHP		000001	spd	GAMENO	000000000000#	pol	
BLKSET		411256'	ent	CRLF		406616'	ent	DXMPTY		000000	spd	GDSP.		413363'		
BOARD	000000000000#	pol	D.		411465'	int	DXNPLN		000006	spd	GETHIT		410547'	ent	
BRDSIZ		003523	spd	DATE	047000	000014		DXROM		000005	spd	GETLCH	051300	000000		
BUFPTR		000141'		DAY		414764'		DXSTAR		000011	spd	GETLIN	047000	000034		
C		000011		DAYTIM		411302'	ent	ECHFLG		000135'		GETMSG		410764'	ent	
CAPBIT		002000	spd	DB777.	777777	777777	spd	ECHG.		406550'		GETPPN	047000	000024		
CBITS		405267'		DBITS	000000000000#	pol	ECHOFF		405705'	ent	GETSHP		410036'		
CCFLG	000000000000#	pol	DBQUE.		000000	spd	ECHON		405677'	ent	GETTAB	047000	000041		
CCFLG.		000140'	int	DBUF		001761'		EMPBIT		000200	spd	GHIT.1		410552'		
CCTRAP		411422'	ent	DBZER.		000000	spd	ENDFLG	000000000000#	pol	GHIT.2		410573'		
CF.BSC		000001	spd	DEAD	000000000000#	pol	ENQ.	047000	000151		GHIT.A		410576'		
CF.BSL		000002	spd	DEB.1		411617'		ENQC.	047000	000153		GL.ITY	400000	000000	spd	
CF.COM		020000	spd	DEB.2		411621'		EOFBLK		405250'		GMSG.1		410767'		
CF.CR		000010	spd	DEBCOM		412106'		EONBLK		405245'		GMSG.2		410774'		
CF.DEL		000003	spd	DEBDEC		412113'		EQUA.1		411675'		GNM		411141'		
CF.DIG		100000	spd	DEBFLG		001760'		EQUA.2		411712'		GNM0		411152'		
CF.DLM		010000	spd	DEBOCT		412102'		EQUA.3		411716'		GNM1		411170'		
CF.DSP		001000	spd	DEBUG		411610'	ent	EQUA.4		411720'		GNM2		411173'		
CF.EOC		000400	spd	DEBUG.	777777	777777	spd	EQUAL		411646'	ent	GNM3		411176'		
CF.EOF		000040	spd	DECI.1		405635'		EQUAL.		411662'		GNM4		411206'		
CF.EOL		000200	spd	DECIN0		405600'		ER.ICC		000002	spd	GNM5		411213'		
CF.ETG		002000	spd	DECIN1		405627'		ERFBM%		000003	spd	GPTR.		413375'		
CF.FF		000020	spd	DECINI		405576'	ent	EROM	000000000000#	pol	GREEN		000001	spd	
CF.IGN		000004	spd	DEQ.	047000	000152		EROMO	000000000000#	pol	GRIP.1		412306'		
CF.NUM		340000	spd	DEVICE	000000000000#	pol	ESHP.		413265'		GRIP.2		412544'		
CF.PNT		200000	spd	DH	000000000000#	pol	ESHP.1		413276'		GRIP.3		412552'		
CF.RPT		000100	spd	DIBUF		001764'		ETIM		411313'	ent	GRIP.4		412557'		
CF.SGN		040000	spd	DISP		413313'	ent	EXIT		405554'	ent	GRIP.5		412575'		
CF.SPC		004000	spd	DISP.		406523'		EXIT	047000	000012		GRIP.6		412607'		
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page S-2
WARMAC	MAC	 7-Jul-;2 18:15		SYMBOL TABLE

GRIP.7		412615'		IBFINS		000274'		JSQTIM		400000'		KNTURN		000003	spd	
GRIP.8		412627'		IBFLB		000271'		JSQWHO		000407'		KNUL		000000	spd	
GRIP.A		412336'		IBFPTR		000273'		KABS		000001	spd	KNXTR		000010	spd	
GRIP.B		412420'		IC		000275'		KALF		000003	spd	KPASS	000005	154513	spd	
GRIP.C		412427'		ICFLG	000000000000#	pol	KBOTH		000000	spd	KPBBAS		000005	spd	
GRIP.T		412450'		ICHR.		406150'		KCMDTM		003720	spd	KPBDAM		000003	spd	
GRIP.U		412343'		ICHR.1		406156'		KCRIT		005670	spd	KPEDAM		000001	spd	
GRIP.Z		412541'		ICHR.B		406151'		KDCOMP		000007	spd	KPEKIL		000002	spd	
GRIPE		412265'	ent	ICHR.T		406162'		KDIMP		000003	spd	KPPCAP		000004	spd	
GRIPTT		412473'		IGMBIT		000004	spd	KDLIFE		000004	spd	KPPN		000004	spd	
GRIPTU		412510'		IHITA	000000000000#	pol	KDPHAS		000006	spd	KPRKIL		000006	spd	
GROUP	000000000000#	pol	IICH.		405644'		KDRAD		000010	spd	KQLEN		000012	spd	
GRP		000003	spd	IICH.1		405655'		KDSHLD		000001	spd	KRANGE		000012	spd	
GRPFIL		405156'		IICH.2		405656'		KDTORP		000005	spd	KREL	777777	777777	spd	
GRPSIZ		000024	spd	IN	056000	000000		KDWARP		000002	spd	KRUNTM		000011	spd	
GTKN		406200'	ent	INCHWL	051200	000000		KENDAM		060650	spd	KSCMD		000002	spd	
GTKN.1		406211'		INCR.H		406172'		KEOL	777777	777777	spd	KSDAM		000011	spd	
GTKN.2		406222'		INGA.1		411756'		KFLT		000002	spd	KSHCON		000006	spd	
GTKN.3		406226'		INGAL		411751'	ent	KGALH		000113	spd	KSID		000031	spd	
GTKN.4		406247'		INI		000004	spd	KGALV		000113	spd	KSNRGY		000010	spd	
GTKN.5		406253'		INIBEG		405046'		KHPOS		000002	spd	KSPCON		000004	spd	
HALT	254200	000000		INIEXP		405076'		KILALL		412125'	int	KSSHPC		000012	spd	
HAND		000000'		INIFLG		000136'		KILH.1		411514'		KTTYN		000005	spd	
HANG$V		000005'		INIINT		405062'		KILH.2		411523'		KTTYSP		000006	spd	
HANGTA		000006'		INLI.		406431'		KILHGH		411475'	ent	KTTYTP		000007	spd	
HB.RTC	000010	000000	spd	INLI.1		406441'		KILLOW		411525'	ent	KVPOS		000001	spd	
HCPOS	000000000000#	pol	INLI.2		406444'		KILNDX	000000000000#	pol	KWAIT		352300	spd	
HELP		412661'	ent	INLI.3		406454'		KILQUE	000000000000#	pol	LABL.		410170'		
HELP.1		412672'		INLI.4		406456'		KINT		000001	spd	LABL.1		410200'		
HELP.2		412704'		INLI.5		406460'		KJOB		000001	spd	LABL.2		410203'		
HELP.3		412720'		INLI.6		406472'		KJOBTM		000010	spd	LDIS		411734'	ent	
HELP.4		412723'		INLI.7		406502'		KLFLG	000000000000#	pol	LDIS.1		411745'		
HFROM	000000000000#	pol	INPT.1		411235'		KLFSUP		000007	spd	LE.EXT		002034'		
HFZ	000000000000#	pol	INPT.2		411242'		KMAXTK		000017	spd	LE.NAM		002033'		
HI.FST	000000000000#	pol	INPUT		411215'	ent	KNAM1		000002	spd	LE.PPN		002036'		
HI.LST	000000000000#	pol	INPUT	066000	000000		KNAM2		000003	spd	LE.PRV		002035'		
HIBER	047000	000072		INTADR		001777'		KNBASE		000012	spd	LEBLK		002033'		
HISEG		000000	ext	INTBLK		001775'		KNCMD		000041	spd	LF		000012		
HITFLG	000000000000#	pol	INTFLG		002002'		KNDEV		000011	spd	LFZ	000000000000#	pol	
HITIME	000000000000#	pol	INTH.		411426'		KNGRP		000007	spd	LINBUF		000143'		
HITQ		400635'		INTSAV		002001'		KNHIT		000620	spd	LKFAIL	000000000000#	pol	
HITQL		400015'		INTTYP		002000'		KNHSHP		000050	spd	LLZ	000000000000#	pol	
HITSER		400013'		INWAIT	000000000000#	pol	KNJBST		000011	spd	LNGCND		407376'		
HL1FIL		405125'		IO.LEM		000100	spd	KNLOKS		000024	spd	LNGDEV		407347'		
HL2FIL		405143'		IO.SUP		000200	spd	KNMSG		000040	spd	LNGDSP		407266'		
HLP		000002	spd	IRAN		407653'	ent	KNOBIT		000040	spd	LNGSHP		407301'		
HLPALL		413012'	ent	IRNBIT		000001	spd	KNPCMD		000014	spd	LOC..	000000000000#	pol	
HLPXTR		412727'	ent	ISAYDO	000000000000#	pol	KNPDES		000010	spd	LOCAL		000000	ext	
HLZ	000000000000#	pol	ISRBIT		000002	spd	KNPLAY		000012	spd	LOCF		411277'	ent	
HMAX	000000000000#	pol	ISWIZ		405511'		KNPLNT		000074	spd	LOCK		411774'	ent	
HMIN	000000000000#	pol	IWHAT	000000000000#	pol	KNPOIN		000010	spd	LOCK	047000	000060		
HTO	000000000000#	pol	JOB	000000000000#	pol	KNSDES		000007	spd	LOCK.		411776'		
HUNGUP	000000000000#	pol	JOBNUM	000000000000#	pol	KNSTAT		000012	spd	LOCK.0		412027'		
HV.LOK		000007'		JOBSTA		411072'	ent	KNTORP		000005	spd	LOCK.1		412042'		
IBFCTR		000272'		JSQTAB		400001'		KNTTY		000010	spd	LOCK.3		412026'		
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page S-3
WARMAC	MAC	 7-Jul-;2 18:15		SYMBOL TABLE

LOCK.5		412023'		NEWS.4		412246'		OLDOBJ		002050'		P		000017		
LOCKED		000356'		NEWS.5		412252'		OLST.		413240'		P.DEV		000134'		
LOCPLN	000000000000#	pol	NGROUP	000000000000#	pol	OLST.1		413242'		P.NAM		000132'		
LOCR	000000000000#	pol	NKILL	000000000000#	pol	OLST.2		413243'		P.PPN		000133'		
LOCSIZ		000310	spd	NODNAM		414627'		OLST.3		413255'		P1		000012		
LOFST.		000000	spd	NOMSG	000000000000#	pol	ONEXIT		414757'	ent	P2		000013		
LOKNAM		414750'		NPLNET	000000000000#	pol	ONUM.		407062'		PASBIT		000020	spd	
LOKTAB		000363'		NTOK	000000000000#	pol	ONUM.1		407065'		PASFLG	000000000000#	pol	
LONG		000001	spd	NTRY		000036		ONUM.2		407100'		PAUS.3		411350'		
LOOKUP	076000	000000		NUMCAP	000000000000#	pol	ONUM.3		407107'		PAUS.4		411342'		
LOWSEG		000000	ext	NUMPLY	000000000000#	pol	ONUM.4		407111'		PAUSE		411323'	ent	
LSTBIT		100000	spd	NUMROM	000000000000#	pol	ONUM.5		407114'		PAUSES		414761'	ent	
LSTCMD		000000	spd	NUMSHP	000000000000#	pol	ONUM.6		407125'		PDIST		411762'	ent	
LVLTBL		000010'		NUMSID	000000000000#	pol	OOCT.		407045'		PDL		000012'		
MAKHIT		410367'	ent	NWS		000001	spd	OPEN	050000	000000		PDLSIZ		000050	spd	
MAKMSG		410663'	ent	NWSFIL		405112'		OPEN.		405725'		PDWDOC		413740'	ent	
MARK		410043'	ent	NXCH.		406513'		OPEN.1		405743'		PHBANK	000000000000#	pol	
MARK.1		410104'		NXTT.		406271'		OPEN.2		405764'		PJOB	047000	000030		
MARK.2		410111'		NXTT.1		406306'		OPEN.3		405764'		PJRST	324740	000000		
MAXCNT		000120	spd	NXTT.2		406327'		OPEN.4		405765'		PLAYER	000000000000#	pol	
MAXINT	377777	777777	spd	NXTT.3		406333'		OPEN.5		406004'		PLNBIT		000020	spd	
MEDDEV		407336'		NXTT.4		406342'		OPEN.6		406011'		PLNCMD		000003	spd	
MEDIUM		000000	spd	O2D		406702'		OPEN.7		406012'		PLNLOK	000000000000#	pol	
MHIT.1		410462'		O2DB.		406773'		OPEN.8		406000'		PPN	000000000000#	pol	
MHIT.2		410520'		O2DG.		406753'		ORNBIT		000010	spd	PRGNAM		411354'	ent	
MHIT.3		410525'		OBFCTR		000265'		OSDEC		407135'	ent	PRTBIT		000002	spd	
MHIT.A		410377'		OBFINS		000267'		OSFLT		407160'	ent	PRTYPE	000000000000#	pol	
MHIT.B		410407'		OBFLB		000264'		OSIX.		407014'		PSHP.		413277'		
MHIT2A		410516'		OBFPTR		000266'		OSIX.1		407020'		PSHP.1		413311'		
MMSG.1		410675'		OBJMSK		000077	spd	OSN1.		407054'		PT.FCN		002037'		
MMSG.2		410676'		OBJTBL		410023'		OSN2.		407055'		PT.MAX		002047'		
MMSG.3		410710'		OC		000270'		OSN3.		407056'		PT.PPN		002041'		
MMSG.4		410723'		OCFLG	000000000000#	pol	OSPC.		406612'		PT.SFD		002042'		
MMSG.5		410742'		OCHR.		406077'		OSTB.		406723'		PT.SWT		002040'		
MMSG.6		410750'		OCHR.1		406132'		OSTB.1		406730'		PTBLK		002037'		
MMSG.7		410754'		OCHR.2		406144'		OSTB.2		406736'		PTIME	000000000000#	pol	
MMSG.8		410761'		OCHR.B		406100'		OSTB.3		406737'		PTRLST	000000000000#	pol	
MONIT		405556'	ent	OCHR.T		406112'		OSTB.4		406743'		PTY		405567'	ent	
MONRT.	047040	000012		OCHR.X		406115'		OSTB.X		406724'		PWR		407675'	ent	
MONTH		414765'		OCON.1		407370'		OSTBX.		406715'		PWR.		407716'		
MSGFLG	000000000000#	pol	OCOND		407361'	ent	OSTR.		406710'		PWR.1		407735'		
MSGLEN		000021	spd	OCRL.		406616'		OSTR.X		406711'		PWR.2		407742'		
MSGQ		403776'		OCT.01		412524'		OSTS.		407404'		QRSRV.		410240'		
MSGQL		403736'		OCT.02		412530'		OSTS.P		407447'		QUELOK	000000000000#	pol	
MSTIME	047000	000023		OCT.O		412522'		OTIM		406662'	ent	QUEREQ		002054'		
NAM1	000000000000#	pol	ODEC		407136'	ent	OUT		406554'	ent	QUEUE		002053'		
NAM2	000000000000#	pol	ODEC.		407035'		OUT	057000	000000		QUEUEN		002056'		
NAMBIT		000001	spd	ODEV		407314'	ent	OUT2C		406634'	ent	QUPDT.		410300'		
NAMES	000000000000#	pol	ODIM..		000310	spd	OUT2W		406651'	ent	RAN		407660'	ent	
NBASE	000000000000#	pol	ODISP		407223'	ent	OUTC		406630'	ent	RAN.		407663'		
NEUBIT		001000	spd	OFLG	000000000000#	pol	OUTCHR	051040	000000		RED		000003	spd	
NEWS		412200'	ent	OFLT		407164'	ent	OUTMSK		140000	spd	RELOC.		410125'		
NEWS.1		412210'		OFLT.1		407205'		OUTPUT	067000	000000		REMV.		410341'		
NEWS.2		412211'		OGCH.		412637'		OUTSTR	051140	000000		REMV.1		410364'		
NEWS.3		412231'		OGCH.1		412650'		OUTW		406642'	ent	REMV.2		410365'		
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page S-4
WARMAC	MAC	 7-Jul-;2 18:15		SYMBOL TABLE

REMV.X		410351'		SHCNFR	000000000000#	pol	SPACES		406604'	ent	TF.EOL		000004	spd	
REN		000005	spd	SHCNTO	000000000000#	pol	SPCS.		406605'		TF.NEG		000100	spd	
RENAME	055000	000000		SHJUMP	000000000000#	pol	SRCH.		410312'		TF.NNM		000002	spd	
RESET	047000	000000		SHLP.		413023'		SRCH.1		410326'		TF.NUM		000001	spd	
RESET.		405470'	ent	SHLP.1		413040'		SRCH.2		410335'		TF.PNT		000040	spd	
RMCOPY		414565'		SHLP.2		413043'		SRCH.3		410340'		TF.SGN		000020	spd	
RMGPL0		414601'		SHLP.3		413046'		SRCH.X		410324'		TIM0	000000000000#	pol	
RMGPL1		414610'		SHLP.4		413047'		STA		000006	spd	TIMCNT	000000000000#	pol	
RMGPLY		414572'		SHLP.5		413056'		STABUF		000554'	int	TIMERS		000000	ext	
RMGPRN		414620'		SHLP.6		413075'		STACAP		001554'	spd	TIMHI	000000000000#	pol	
RMSPK0		414515'		SHLP.7		413111'		STAEKA		001323'	spd	TIMIN		411552'	ent	
RMSPK1		414520'		SHLP.8		413113'		STAELV		001157'	spd	TIMLCN		000472'		
RNGBIT		010000	spd	SHLP.9		413122'		STAEMP		000755'	spd	TIMNAM	000000000000#	pol	
RNGTBL		413604'		SHLP.E		413124'		STAEND		001753'	spd	TIMOUT		411561'	ent	
ROM	000000000000#	pol	SHOCKP		414201'		STAFED		000555'	spd	TIMSRC		411574'		
ROMBIT		000400	spd	SHOPAY		414147'		STAFKA		000723'	spd	TIMSTA		000410'		
ROMCNT	000000000000#	pol	SHORT	777777	777777	spd	STAFLV		000557'	spd	TIMTOT	000000000000#	pol	
ROMOPT	000000000000#	pol	SHOST1		414177'		STAIOW		001754'		TKNLST	000000000000#	pol	
ROMSPK		414504'	ent	SHOSTA		414145'	ent	STAKIL		001566'	spd	TMP		001767'		
RPPAUS	000000000000#	pol	SHPBIT		000004	spd	STANEW		000756'	spd	TMSCOR	000000000000#	pol	
RPTFLG	000000000000#	pol	SHPCON	000000000000#	pol	STANFW		000556'	spd	TMTURN	000000000000#	pol	
RSR	000000000000#	pol	SHPDAM	000000000000#	pol	STARED		405171'		TOBANK	000000000000#	pol	
RSRV.		410232'		SHSTFR	000000000000#	pol	START		411536'	int	TOBCB		000276'		
RSRV.1		410240'		SHSTTO	000000000000#	pol	STASER		000554'	spd	TOBUF		000301'		
RSRV.2		410252'		SHTCND		407401'		STAT		407511'	ent	TPOINT	000000000000#	pol	
RSRV.3		410256'		SHTDEV		407325'		STAT.1		407567'		TRAC.		413620'		
RSRV.4		410262'		SHTDSP		407241'		STAT.2		407644'		TRAC.1		413626'		
RSRVHQ		410270'	int	SHTSHP		407254'		STAT.X		407513'		TRAC.2		413635'		
RTPAUS	000000000000#	pol	SHTYPE	000000000000#	pol	STAT.Y		407570'		TRMOP.	047000	000116		
RUN	047000	000035		SHWS.1		410147'		STAUPD		405204'		TRPADR		002003'		
RUNDEC		002051'		SHWS.2		410153'		STAZAP		414447'	ent	TRSTAT	000000000000#	pol	
RUNTIM		411306'	ent	SHWS.3		410166'		STFIOW		001756'		TTY		000000	spd	
RUNTIM	047000	000027		SHWSCN		410140'	ent	STFRED		405217'		TTYDAT	000000000000#	pol	
S		000015		SIDMSK		003700	spd	STFUPD		405232'		TTYFIL		405036'		
SAVE$V		000004'		SIZE		000310	spd	STK		000062'		TTYNUM	000000000000#	pol	
SAVR		002004'		SKIP		406565'	ent	STKSIZ		000050	spd	TTYON		405717'	ent	
SBITS	000000000000#	pol	SKIP.1		406566'		STOP.		405554'	ent	TTYSPD	000000000000#	pol	
SCALE		000137'		SKPB.		406360'		STZAP0		414474'		TTYTYP	000000000000#	pol	
SCNFLG	000000000000#	pol	SKPINC	051540	000000		STZAPX		414501'		TYPLST	000000000000#	pol	
SCORE	000000000000#	pol	SKPINL	051600	000000		SUMBIT		040000	spd	UNKCOM		411612'	ext	
SCREEN	000000000000#	pol	SLEEP	047000	000031		SUMCMD		000001	spd	UNLO.		412142'		
SDSP.		413366'		SLPTIM		000144		SVLOCK		000357'		UNLOCK		412121'	ent	
SEED		002023'		SLST.		413143'		SYSPPN	000001	000027	spd	UPDCAP		413652'	ent	
SETDSP		413342'	ent	SLST.1		413151'		T..		000001	spd	UPDCAX		413667'		
SETI.		406060'		SLST.2		413155'		T0		000000		UPDCAY		413706'		
SETNAM	047000	000043		SLST.3		413163'		T1		000001		UPDNAM		414706'		
SETO.		406041'		SLST.4		413176'		T2		000002		UPDST0		414013'		
SETQH		410217'	ent	SLST.5		413203'		T3		000003		UPDST1		414134'		
SETQM		410225'	ent	SLST.6		413207'		T4		000004		UPDST2		414024'		
SETRAN		407646'	ent	SLST.7		413221'		TAB		406575'	ent	UPDST3		414072'		
SETS.1		410000'		SLST.8		413223'		TAB.		406576'		UPDST5		414054'		
SETS.2		410005'		SLST.9		413226'		TARCMD		000004	spd	UPDST8		414077'		
SETSCN		407752'	ent	SLWEST	000000000000#	pol	TEAM	000000000000#	pol	UPDST9		414142'		
SETUP		405476'	ext	SP		000040		TERWID	000000000000#	pol	UPDSTA		413745'	ent	
SETUWP	047000	000036		SPACE		406612'	ent	TF.CHR		000010	spd	UPDSTF		414124'		
WARMAC -- MACRO support routines for DECWAR.FOR	MACRO %53B(1244) 18:18  7-Jul-;2 Page S-5
WARMAC	MAC	 7-Jul-;2 18:15		SYMBOL TABLE

UPDSTX		414002'		.FORED		000001	spd	
UPDT.		410272'		.FOSAU		000004	spd	
UPST2A		414032'		.FOWRT		000003	spd	
UPST2B		414040'		.IOASC		000000	spd	
UPST5A		414071'		.IODMP		000017	spd	
USCBH.		000002'		.JBAPR		405527'	ext	
USETO	075000	000000		.JBDDT		411525'	ext	
USPPN.		414766'		.JBFF		412650'	ext	
USRN.1		411362'		.JBINT		405525'	ext	
USRN.2		411370'		.JBREL		412643'	ext	
USRN.3		411375'		.JBREN		413140'	ext	
USRN.4		411407'		.JBSA		411530'	ext	
USRN.5		411417'		.JBTPC		414417'	ext	
USRNAM		411356'	ent	.JBVER		405544'	ext	
USRPRJ		411022'	ent	.TORSP		001030	spd	
UU.PHS	400000	000000	spd	
VALLST	000000000000#	pol	
VERSIO	000000000000#	pol	
VFROM	000000000000#	pol	
VMAX	000000000000#	pol	
VMIN	000000000000#	pol	
VTO	000000000000#	pol	
WHO	000000000000#	pol	
WHOHAS		000360'		
X..		000310	spd	
X1		000005		
X2		000006		
X3		000007		
X4		000010		
XFRTM1		407503'		
XFRTMP		407502'		
XHELP	000000000000#	pol	
XHLP1		412736'		
XHLP2		412773'		
YEAR		414767'		
YELLOW		000002	spd	
Z		405475'	ext	
ZAPLOK		412135'	int	
%DEB%	777777	777777	spd	
.BFADR		000000	spd	
.BFCTR		000002	spd	
.BFPTR		000001	spd	
.FBBRH		000005	spd	
.FBBUF		000001	spd	
.FBCIO		000000	spd	
.FBDEV		000004	spd	
.FBEXT		000010	spd	
.FBFNC		000002	spd	
.FBIOS		000003	spd	
.FBNAM		000007	spd	
.FBNBF		000006	spd	
.FBPPN		000012	spd	
.FBPRV		000011	spd	
.FBSFD		000013	spd	
.FOLEB		000005	spd	
